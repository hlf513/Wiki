{"pages":[],"posts":[{"title":" 架构与表设计","date":"2017-11-16T15:35:00.000Z","path":"技术之路/数据库/Mysql/架构与表设计/","text":"数据表设计存储引擎 默认使用innodb 引擎，基本抛弃 myisam（只读也不一定比 innodb 快） text/blob 垂直拆分后，转成 myisam 表，innodb 存 blob 会产生大量的磁盘碎片 各存储引擎区别：存储引擎 字符集默认使用utf-8 注意字符集问题，server=&gt;database(trigger、stored procedure、event scheduler)=&gt;table=&gt;column不要同时指定字符集（character set）和校验集（collect set），避免出现和默认对应关系不一致 字段类型基本原则 越小越好 字段都NOT NULL 默认都加上NOT NULL约束，必须为NULL用0表示 在对该字段进行COUNT(*)统计时，统计结果更准确（值为NULL的不会被COUNT统计进去） 存储技巧 可使用枚举类型ENUM的内部存储机制是采用TINYINT或SMALLINT（并非CHAR/VARCHAR），性能一点都不差 存储ipv4地址用INT UNSIGNED存储IPV4地址，用INET_ATON()、INET_NTOA()进行转换 存储日期时间一个常识性误导：建议用TIMESTAMP取代DATETIME。从5.6开始，建议优先选择DATETIME存储日期时间。因为它的可用范围比TIMESTAMP更大，物理存储上仅比TIMESTAMP多1个字节，整体性能上的损失并不大。 InnoDB表行记录物理长度不超过8KBInnoDB的data page默认是16KB的情况下。当实际存储长度超过8KB（尤其有TEXT/BLOB列）且读写频繁的话, 则最好把这些列拆分到子表中，不要和主表放在一起存储。如果不太频繁，可以考虑继续保留在主表中[1]。 索引 显式指定自增 int/bigint unsigned not null 作为主键(有主键 TPS 提升9%，不要使用 uuid，性能差) 选择适当的索引顺序，选择性高条件靠前 基数（ Cardinality ）很低（30%以下）的字段不创建索引（MySQL还不支持 bitmap 索引） 常用排序（ORDER BY）、分组（GROUP BY）、取唯一（DISTINCT）字段上创建索引 单表索引数量不超过5个 不使用外键 超过20个长度的字符串列（不需要排序），创建前缀索引而非整列索引[6] 优点:有效提高索引利用率 缺点:对这个列排序时用不到前缀索引 高级特性使用 是否使用分区表？在可以提升性能或者运维便利性的场景下，还是建议使用分区表。例如：日志系统，按时间纬度进行分区，方便删除历史数据 是否使用存储过程、触发器？单机可用，分布式舍弃。（存储器场景：不变的业务逻辑） 是否使用视图？MySQL因为没有物化视图，因此视图尽量少用（不用） 缓存与数据库结合读取优缺点优点：可以减少数据库读取请求缺点：增加代码复杂度、增加维护难度 如何使用？ 评估进入缓存的数据规模，以及命中率优化[2] 不是所有数据都适合被缓存，也并不是进入了缓存就意味着效率提升 命中率是第一要评估的数据；核心在于如何判断哪些属于热点数据 善于利用内存，请注意数据存储的格式及压缩算法。 如何确定热点数据见下文 写入优缺点优点：减少数据库写入i/o压力缺点：数据不能第一时间持久化，有丢失风险 如何使用?缓存实时更新，数据库异步更新（使用队列,请注意使用increment来维持队列序号） 不要通过get-&gt;处理数据-&gt;set-&gt;更新数据的方式维护队列[3]。 使用increment存储队列编号，用标记+编号作为key存储队列内容[4]。 后台基于缓存队列读取更新数据并更新数据库[5] 基于队列读取后可以合并更新 更新合并率是重要指标 异步更新风险 前后端同时写，可能导致覆盖风险。 使用后端异步更新，前端应用程序不要写数据库，否则可能造成写入冲突。 一种兼容的解决方案是，前端和后端不要写相同的字段[7]。 缓存数据丢失或服务崩溃可能导致数据丢失风险。 如缓存中间出现故障，则缓存队列数据不会回写到数据库，而用户会认为已经完成，此时会带来比较明显的用户体验问题。 一个不彻底的解决方案是，确保高安全性，高重要性数据实时数据更新，而低安全性数据通过缓存异步回写方式完成。此外，使用相对数值操作而不是绝对数值操作更安全[8][9]。 异步更新如出现队列阻塞可能导致数据丢失风险。 异步更新通常是使用缓存队列后，在后台由cron或其他守护进程写入数据库。 如果队列生成的速度&gt;后台更新写入数据库的速度，就会产生阻塞，导致数据越累计越多，数据库响应迟缓，而缓存队列无法迅速执行，导致溢出或者过期失效。 解决办法：使用 MQ 队列产品而不使用 memcache 来进行缓存异步更新 反范式设计（冗余） 适度冗余可以减少查询请求 适度冗余可以解决分表带来的索引查询问题 适度冗余可以解决统计类负载较高的查询问题 适度冗余可以减少 io 请求频次，提高 io 支撑能力(cpu 换 io) 反范式设计的概念 无外键，无连表查询，强调索引,去关联化 不考虑触发器及其他内部的存储过程 便于分布式设计，允许适度冗余，为了容量扩展允许适度开销。 基于业务自由优化，基于i/o 或查询设计，无须遵循范式结构设计。 冗余结构设计所面临的典型场景 原有展现程序涉及多个表的查询，希望精简查询程序 数据表拆分往往基于主键，而原有数据表往往存在非基于主键的关键查询，无法在分表结构中完成。 存在较多数据统计需求（count, sum等），效率低下。 冗余造成的问题一致性问题–业务层校验 冗余设计方案基于展现的冗余设计冗余特征：字段简单，更改度不高为了简化展现程序，在一些数据表中往往存在冗余字段[13] 基于查询的冗余设计 涉及分表操作后，一些常见的索引查询可能需要跨表，带来不必要的麻烦。确认查询请求远大于写入请求时，应设置便于查询项的冗余表。 冗余表要点 数据一致性，简单说：同增，同删，同更新。 可以做全冗余，或者只做主键关联的冗余，比如通过用户名查询uid，再基于uid查询源表。 实战示例[10][11][12] 基于统计的冗余结构 为了减少会涉及大规模影响结果集的表数据操作，比如count，sum操作。应将一些统计类数据通过冗余数据结构保存。 冗余数据结构可能以字段方式存在，也可能以独立数据表结构存在，但是都应能通过源数据表恢复。 实战示例[13] 基于 io 压力优化的冗余现象： 单次请求多次写入的情况 请求频次较高，io 压力较大 存在高频读取请求，数据可靠性要求高 可用方案: 数据压缩存储 写入缓存队列 通过冗余结构，合并为一次写入[14][15] 历史数据表历史数据表对应于热点数据表，将需求较少又不能丢弃的数据存入，仅在少数情况下被访问。 主从架构基本认识 读写分离对负载的减轻远远不如分库分表来的直接。 写压力会传递给从表，只读从库一样有写压力，一样会产生读写锁！ 一主多从结构下，主库是单点隐患，很难解决（如主库当机，从库可以响应读写，但是无法自动担当主库的分发功能） 主从延迟也是重大问题。一旦有较大写入问题，如表结构更新，主从会产生巨大延迟。 优点部署简单 局限性 io 压力无法分布，性价比不高（主是多线程写，从是单线程写；分担读压力，不能分担写压力） 同步延时避免不了 一主多从，主库单点，很难自动故障转移（一从转主，其他从不能自动关联到这个新主） 应用场景一主一从 在线热备 异地分布 写分布，读统一。 仍然困难重重，受限于网络环境问题巨多！ 自动障碍转移 主崩溃，从自动接管 个人建议，负载均衡主要使用分库方案，主从主要用于热备和障碍转移。 潜在优化点为了减少写压力，有些人建议主不建索引提升i/o性能，从建立索引满足查询要求。个人认为这样维护较为麻烦。而且从本身会继承主的i/o压力，因此优化价值有限。该思路特此分享，不做推荐(caoz观点)。 分布式设计 设计分布式之前，先优化单机： 单机读 qps 几千很容易 单机写 qps 几千很容易 数据量最少在3000万以上（具体业务具体分析） 目标防止单点隐患lvs nginx（轮询，自动切换） 所谓单点隐患，就是某台设备出现故障，会导致整体系统的不可用，这个设备就是单点隐患。 理解连带效应，所谓连带效应，就是一种问题会引发另一种故障，举例而言，memcache+mysql是一种常见缓存组合，在前端压力很大时，如果memcache崩溃，理论上数据会通过mysql读取，不存在系统不可用情况，但是mysql无法对抗如此大的压力冲击，会因此连带崩溃。因A系统问题导致B系统崩溃的连带问题，在运维过程中会频繁出现。[16][17] 连带效应是常见的系统崩溃，日常分析崩溃原因的时候需要认真考虑连带效应的影响，头疼医头，脚疼医脚是不行的。 方便系统扩容 数据容量增加后，要考虑能够将数据分布到不同的服务器上。 请求压力增加时，要考虑将请求压力分布到不同服务器上。 扩容设计时需要考虑防止单点隐患。 安全可控，成本可控 数据安全，业务安全 人力资源成本 &gt; 带宽流量成本 &gt; 硬件成本 成本与流量的关系曲线应低于线性增长（流量为横轴，成本为纵轴）。 规模优势 分库&amp;分表优点 负载分担较好 不存在同步延迟 拆分方法灵活 局限性 需要有备份和自动故障转移的方案 需要应用端配合，无法完全满足关联查询的需求 推荐方案 以分库、分表为负载和数据支撑方案 以主从结构为热备和故障转移方案 使用中间件作为分布式数据库的前端（amoeba，要去关联化） 数据一致性问题解决 前端校验 后端 cron 定时跑数据 基本认识 用分库&amp;拆表是解决数据库容量问题的唯一途径。 分库&amp;拆表也是解决性能压力的最优选择。 分库 – 不同的数据表放到不同的数据库服务器中（也可能是虚拟服务器） 拆表 – 一张数据表拆成多张数据表，可能位于同一台服务器，也可能位于多台服务器（含虚拟服务器）。 去关联化原则 摘除数据表之间的关联，是分库的基础工作。 摘除关联的目的是，当数据表分布到不同服务器时，查询请求容易分发和处理。 学会理解反范式数据结构设计，所谓反范式，第一要点是不用外键，不允许Join操作，不允许任何需要跨越两个表的查询请求。第二要点是适度冗余减少查询请求[18] 去关联化处理会带来额外的考虑，比如说，某一个数据表内容的修改，对另一个数据表的影响。这一点需要在程序或其他途径去考虑。 分库方案安全性拆分运维优化，易于管理 将高安全性数据与低安全性数据分库，这样的好处第一是便于维护，第二是高安全性数据的数据库参数配置可以以安全优先，而低安全性数据的参数配置以性能优先。参见运维优化相关部分。 安全性开启参数：sync_binlog，innodb_flush_log_at_trx_commit = 2(丢失最后1s 数据);开启后性能下降10~100倍 基于业务逻辑拆分易于管理，对应用端友好，负载不能均分 根据数据表的内容构成，业务逻辑拆分，便于日常维护和前端调用。 基于业务逻辑拆分，可以减少前端应用请求发送到不同数据库服务器的频次，从而减少链接开销。 基于业务逻辑拆分，可保留部分数据关联，前端web工程师可在限度范围内执行关联查询。 基于负载压力拆分负载相对可以均摊；管理不方便 基于负载压力对数据结构拆分，便于直接将负载分担给不同的服务器。 基于负载压力拆分，可能拆分后的数据库包含不同业务类型的数据表，日常维护会有一定的烦恼。 混合拆分组合 基于安全与业务拆分为数据库实例，但是可以使用不同端口放在同一个服务器上。 基于负载可以拆分为更多数据库实例分布在不同数据库上 例如: 基于安全拆分出A数据库实例， 基于业务拆分出B,C数据库实例， C数据库存在较高负载，基于负载拆分为C1,C2,C3,C4等 实例。 数据库服务器完全可以做到 A+B+C1为一台，C2,C3,C4各单独一台。 分表方案数据量过大或者访问压力过大的数据表需要切分 纵向分表（常见为忙闲分表） 单数据表字段过多，可将频繁更新的整数数据与非频繁更新的字符串数据切分[19] 过于频繁的，使用 nosql（memcached，redis 等） 横向切表 等分切表，如哈希切表或其他基于对某数字取余的切表。等分切表的优点是负载均分；缺点是当容量继续增加时无法方便的扩容，需要重新进行数据的切分或转表。而且一些关键主键不易处理。（只能基于差存条件进行拆分，否则没法查询） 递增切表，比如每1kw用户开一个新表，优点是可以适应数据的自增趋势；缺点是往往新数据负载高（最新的表），压力分配不平均。 日期切表，适用于日志记录式数据，优缺点等同于递增切表。 个人倾向于递增切表，具体根据应用场景决定。 热点数据分表将数据量较大的数据表中将读写频繁的数据抽取出来，形成热点数据表。通常一个庞大数据表经常被读写的内容往往具有一定的集中性，如果这些集中数据单独处理，就会极大减少整体系统的负载。 热点数据表与旧有数据关系: 可以是一张冗余表，即该表数据丢失不会妨碍使用，因源数据仍存在于旧有结构中。优点是安全性高，维护方便，缺点是写压力不能分担，仍需要同步写回原系统。 可以是非冗余表，即热点数据的内容原有结构不再保存，优点是读写效率全部优化；缺点是当热点数据发生变化时，维护量较大。 具体方案选择需要根据读写比例决定，在读频率远高于写频率情况下，优先考虑冗余表方案。 数据存储：热点数据表可以用单独的优化的硬件存储，比如昂贵的闪存卡或大内存系统。 热点数据表的重要指标: 热点数据的定义需要根据业务模式自行制定策略，常见策略为，按照最新的操作时间；按照内容丰富度等等。 数据规模，比如从1000万条数据，抽取出100万条热点数据。 热点命中率，比如查询10次，多少次命中在热点数据内。 理论上，数据规模越小，热点命中率越高，说明效果越好。需要根据业务自行评估。 热点数据表的动态维护: 加载热点数据方案选择 定时从旧有数据结构中按照新的策略获取 在从旧有数据结构读取时动态加载到热点数据 剔除热点数据方案选择 基于特定策略，定时将热点数据中访问频次较少的数据剔除 如热点数据是冗余表，则直接删除即可，如不是冗余表，需要回写给旧有数据结构。 通常，热点数据往往是基于缓存或者key-value方案冗余存储，所以这里提到的热点数据表，其实更多是理解思路，用到的场合可能并不多。（适合组合条件场景，数据规模中等，像淘宝的数据量就需要第三方搜索引擎） 参考资料 [MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率 《Mysql 性能优化教程-曹政》 1.[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率 ↩2.实景分析： 前端请求先连接缓存，缓存未命中连接数据库，进行查询，未命中状态比单纯连接数据库查询多了一次连接和查询的操作；如果缓存命中率很低，则这个额外的操作非但不能提高查询效率，反而为系统带来了额外的负载和复杂性，得不偿失。 ↩3.范例:$var=Memcache_get($memcon,”var”);$var++;memcache_set($memcon,”var”,$var);这样一个脚本，使用apache ab去跑，100个并发，跑10000次，然后输出缓存存取的数据，很遗憾，并不是1000，而是5000多，6000多这样的数字，中间的数字全在 get &amp; set的过程中丢掉了。原因：读写间隔中其他并发写入，导致数据丢失。 ↩4.范例2:用memcache_increment来做这个操作，同样跑测试会得到完整的10000，一条数据不会丢。 ↩5.实战范例：某论坛热门贴，前端不断有views=views+1数据更新请求。缓存实时更新该状态后台任务对数据库做异步更新时，假设执行周期是5分钟，那么五分钟可能会接收到这样的请求多达数十次乃至数百次，合并更新后只执行一次update即可。类似操作还包括游戏打怪，生命和经验的变化；个人主页访问次数的变化等。 ↩6.例如：ALTER TABLE t1 ADD INDEX(user(20))前缀索引的长度可以基于对该字段的统计得出，一般略大于平均长度一点就可以了。 ↩7.实战范例：用户在线上时，后台异步更新用户状态。管理员后台屏蔽用户是直接更新数据库。结果管理员屏蔽某用户操作完成后，因该用户在线有操作，后台异步更新程序再次基于缓存更新用户状态，用户状态被复活，屏蔽失效。 ↩8.范例：支付信息，道具的购买与获得，一旦丢失会对用户造成极大的伤害。而经验值，访问数字，如果只丢失了很少时间的内容，用户还是可以容忍的。 ↩9.范例：如果使用 Views=Views+…的操作，一旦出现数据格式错误，从binlog中反推是可以进行数据还原，但是如果使用Views=特定值的操作，一旦缓存中数据有错误，则直接被赋予了一个错误数据，无法回溯！ ↩10.实战范例1: 用户分表将用户库分成若干数据表;基于用户名的查询和基于uid的查询都是高并发请求。用户分表基于uid分成数据表，同时基于用户名做对应冗余表。如果允许多方式登陆，可以有如下设计方法：uid,passwd,用户信息等等，主数据表，基于uid分表ukey,ukeytype,uid 基于ukey分表，便于用户登陆的查询。分解成如下两个SQL:select uid from ulist_key_13 where ukey=’$username’ and ukeytype=‘login’;select from ulist_uid_23 where uid=$uid and passwd=’$passwd’;ukeytype定义用户的登陆依据，比如用户名，手机号，邮件地址，网站昵称等。 Ukey+ukeytype 必须唯一此种方式需要登陆密码统一，对于第三方connect接入模式，可以通过引申额外字段完成 ↩11.实战范例2：用户游戏积分排名表结构 uid,gameid,score 参见前文实时积分排行。表内容巨大，需要拆表。需求1：基于游戏id查询积分排行需求2：基于用户id查询游戏积分记录解决方案：建立完全相同的两套表结构，其一以uid为拆表主键，其二以gameid为拆表主键，用户提交积分时，向两个数据结构同时提交。 ↩12.实战范例3：全冗余查询结构主信息表仅包括 主键及备注memo字段（text类型），只支持主键查询，可以基于主键拆表。所以需要展现和存储的内容均在memo字段重体现。对每一个查询条件，建立查询冗余表，以查询条件字段为主键，以主信息表主键id 为内容。日常查询只基于查询冗余表，然后通过in的方式从主信息表获得内容。优点是结构扩展非常方便，只需要扩展新的查询信息表即可，核心思路是，只有查询才需要独立的索引结构，展现无需独立字段。缺点是只适合于相对固定的查询架构，对于更加灵活的组合查询束手无策。 ↩13.举例，信息表 message，存在字段 fromuid,touid,msg,sendtime 四个字段，其中 touid+sendtime是复合索引。存在查询为 select from message where touid=$uid order by sendtime desc limit 0,30;展示程序需要显示发送者姓名，此时通常会在message表中增加字段fromusername，甚至有的会增加fromusersex，从而无需连表查询直接输出信息的发送者姓名和性别。这就是一种简单的，为了避免连表查询而使用的冗余字段设计。 ↩13.实战范例：论坛板块的发帖量，回帖量，每日新增数据等。网站每日新增用户数等。参见Discuz论坛系统数据结构，有较多相关结构。参见前文分段积分结构，是典型用于统计的冗余结构。后台可以通过源数据表更新该数字。Redis的Zset类型可以理解为存在一种冗余统计结构。 ↩14.游戏组队，5个武将。（建立临时的武将表，定时更新到主表） ↩15.实时统计 ↩16.实战范例： 在mysql连接不及时释放的应用环境里，当网络环境异常（同机房友邻服务器遭受拒绝服务攻击，出口阻塞），网络延迟加剧，空连接数急剧增加，导致数据库连接过多崩溃。 ↩17.实战范例：前端代码 通常我们封装 mysql_connect和memcache_connect，二者的顺序不同，会产生不同的连带效应。如果mysql_connect在前，那么一旦memcache连接阻塞，会连带mysql空连接过多崩溃。 ↩18.比如说，信息表，fromuid, touid, message字段外，还需要一个fromuname字段记录用户名，这样查询者通过touid查询后，能够立即得到发信人的用户名，而无需进行另一个数据表的查询。 ↩19.范例: user表 ，个人简介，地址，QQ号，联系方式，头像 这些字段为字符串类型，更新请求少； 最后登录时间，在线时常，访问次数，信件数这些字段为整数型字段，更新频繁，可以将后面这些更新频繁的字段独立拆出一张数据表，表内容变少，索引结构变少，读写请求变快。 ↩","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"数据库","slug":"技术之路/数据库","permalink":"http://yoursite.com/categories/技术之路/数据库/"},{"name":"Mysql","slug":"技术之路/数据库/Mysql","permalink":"http://yoursite.com/categories/技术之路/数据库/Mysql/"}]},{"title":"基础知识","date":"2017-11-16T15:24:00.000Z","path":"技术之路/数据库/Mysql/基础知识/","text":"索引Mysql 常用数据结构 B+ Tree Hash index 二者区别b+treeB+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。 在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。 B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大 Hash index简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。 哈希索引只能使用 in ，=，!= 使用场景 如果是等值查询，那么哈希索引明显有绝对优势 如果是范围查询检索，这时候哈希索引就毫无用武之地了 哈希索引也没办法利用索引完成排序 哈希索引也不支持多列联合索引的最左匹配规则 在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题 FAQ为什么使用索引能提高效率关系型数据库的数据索引（Btree及常见索引结构）的存储是有序的（在有序的情况下，通过索引查询一个数据是无需遍历索引记录的）。 「默认 b+tree索引」查询效率趋近于二分法，趋近于 log2(N)。 「hash 索引」查询效率是寻址操作，趋近于1次查询，比有序索引查询效率更高 如何理解数据索引的结构从结构 数据索引通常默认采用b+tree索引，（内存表使用了hash索引）。 单向 有序 排序序列是查找效率最高的（二分查找），使用树形索引的目的是为了达到快速的更新和增删操作。 在极端情况下（比如数据查询需求量非常大，而数据更新需求极少，实时性要求不高，数据规模有限），直接使用 单一排序序列，折半查找速度最快。 从优化 在进行索引分析和SQL优化时，可以将数据索引字段想象为单一有序序列，并以此作为分析的基础。 涉及到复合索引情况，复合索引按照索引顺序拼凑成一个字段，想象为单一有序序列，并以此作为分析的基础。 从查询优化器 一条数据查询只能使用一个索引，索引可以是多个字段合并的复合索引。但是一条数据查询不能使用多个索引。 拓展阅读 MySQL索引背后的数据结构及算法原理 MySQL索引与Index Condition Pushdown FAQ系列 | MySQL索引之聚集索引 FAQ系列 | MySQL索引之主键索引 Mysql加密mysql用户名密码公式(5.7以前)：1concat('*',sha1(unhex(sha1('mypassword')))) //等于 password('mypassword') 记录密码方式 binlog 记录密码方式 5.6以前 binlog 会打印明文密码 5.6以后 以密文方式记录 binlog 的命令 1234567CREATE USER … IDENTIFIED BY …GRANT … IDENTIFIED BY …SET PASSWORD …SLAVE START … PASSWORD = … (as of 5.6.4)CREATE SERVER … OPTIONS(… PASSWORD …) (as of 5.6.9)ALTER SERVER … OPTIONS(… PASSWORD …) (as of 5.6.9)//change master to 不在此范畴中，在启动主从时会有 warning 提示 影响结果集1explain [sql] 影响因素查询条件与索引的关系决定影响结果集。 影响结果集是什么？影响结果集不是输出结果数，不是查询返回的记录数，而是索引所扫描的结果数。 优化目标 影响结果集越趋近于实际输出或操作的目标结果集，索引效率越高。 影响结果集与查询开销的关系可以理解为线性相关。减少一半影响结果集，即可提升一倍查询效率！当一条搜索query可以符合多个索引时，选择影响结果集最少的索引。 如何优化？SQL的优化，核心就是对结果集的优化，认识索引是增强对结果集的判断，基于索引的认识，可以在编写SQL的时候，对该SQL可能的影响结果集有预判，并做出适当的优化和调整。 Limit 的影响 如果索引与查询条件和排序条件完全命中，影响结果集就是limit后面的数字（$start + $end），比如 limit 200,30 影响结果集是230. 而不是30. 如果索引只命中部分查询条件，甚至无命中条件，在无排序条件情况下，会在索引命中的结果集 中遍历到满足所有其他条件为止。 比如 select * from user limit 10; 虽然没用到索引，但是因为不涉及二次筛选和排序，系统直接返回前10条结果，影响结果集依然只有10条，就不存在效率影响。 如果搜索所包含的排序条件没有被索引命中，则系统会遍历所有索引命中的结果，并且排序。 例如 Select from user order by timeline desc limit 10; 如果timeline不是索引，影响结果集是全表，就存在需要全表数据排序，这个效率影响就巨大。再比如 Select from user where area=’厦门’ order by timeline desc limit 10; 如果area是索引，而area+timeline未建立索引，则影响结果集是所有命中 area=’厦门’的用户，然后在影响结果集内排序。 Cpu/内存/磁盘利用特点Cpu利用特点每个连接对应一个线程，每个并发query只能使用到一个核 &lt;5.1，多核心支持较弱 5.1，可利用4个核 5.5，可利用24个核 5.6，可利用64个核 内存利用特点 类似ORACLE的SGA(全局)、PGA（会话）模式，注意PGA不宜分配过大 SGA：System Global Area是Oracle Instance的基本组成部分，在实例启动时分配;系统全局域SGA主要由三部分构成：共享池、数据缓冲区、日志缓冲区。PGA：Process Global Area是为每个连接到Oracle database的用户进程保留的内存Mysql 中会话内存分配不要太大，否则会造成 OOM（out of memory） 内存管理简单、有效。在高TPS、高并发环境下，可增加物理内存以减少物理IO，提高并发性能 Mysql 锁并发竞争比较严重，MariaDB、Percona进行优化 2014年建议使用 Percona &gt; MariaDB &gt; Mysql 有类似ORACLE library cache的query cache，但效果不佳，建议关闭 Qcache有个全局锁,有数据变更，则会更新 Qcache；Dml 不频繁时（只读），Qcache 还是有用的–没有只读的场景，从服务也要写 执行计划没有缓存，每次都需要解析 SQL 通常内存建议按热点数据总量的15%-20%来规划，专用单实例则可以分配物理内存的50~70%左右 磁盘利用特点 binlog、redo log、undo log主要顺序IO datafile是主要是 「随机IO」 和顺序IO也有 OLTP业务（数据查询）以随机IO为主，建议加大内存，尽量合并随机IO为顺序IO 通过 innodb buffer 进行合并 OLAP业务（数据分析）以顺序IO为主，加大内存的同时增加硬盘数量提高顺序IO性能 MyISAM是堆组织表（HOT），InnoDB是索引组织表（IOT） MYISAM ：新写的数据放入堆的最后Innodb ：B+tree 的索引结构 InnoDB相比MyISAM更消耗磁盘空间 Innodb 的占用空间通常比 MyISAM 多1.5~2倍innodb 保存更多的数据，比如：事务信息 数据引擎Myisam速度快，响应快。表级锁是致命问题 表级锁 – 读和写是串行的 不支持事务 内存只缓存索引 Innodb目前主流存储引擎 行级锁 – 不同数据读写可并行处理 支持事务 内存缓存数据和索引 Crash Recovery – 故障自动修复，修复相比MyISAM速度更快 Memory使用 hash 索引 频繁更新和海量读取情况下仍会存在锁定状况 不支持范围查询及排序，只能=,!=,in 设计规范基本原则 减少物理I/O，让MySQL闲下来 (减少负载（前端+各级cache）) 转变随机I/O为顺序I/O （本地写队列，最后合并写） 减小活跃数据 (冷热数据分离) 分库分表 (垂直、水平拆分、分布式集群) 读写分离 (从只读，加大 buffer使读的性能更好些) OLTP、OLAP分离 禁止 禁止 Mysql 做运算 快速更新大数据表，禁止直接运行count(*)统计 数据量控制 单表行记录数控制在1000万以内，行平均长度控制在16KB以内，单表20GB以内 单实例下数据表数量不超过2000个， 单库下数据表数量不超过500个 读写 读写分离，主库只写和少量实时读取请求，统计在从库上执行 采用队列方式合并多次写请求， 持续写入， 避免瞬间压力 存储 「垂直拆分」超长text/blob进行垂直拆分，并先行压缩 「水平拆分」冷热数据进行水平拆分，LRU原则 压力分散，在线表和归档表（日志表）分开存储 SQL规范 注意引号问题会导致类型转换（where id = ‘1234’） 过滤用户提交SQL，防止注入 杜绝 like ‘%xxx%’，不用/少用 like ‘xxx%’ 不用/少用子查询，改造成连接（JOIN） 不用/少用FOR UPDATE、LOCK IN SHARE MODE，防止锁范围扩大化 参考资料 FAQ系列 | B+树索引和哈希索引的区别","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"数据库","slug":"技术之路/数据库","permalink":"http://yoursite.com/categories/技术之路/数据库/"},{"name":"Mysql","slug":"技术之路/数据库/Mysql","permalink":"http://yoursite.com/categories/技术之路/数据库/Mysql/"}]},{"title":"Git 常用命令","date":"2017-11-16T13:21:00.000Z","path":"技术之路/GIT/git/","text":"工作流程图 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 GIT 配置Git的设置文件为.git/config，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置:git config --list 编辑Git配置文件:git config -e [--global] 设置提交代码时的用户信息git config [--global] user.name [name]git config [--global] user.email [email address] 新建代码库 当前目录空目录/拷贝的 git 目录git init 创建目录git init [project-name] 下载一个项目(包含历史)git clone [url] 本地初始化远端git remote add origin [http://xxx.git]git push -u origin master 增加/删除文件 添加指定文件到暂存区git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录git add [dir] 添加文件的部分到暂存区git add -e [file] 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file] 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 代码提交 提交暂存区到仓库区git commit -m [message] 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区git commit -a 提交时显示所有diff信息git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化git commit --amend ... 修改提交信息git rebase HEAD^^ -i//-i 是交互模式//reword 修改注释信息//squash 与之前的注释合并 暂存数据（Stage） 把文件写入 Stagegit stash save [file] 查看 Stage 列表git stash list 应用最后一个 Stagegit stash pop 应用指定的 Stagegit stash apply [stash@{1}] 远程同步 下载远程仓库的所有变动git fetch [remote] 下载远程仓库的所有taggit fetch —tags 只下载远程仓库的分支git fetch [remote] &lt;本地master&gt;:&lt;新建分支名&gt; 显示所有远程仓库git remote -v 显示某个远程仓库的信息git remote show [remote] 增加一个新的远程仓库，并命名git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch] 上传本地指定分支到远程仓库git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force 推送所有分支到远程仓库git push [remote] --all 在已有项目中添加子项目git submodule add [remote] [dir] 撤销 恢复暂存区的指定文件到工作区git checkout [file] 恢复某个commit的指定文件到工作区git checkout [commit] [file] 恢复上一个commit的所有文件到工作区git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file] 重置暂存区与工作区，与上一次commit保持一致git reset --hard 重置暂存区，保留已修改git reset —soft 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit] 新建一个commit，用来撤销指定commit#_后者的所有变化都将被前者抵消，并且应用到当前分支_git revert [commit] 分支 列出所有本地分支git branch 列出所有远程分支git branch -r 列出所有本地分支和远程分支git branch -a 新建一个分支，但依然停留在当前分支git branch [branch-name] 新建一个分支，并切换到该分支git checkout -b [branch] 新建一个分支，指向指定commitgit branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区git checkout [branch-name] 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支git merge [branch] 保留 commit 信息（即使在 fast-forward模式）git merge –no-ff [branch] 合并多个commit为一次提交git merge —squash [branch] 选择一个commit，合并进当前分支git cherry-pick [commit] 删除分支git branch -d [branch-name] 删除远程分支git push origin --deletegit branch -dr 衍合分支到主干git checkout [branch]git rebase [master] 合并分支到主干git checkout [master]git merge [branch] 标签若 tag 和 branch 重名，操作时可指定，比如：tags/v2 列出所有taggit tag 新建一个tag在当前commitgit tag [tag] 新建一个tag在指定commitgit tag [tag] [commit] 查看tag信息git show [tag] 提交指定taggit push [remote] [tag] 提交所有taggit push [remote] --tags 新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息多个条件默认是or 关系，使用 –all-match 变为 AND 关系 显示有变更的文件git status 显示当前分支的版本历史git log 显示commit历史，以及每次commit发生变更的文件git log --stat 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file] 显示指定文件相关的每一次diffgit log -p [file] 显示两个 tag 之间的版本历史git log [tag1]…[tag2] 显示指定时间范围的版本历史git log --since=2.months.ago --until=1.day.ago 显示在分支2而不在分支1上的版本历史（branch2没有提交的历史）git log [old_branch1]…[new_branch2] 搜索特定提交者git log —author=[name] 搜索历史信息git log —grep=&#39;search message&#39; 显示指定文件是什么人在什么时间修改过git blame [file] 显示暂存区和工作区的差异git diff 显示暂存区和上一个commit的差异git diff --cached 显示工作区与当前分支最新commit之间的差异git diff HEAD 显示两次提交之间的差异git diff [first-branch]...[second-branch] 显示某次提交的元数据和内容变化git show [commit] 显示某次提交发生变化的文件git show --name-only [commit] 显示某次提交时，某个文件的内容git show [commit]:[filename] 显示分支发生的变化git show [branch] 显示最后一次提交发生的变化git show HEAD 显示当前分支的最近几次提交git reflog 查找信息git grep [pattern] [search_scope] 查看分支间的关系git show-branch//(加号)表示所在分支 包含 此行所标识的 commit//(空格)表示所在分支 不包含 此行所标识的 commit//(减号)表示所在分支是经过 merge 得到的,而所在行的内容即是 merge 的基本信息//(星号)表示如果需要在某列标识+(加号),且此列为当前分支所在列,那么则将+(加号)转变为*(星号) 显示两个分支的差异git whatchanged -p [branch1]…[branch2] 其他命令 仓库移了位置git remote set-url origin &lt;new repo addr&gt; 生成一个可供发布的压缩包git archive 压缩信息，清理垃圾git gc 一致性检查git fsck 查看对象数据库#四种对象类型：blob、commit、tag、tree#commit 指向 tree#tree 显示一个目录的状态，指向 tree 或者 blob 显示对象类型git cat-file -t [ID] 显示对象信息git cat-file [type] [ID] 显示 tree 信息git ls-tree [ID] 忽略本地修改 忽略本地修改（仓库存在）git update-index --assume-unchanged [file] 删除忽略的本地修改git update-index --no-assume-unchanged [file] 意外情况 找回删除的文件git reflog / git fsck --lost-foundgit checkout [hash值] 从本地分支生成 patch（用于 email 提交）git format-patch origin 与主干同步git fetch origingit rebase origin/master 提交到了错误的分支git branch experimental //创建一个指向当前master的位置的指针git reset --hard master~3 //移动master分支的指针到3个版本之前git checkout experimental","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"GIT","slug":"技术之路/GIT","permalink":"http://yoursite.com/categories/技术之路/GIT/"}]},{"title":"TCP/IP 协议","date":"2017-11-11T03:00:00.000Z","path":"技术之路/计算机网络/tcp-ip-协议/","text":"指代整个协议族；之所以叫TCP/IP协议，是因为TCP、IP是核心的协议。 传输层TCP 协议定义 TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义 数据传输 三次握手WHY 为什么要三次握手？为了防止已失效的客户端连接请求突然又传送到了服务端，若没有客户端确认，则会占用服务端的资源。 HOW 客户端 传输 服务端 SYN(x) -&gt; SYN(x) SYN(y)-ACK(x+1) &lt;- SYN(y)+ACK(x+1) ACK(y+1) -&gt; ACK(Y+1) 必须是客户端发起的SYN SYN: 同步序列编号（Synchronize Sequence Numbers）ACK: 确认编号（Acknowledgement Number） 四次挥手WHY 为什么要四次挥手？全双工通信，所以必须双方都确认 FIN 才可以关闭连接 HOW 客户端 传输 服务端 FIN(客户端传输完毕) -&gt; FIN ACK &lt;- ACK（先确认） FIN &lt;- FIN （服务端传输完毕） ACK -&gt; ACK 客户端、服务端都可以发起 FIN FIN: 数据传输完毕 (Finsh) 包头结构 名称 长度 源端口 16位 目标端口 16位 序列号 32位 回应序号 32位 TCP头长度 4位 reserved 6位 控制代码 6位 窗口大小 16位 偏移量 16位 校验和 16位 选项 32位(可选) TCP包头的最小长度，为20字节。 UDP 协议定义一种无连接的传输层协议；可靠性通过「应用层」保证。 数据传输不提供数据包分组、组装和不能对数据包进行排序 包头结构 名称 长度 源端口 16位 目的端口 16位 长度 16位 校验和 16位 UDP包头只有8个字节 常见的协议DNS 应用场景： 面向数据报方式 网络数据大多为短消息 拥有大量Client 对数据安全性无特殊要求 网络负担非常重，但对响应速度要求高 TCP vs UDP - TCP UDP 可靠性 可靠（面向连接） 不可靠（无连接） 有序性 有序 无序 占用资源 多 少 程序结构 复杂 简单 数据模式 数据流[1]（字节流） 数据报文[2] 通信模式 点对点 一对一，一对多，多对一，多对多 首部开销 20字节 8字节 通信信道 全双工 不可靠信道 网络层IP 协议作用IP协议是TCP/IP协议簇中的核心协议，也是TCP/IP的载体。所有的TCP，UDP，ICMP及IGMP数据都以 IP数据报 格式传输。IP提供不可靠的，无连接的数据传送服务；如果发生某种错误，IP会丢失该数据，然后发送ICMP消息给信源端 IP数据报 IP路由选择局域网经过ARP协议将目的主机的IP地址解析为MAC地址 非局域网主机通过IP数据报连接目的主机时，按照如下步骤搜索: 搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机 搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要子网掩码的协助。如果找到路由器，则将该包发向路由器。 搜索路由表，如果匹配同子网路由器失败，则匹配同网号路由器，如果找到路由器，则将该包发向路由器。 搜索路由表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包 如果都失败了，就丢掉这个包。 如何查看路由表 参考资料 维基百科-TCP 百科-TCP CDSN-TCP IP协议-CSDN IP协议-百度经验 1.可以合并多个请求数据(放在缓冲区中)，一次/多次读取完 ↩2.发送几次请求，就需要接收几次；一次只能读取一个完整的报文 ↩","tags":[],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"计算机网络","slug":"技术之路/计算机网络","permalink":"http://yoursite.com/categories/技术之路/计算机网络/"}]},{"title":"网络参考模型","date":"2017-11-10T18:52:00.000Z","path":"技术之路/计算机网络/网络参考模型/","text":"OSI 参考模型 国际标准化组织(ISO) 和 国际电报电话咨询委员会(CCITT) 联合制定了 OSI（Open System Interconnect） WHYOSI参考模型是计算机网路体系结构发展的产物；其目的是为异种计算机互连提供 一个共同的基础和标准框架 ，并为保持相关标准的一致性和兼容性提供共同的参考。 WHAT实现「开放系统互连」所建立的「通信功能」的「分层模型」；分七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 HOW 每一层的功能是独立的，利用下一层为上一层提供服务； 同等层实体之间通信由该层的协议管理。 除物理层之外，每层都会在原始数据前添加一串属于自己的协议头；接收端向上传递过程中会删除自己的协议头 服务：下一层向上一层提供的「通信功能」和「层之间的会话规定」。协议：两个开放系统中的 同等层之间的通信规则和约定 1～4层协议称为下层协议 5～7层协议称为上层协议 分层说明应用层 (Application)网络服务与最终用户的一个接口。协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP 表示层（Presentation Layer）数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）格式有，JPEG、ASCll、DECOIC、加密格式等 会话层（Session Layer）建立、管理、终止会话。（在五层模型里面已经合并到了应用层）对应主机进程，指本地主机与远程主机正在进行的会话 传输层 (Transport)定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层 网络层 (Network)进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP 数据链路层 (Link)建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。 物理层（Physical Layer）建立、维护、断开物理连接。（由底层网络定义协议） TCP/IP 参考模型 TCP/IP是先有了协议，才制定TCP/IP模型。目前是互联网的事实标准 WHYARPANET是由美国国防部DoD（U.S.Department of Defense）赞助的研究网络。逐渐地它通过租用的电话线连结了数百所大学和政府部门。当无线网络和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。 WHAT由 TCP、IP 两个协议演进过来的，共分为四层：网络访问层、互联网层、传输层和应用层 HOW 分层说明应用层为用户提供所需要的各种服务协议有：HTTP、FTP、Telnet、DNS、SMTP等. 传输层为应用层提供端到端的通信功能协议有：TCP、UDP 网络互联层负责分配地址和传送二进制数据。协议有：IP、IGMP、ICMPIP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。 网络接口层负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，所以其具体实现的方法随着网络类型的不同而不同。 OSI 比对 TCP/IP 参考资料 科来协议图 百科-七层模型 百科-TCP/IP参考模型","tags":[],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"计算机网络","slug":"技术之路/计算机网络","permalink":"http://yoursite.com/categories/技术之路/计算机网络/"}]},{"title":"欢迎来到贺龙飞的知识库！","date":"2017-11-08T13:20:17.000Z","path":"index/","text":"何为「知识库」？在这个信息爆炸的年代，获取信息的成本接近于0，每天都有很多新的信息蜂拥而来；过往针对这些信息，我都是放在云笔记中（尝试过有道、印象、为知、蚂蚁等），但是放在笔记中不等于掌握，所以需要进一步的进行归纳和整理，所以才有了「知识库」。 为什么要用 github page 作为「知识库」?之前都是放在云笔记中，但是不利于查找和分享，同时有些需求云笔记不太能满足我；这边整理了下自己对「知识库」的需求： 无限级分类 可以全文搜索 内容有目录 可以方便查询 便于进行知识梳理 保证数据不会丢失 内容有更新历史 所以最终选择了使用 github page。 「知识库」和「博客」有什么区别？个人学习的过程是：收集-&gt;整理-&gt;吸收-&gt;输出 收集：采用「evernote」进行信息的收集整理：采用「知识库」进行信息/知识的整理吸收：在工作/学习中「实战」输出：采用「博客」对知识进行深入的剖析/个人见解 综上所述，「知识库」是对知识的整理，「博客」是对知识的剖析","tags":[],"categories":[]},{"title":"YAR","date":"2017-11-07T14:35:00.000Z","path":"技术之路/程序语言/PHP/yar/","text":"What一个轻量级可并行的 RPC 框架，支持三种打包协议（msgpack,json,php）,传输协议支持 http（tcp/unix以后会支持）​ github 地址：https://github.com/laruence/yarphp 官网：http://php.net/manual/zh/book.yar.php Why鸟哥举了两个场景(传统 web 应用)： 一个进程，一个请求，但是涉及到多个没有依赖性的数据源，只能串行处理（依次等待所有数据源处理）完毕后才能响应； yar 可以并行处理，减少时间开销 一个应用系统随着业务的增加，人员流失，只做加法，等到不可维护性的时候，只能重构 yar 可以给系统进行解耦（实际上是 soa 思想） Howserver放置在 web 服务器上，通过 http 访问(默认get访问会输出 doc 信息) client 串行调用 并行调用（yar 内部使用 libcurl + epoll ） 高级进阶Yar 协议分析Yar整个协议由82字节长度的yar_header + 8字节的数据打包协议(MSGPACK、JSON、PHP) + N字节的Body组成。 安全性 未验证 123456789typedef struct _yar_header &#123; unsigned int id; // transaction id unsigned short version; // protocl version unsigned int magic_num; // default is: 0x80DFEC60 unsigned int reserved; unsigned char provider[32]; // reqeust from who unsigned char token[32]; // request token, used for authentication unsigned int body_len; // request body len&#125; struct _yar_header中需要注意的是magic_num值。该值在Client与Server都应该保持一致。否则视为不合法的数据。我们可以通过修改这个值，定制一个yar框架，防止其他人恶意请求。 跨语言 利用 yar 可以接收 struct 实现 client 12345array( &quot;i&quot; =&gt; &apos;&apos;, // transaction id &quot;m&quot; =&gt; &apos;&apos;, // the method which being called &quot;p&quot; =&gt; array(), // parameters) server 1234567array( &quot;i&quot; =&gt; &apos;&apos;, &quot;s&quot; =&gt; &apos;&apos;, //status &quot;r&quot; =&gt; &apos;&apos;, //return value &quot;o&quot; =&gt; &apos;&apos;, //output &quot;e&quot; =&gt; &apos;&apos;, //error or exception) 参考资料 Yar – 并行的RPC框架(Concurrent RPC framework) YAR 并行RPC框架研究 Yar协议分析与跨语言实现","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"yar","slug":"yar","permalink":"http://yoursite.com/tags/yar/"},{"name":"php_ext","slug":"php-ext","permalink":"http://yoursite.com/tags/php-ext/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"程序语言","slug":"技术之路/程序语言","permalink":"http://yoursite.com/categories/技术之路/程序语言/"},{"name":"PHP","slug":"技术之路/程序语言/PHP","permalink":"http://yoursite.com/categories/技术之路/程序语言/PHP/"}]},{"title":"MAC 必备软件","date":"2017-11-06T15:25:00.000Z","path":"效率工具/mac/","text":"系统 Vanilla：隐藏菜单栏 Spectacle：窗口分屏 Coffitivity：白噪音 Enpass：密码管理工具 TeamViewer：远程控制 Tickeys：打字音效 Lantern：出国工具 Irvue：自动切换壁纸 OmniDiskSweeper: 查看磁盘占用工具 学习 Anki：复习工具 Evernote：收集资料 Leanote：笔记 MarginNote Pro：学习 pdf 神器（收费） MindNode：思维导图（收费） kiwix：离线维基百科 工作 Atom：编辑器 Charles：抓包工具（收费） Dash：文档（收费） iTerm 2：终端 PhpStorm：PHP 的 IDE Sequel Pro：Mysql 客户端 SourceTree：Git 客户端 Sublime Text：轻量可定制编辑器 Typora：MD 编辑器","tags":[],"categories":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/categories/效率工具/"}]},{"title":"Blog 系统之 Hexo","date":"2017-11-05T06:26:00.000Z","path":"开源软件简析/blog/","text":"Blog 系统之前用的是 Octopress ，由于不更新了，且使用的是 ruby 开发，生成 html 比较慢，所以迁移到 hexo。 Hexo安装 hexohexo 文档 1234$ npm install -g hexo-cli$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 安装完毕后，请自行修改 /_config.yml 最后别忘记添加 CNAME 主题采用 Hiker 主题；[中文说明] [Github] 删除作者自己的 cnzz 统计代码 12345678910# source/js/scripts.js 中，删除以下代码var s = [ '&lt;div style=\"display: none;\"&gt;', '&lt;script src=\"https://s11.cnzz.com/z_stat.php?id=1260716016&amp;web_id=1260716016\" language=\"JavaScript\"&gt;&lt;/script&gt;', '&lt;/div&gt;' ].join(''); var di = $(s); $('#container').append(di); 修改主题的配置文件 12345# /themes/hiker/_config.yml# 清空以下信息，都是作者本人信息social:donate:# 其他数据请自行填充 Atom 配置 采用 atom 作为 md 的编辑器 详细配置见：atom-hexo配置 Hexo 命令 详细命令清单见：hexo 命令 新增文章1$ hexo new [layout] &lt;title&gt; 预览1$ hexo g 实时更新预览1$ hexo g -w 发布1$ hexo d -g 自定义命令配置 bash/zsh 的配置文件 .basrc/.zshrc 增加如下命令 123export BLOG_PATH=\"blog的目录\"alias blog_root=\"cd $BLOG_PATH/\"PATH=\"...:$BLOG_PATH/shell\" 进入 Hexo 根目录1blog_root 预览1blog_preview 生成 html1blog_generate 发布1blog_deploy 打开 atom1blog_atom","tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"Atom 编辑器","date":"2017-11-04T21:51:00.000Z","path":"开源软件简析/atom/","text":"安装插件 markdown-preview-enhanced ：增强版 md 预览 markdown-writer ：写博客必备利器 tool-bar ：工具栏基类 tool-bar-markdown-writer ： md-writer的工具栏 vim-mode-plus ：vim 插件 markdown-table-editor ：表格编辑工具 atom-terminal ：终端 tool-bar-markdown-writer 修改文件 ~/.atom/packages/tool-bar-markdown-writer/lib/tool-bar-markdown-writer.coffee 增加如下功能： 增加 publish-draft Preview markdown 增加支持 markdown-preview-enhanced 新增的配置如下：12345678910111213&#123; 'icon': 'content-duplicate' 'tooltip': 'Publish Draft' 'callback': 'markdown-writer:publish-draft'&#125;&#123; 'icon': 'markdown' 'tooltip': 'Preview Markdown' 'data': ['markdown-preview-enhanced', 'markdown-preview-plus','markdown-preview'] 'visible': (data) -&gt; pkg = data.find (pkg) -&gt; !!atom.packages.getLoadedPackage(pkg) \"#&#123;pkg&#125;:toggle\" if pkg&#125; Atom 配置文件123456789101112131415161718192021\"*\": core: packagesWithKeymapsDisabled: [ \"markdown-preview\" ] telemetryConsent: \"no\" \"exception-reporting\": userId: \"5a8289c3-5832-4d26-af7b-3235427b72da\" \"markdown-preview-enhanced\": enableExtendedTableSyntax: true imageDropAction: \"copy to image folder\" mathRenderingOption: \"MathJax\" \"markdown-writer\": fileExtension: \".md\" renameImageOnCopy: true \"tool-bar\": &#123;&#125; \"tool-bar-markdown-writer\": &#123;&#125; \"vim-mode-plus\": notifiedCoffeeScriptNoLongerSupportedToExtendVMP: true welcome: showOnStartup: false Simiki 配置 主要使用的是 md-writer 生成项目专用的配置文件： 1点击 packages -&gt; markdown-writer -&gt; configurations -&gt; create project configs 最终在项目的根目录下生成 _mdwriter.cson 修改如下配置： 1234567891011121314151617181920212223242526272829303132# Directory to drafts from siteLocalDirsiteDraftsDir: \"content/\"# Directory to posts from siteLocalDirsitePostsDir: \"content/\"# Directory to images from siteLocalDir# - E.g. to use the current filename directory, can use &#123;directory&#125;siteImagesDir: \"attach/img/&#123;year&#125;/&#123;month&#125;/\"# Filename format of new drafts creatednewDraftFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Filename format of new posts creatednewPostFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Front matter date format, determines the &#123;date&#125; in frontMatterfrontMatterDate: \"&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;\"# Front matter templatefrontMatter: \"\"\"---title: \"&#123;title&#125;\"date: \"&#123;date&#125;\"layout: \"page\"---[TOC]\"\"\"# File extension of posts/draftsfileExtension: \".md\"# File slug separatorslugSeparator: \"-\"tableExtraPipes: true Hexo 配置 主要使用的是 md-writer 生成项目专用的配置文件： 1点击 packages -&gt; markdown-writer -&gt; configurations -&gt; create project configs 最终在项目的根目录下生成 _mdwriter.cson 修改如下配置： 12345678910111213141516171819202122232425262728293031323334353637siteEngine: \"hexo\"# Website URL of your blogsiteUrl: \"http://www.helongfei.com\"# Directory to drafts from siteLocalDirsiteDraftsDir: \"source/_drafts/\"# Directory to posts from siteLocalDirsitePostsDir: \"source/_posts/&#123;year&#125;/\"# Directory to images from siteLocalDir# - E.g. to use the current filename directory, can use &#123;directory&#125;siteImagesDir: \"source/images/&#123;year&#125;/&#123;month&#125;/\"# Filename format of new drafts creatednewDraftFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Filename format of new posts creatednewPostFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Front matter date format, determines the &#123;date&#125; in frontMatterfrontMatterDate: \"&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;\"# Front matter templatefrontMatter: \"\"\"---layout: \"&#123;layout&#125;\"title: \"&#123;title&#125;\"date: \"&#123;date&#125;\"---\"\"\"# File extension of posts/draftsfileExtension: \".md\"# File slug separatorslugSeparator: \"-\"# Table row continuation# - Enable to auto insert table columns when you press enter in a table rowtableNewLineContinuation: true","tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"Wiki 系统之 Simiki","date":"2017-11-03T16:00:00.000Z","path":"开源软件简析/wiki/","text":"Wiki 系统需求：git+md 系统 实现方式 缺点 优点 dokuwiki php+文本 编辑器不好用；数据量大搜索可能有性能问题（txt） 插件丰富，txt移植方便 mediawiki php+mysql 配置复杂；visualeditor 加载慢 功能全面，visualeditor simiki git+md 全量生成html；图片支持不好 可定制 gitbook git+md 全量生成 html ( 渲染巨慢 ) 有编辑器 Simiki 安装simiki 文档 123pip install simikimkdir mywiki &amp;&amp; cd mywikisimiki init 配置 _config.yml 123456789101112url:title:keywords:description:author:theme: yasimple_x2markdown: - fenced_code - extra - codehilite(css_class=hlcode, linenums=False) - toc(title=Table of Contents) 增加 CNAME 文件 为了域名解析；文本内容为待解析域名 Atom 配置 使用 Atom 作为 md 编辑器 详细配置见 Atom-simike 配置 发布fab需要_config.yml增加如下配置项： 1234deploy: - type: git remote: origin branch: gh-pages 发布的时候如下命令： 1fab deploy #不支持python3 shell使用自定义命令： 1wiki_deploy simiki 命令生成 html1simiki g 预览 wiki1simiki p 实时生成 html1simiki p -w","tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"Codeception 之验收测试","date":"2016-05-02T07:38:09.000Z","path":"技术之路/测试/codeception/","text":"Acceptance Testing验收测试针对整个站点进行测试，模拟真实用户的访问流程。 写测试的人员不需要知道网站的内部实现。 两种测试类型PhpBrowser配置tests/acceptance.suite.yml 123456class_name: AcceptanceTestermodules: enabled: - PhpBrowser: url: - \\Helper\\Acceptance Selenium WebDriver配置tests/acceptance.suite.yml 1234567class_name: AcceptanceTestermodules: enabled: - WebDriver: url: browser: chrome - \\Helper\\Acceptance 配置Selenium环境 下载Selenium Standalone Server 下载Google Chrome Driver 启动： 1234//启动selenium-serverjava -jar selenium-server-standalone-2.53.0.jar//启动Chrome Driver./chromedriver 编写测试 测试写在tests/acceptance,后缀为Cept，例如：SiginCept.php PhpBrowser测试文档参考：PHP Browser actions Assertions Grabbers Comments Cookies, Urls, Title Selenium WebDriver测试文档参考：Selenium WebDriver Session Snapshots 其他DB配置 SQL语句放在 /tests/_data 下 DB-config修改codeception.yml Debug 命令行增加 --debug 手动输出 codecept_debug() 手动下一步 pauseExecution 记录测试 Recorder extension 参考资料 Acceptance Testing介绍 PHP Browser介绍 PHP Browser文档 Selenium WebDriver文档","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"Codeception","slug":"Codeception","permalink":"http://yoursite.com/tags/Codeception/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"测试","slug":"技术之路/测试","permalink":"http://yoursite.com/categories/技术之路/测试/"}]},{"title":"RBAC","date":"2016-04-10T06:36:00.000Z","path":"技术之路/权限控制/rbac/","text":"前言在权限设计中，若权限比较复杂，使用简单的权限判断，则会使代码比较冗长，逻辑比较复杂，不利用维护和扩展。这时可以考虑使用 RBAC。 RBAC 介绍RBAC（Role-Based Access Control ）基于角色的访问控制。抽象出来就是用户，角色和权利三个方面。在权利和用户之间，增加一个角色，使其不再耦合在一起，方便维护和扩展。 一个角色拥有多个权利，一个用户想拥有某些权利时，只需要附给用户相应的角色即可。若一些用户需要相同的角色，则建立起用户组即可。 RBAC 分类RBAC0 RBAC核心,其他分类都是建立在此基础上 主要有四部分组成： 用户 角色 权限 会话 用户和角色是多对多关系，角色和权限是多对多关系。 一个会话只能由一个用户创建，会话和角色是多对多关系。一般会有8张表来设计(若不需要用户组，则是5张表)： RBAC1 基于 RBAC0 的角色分级；角色有了继承和包含的层级 这种模型使用 RBAC0 也是可以实现的，但是会造成数据冗余 RBAC2 基于 RBAC0 的角色限制（互斥，数量限制等） RBAC3 组合 RBAC1 和 RBAC2 RBAC 总结通常使用 RBAC0 就可以解决大部分权限问题，其他的细节在具体的设计中具体分析。RBAC 只是一种设计思想，我们在设计的过程中要具体问题具体分析，灵活的使用，不要照本宣科。 参考资料 权限管理——RBAC模型总结 RBAC RBAC权限管理 基于角色的访问控制","tags":[{"name":"rbac","slug":"rbac","permalink":"http://yoursite.com/tags/rbac/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"权限控制","slug":"技术之路/权限控制","permalink":"http://yoursite.com/categories/技术之路/权限控制/"}]},{"title":"PSR","date":"2016-04-02T16:45:00.000Z","path":"技术之路/程序语言/PHP/php-psr/","text":"PSR PSR 来自 PHP FIG(框架协同工作组) 现有规范 PSR-0/PSR-4 自动加载（2014.10.21起弃用，请使用 PSR-4） PSR-1 基本规范 PSR-2 代码风格 PSR-3 日志接口 PSR-0/PSR-4 自动加载class 指 class,interface,trait和其他相似的结构 PSR-0(弃用)按照目录拼接类名 1234/path/to/src/ VendorFoo/ Bar/ Baz.php # VendorFoo_Bar_Baz PSR-4 类名中下划线转为目录 每个命名空间必须有顶级命名空间（vender） 1234Vendor_Name |- Name_space |- Class |-Name.php # \\Vendor_Name\\Name_space\\Class_Name 自动加载方法 函数 12345678910111213141516&lt;?phpfunction autoload($className)&#123; $className = ltrim($className, &apos;\\\\&apos;); $fileName = &apos;&apos;; $namespace = &apos;&apos;; if ($lastNsPos = strrpos($className, &apos;\\\\&apos;)) &#123; $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $fileName = str_replace(&apos;\\\\&apos;, DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; &#125; $fileName .= str_replace(&apos;_&apos;, DIRECTORY_SEPARATOR, $className) . &apos;.php&apos;; require $fileName;&#125; 类: SplClassLoader PSR-1 基本代码规范 「文件」源文件必须只使用 &lt;?php 和 &lt;?= 这两种标签。 「文件」源文件中php代码的编码格式必须只使用不带字节顺序标记(BOM)的UTF-8。 「类」类名(class name) 必须使用骆驼式(StudlyCaps)写法。 「类」类(class)中的常量必须只由大写字母和下划线(_)组成。 「类」方法名(method name) 必须使用驼峰式(cameCase)。 「文件」一个源文件建议只用来做声明（类(class)，函数(function)，常量(constant)等）或者只用来做一些引起副作用的操作（例如：输出信息，修改.ini配置等）,但不建议同时做这两件事。 PSR-2 代码风格指南针对 PSR-1 的继承和扩展 「缩进」代码必须使用4个空格来进行缩进，而不是用制表符。 「行」一行代码的长度不建议有硬限制；软限制必须为120个字符，建议每行代码80个字符或者更少；非空行不可有空格；一行不可多于一个语句. 「文件」纯 php 文件 `必须` 省略;`必须`以空行结束123456789- 「命名空间」在`命名空间(namespace)`的声明下面`必须`有一行空行，并且在`导入(use)`的声明下面也`必须`有一行空行。- 「类」`类(class)`的左花括号`必须`放到其声明下面自成一行，右花括号则`必须`放到类主体下面自成一行。- 「方法」`方法(method)`的左花括号`必须`放到其声明下面自成一行，右花括号则`必须`放到方法主体的下一行。- 「属性|方法」所有的`属性(property)`和`方法(method)` `必须`有可见性声明；`抽象(abstract)`和`终结(final)`声明`必须`在可见性声明之前；而`静态(static)`声明`必须`在可见性声明之后。- 「关键字和常量」关键字和常量(true，false，null)`必须`小写- 「控制结构」在控制结构关键字的后面`必须`有一个空格；而`方法(method)`和`函数(function)`的关键字的后面`不可`有空格。- 「控制结构」控制结构的左花括号`必须`跟其放在同一行，右花括号`必须`放在该控制结构代码主体的下一行。- 「控制结构」控制结构的左括号之后`不可`有空格，右括号之前也`不可`有空格。- 「类」`不建议`使用`_`来表明方法和属性的保护性 &lt;?phpnamespace Vendor\\Package; use FooInterface;use BarClass as Bar;use OtherVendor\\OtherPackage\\BazClass; class Foo extends Bar implements FooInterface, Bar{ public function sampleFunction($a, $b = null) { if ($a === $b) { bar(); } elseif ($a &gt; $b) { $foo-&gt;bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { $foo-&gt;bar( $longArgument, $longerArgument, $muchLongerArgument ); $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument = null ) use ($var1) { // body }; } public function aVeryLongMethodName( ClassTypeHint $arg1, &amp;$arg2, array $arg3 = [] ) { switch ($expr) { case 0: echo &apos;First case, with a break&apos;; break; case 1: echo &apos;Second case, which falls through&apos;; // no break case 2: case 3: case 4: echo &apos;Third case, return instead of break&apos;; return; default: echo &apos;Default case&apos;; break; } while ($expr) { // structure body } do { // structure body; } while ($expr); for ($i = 0; $i &lt; 10; $i++) { // for body } foreach ($iterable as $key =&gt; $value) { // foreach body } try { // try body } catch (FirstExceptionType $e) { // catch body } catch (OtherExceptionType $e) { // catch body } } }``` PSR-3 日志接口主要目标是让类库获得一个Psr\\Log\\LoggerInterface对象并能通过简单通用的方式来写日志 8个等级（debug, info, notice, warning, error, critical, alert, emergency） log 方法(等级，日志)； 等级必须一致，否则必须抛出Psr\\Log\\InvalidArgumentException 日志必须是字符串，或者是可__toString的对象 …. 代码检查工具PHP Mess DetectorPHP项目体检工具，根据你设定的标准（如单一文件代码体积，未使用的参数个数，未使用的方法数）检查PHP代码，超出设定的标准时报警。 PHP Copy Paste Detector顾名思义，检查冗余代码的 PHP Dead Code Detector看名字就知道了，检查从未被调用过的方法 PHP Code SnifferPHPLint持续集成jenkins把上述工具以plugins形式整合起来 xinc+phing跟上述工具集成起来做持续集成后的自动化打包发布 参考资料 PHP PSR代码标准中文版 PHP中有什么好的代码自动检查工具吗","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"PSR","slug":"PSR","permalink":"http://yoursite.com/tags/PSR/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"程序语言","slug":"技术之路/程序语言","permalink":"http://yoursite.com/categories/技术之路/程序语言/"},{"name":"PHP","slug":"技术之路/程序语言/PHP","permalink":"http://yoursite.com/categories/技术之路/程序语言/PHP/"}]},{"title":"UML","date":"2016-02-28T15:22:00.000Z","path":"技术之路/面向对象/uml/","text":"UML 类图中的关系关联关系用于表示一类对象与另一类对象之间有联系程序中，通常将一个类的对象作为另一个类的成员变量 双向关联 单向关联 自关联 在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联 多重性关联 表示两个关联对象在数量上的对应关系 表示方式 多重性说明 1..1 表示另一个类的一个对象只与该类的一个对象有关系 0..* 表示另一个类的一个对象与该类的零个或多个对象有关系 1..* 表示另一个类的一个对象与该类的一个或多个对象有关系 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系 m..n 表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n) 聚合关系 整体（整体对象）和部分（成员对象）可以分开独立存在 这里表示的是：汽车和发动机还有个更形象的比喻：雁群和雁子 程序中，成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中 组合关系 整体和部分不可分开，有相同的生命周期 这里表示的是：头和嘴还有个更形象的比喻：雁子和翅膀 程序中，通常在整体类的构造方法中直接实例化成员类 依赖关系 表示一个事物「使用」另一个事物时使用依赖关系 程序中，依赖关系体现在某个类的方法使用另一个类的对象作为参数 将一个类的对象作为另一个类中方法的参数 在一个类的方法中将另一个类的对象作为其局部变量 在一个类的方法中调用另一个类的静态方法 泛化关系 泛化关系就是继承关系 接口与实现关系 总结各种关系的强弱顺序： 泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖 参考资料 深入浅出UML类图（二） 深入浅出UML类图（三） UML类图几种关系的总结","tags":[{"name":"uml","slug":"uml","permalink":"http://yoursite.com/tags/uml/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"面向对象","slug":"技术之路/面向对象","permalink":"http://yoursite.com/categories/技术之路/面向对象/"}]},{"title":"设计原则","date":"2016-02-21T06:04:00.000Z","path":"技术之路/面向对象/oo-principle/","text":"前言在面对一个复杂项目的时候，为了提高项目的 扩展性、 复用性、 可维护性，我们往往会进行抽象设计；而这些原则是从许多成功设计方案中总结出的指导性原则，为我们学习设计模式和设计系统提供了很好的帮助。 设计原则 设计原则名称 定义 使用频率 开闭原则(Open-Closed Principle, OCP) 一个软件实体对扩展开放，而对修改关闭 ★★★★★ 里氏代换原则(Liskov Substitution Principle, LSP) 所有引用基类对象的地方能够透明地使用其子类的对象 ★★★★★ 依赖倒转原则(Dependence Inversion Principle, DIP) 抽象不应该依赖于细节，细节应该依赖于抽象 ★★★★★ 单一职责原则(Single Responsibility Principle, SRP) 一个类只负责一个功能领域中的相应职责 ★★★★☆ 合成复用原则(Composite Reuse Principle, CRP) 尽量使用对象组合，而不是继承来达到复用的目的 ★★★★☆ 迪米特法则(Law of Demeter, LoD) 一个软件实体应当尽可能少地与其他实体发生相互作用 ★★★☆☆ 接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口 ★★☆☆☆ 开闭原则「软件实体」可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 作用 在项目的迭代过程中，出现新的需求或者需求改动时，在不修改现有代码的情况下，就可扩展新的行为。(总目标) 如何做？ 思考增加需求时，如何实现？ 抽象化是开闭原则的关键把 可能会发生变化的地方 （ 要对需求的变更有预见性 ）放到抽象类中，具体的实现在子类中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可。 避免过度使用遵循开闭原则，通常会引入新的抽象层次， 增加代码的复杂度。需要把注意力集中在设计中 最有可能改变的地方 ，然后应用开闭原则。每个地方都采用开闭原则，是一种浪费，也没必要，还会导致代码变得复杂且难以理解。 具体实例 多图表-柱状、饼状[2] 里氏替换原则作用 里氏代换原则是实现开闭原则的重要方式之一；保证整个继承体系不被破坏。 如何做？ 子类不能重新定义父类的方法/属性 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法 尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。（运行时，子类实例替换父类实例） 具体实例 给不同等级的客户发送邮件[3] 依赖倒转原则作用 依赖倒转原则就是面向对象设计的主要实现机制之一；它是系统抽象化的具体实现。依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 如何做？ 要针对接口编程，而不是针对实现编程 传递参数时或在关联关系中，尽量引用层次高的抽象层类；使用 接口和抽象类 进行变量类型声明、参数类型声明等使用继承时，遵循里氏替换原则 针对抽象层编程，而将具体类的对象通过 [依赖注入] 的方式注入到其他对象中;[依赖注入]是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象；主要有以下三种方式：构造注入、设值注入（Setter注入）、接口注入 具体实例 存储不同格式的文件到数据库[4] 单一职责原则作用 单一职责原则是实现 高内聚、低耦合 的指导方针；提高类的复用性。当一个模块或一个类被设计成只支持一组相关功能时，我们说它具有「高内聚」。 如何做？ 发现类的不同职责并将其分离；一个类应该只有一个引起变化的原因 将不同的职责(变化原因)封装在不同的类中 如果多个职责总是同时发生改变则可将它们封装在同一类中 随着系统的成长，随时查看某个类是否超过一个变化原因, 具体实例 客户关系管理[8] 合成复用原则作用 程序设计中，确定复用是用继承还是组合 如何做？ 要判断使用组合/聚合关系（关联关系）还是继承 组合/聚合 优先考虑；两个类之间是“Has-A”的关系应使用组合或聚合；Has-A 表示某一个角色具有某一项责任 优点： “黑盒”复用，因为被包含对象的内部细节对外是不可见（封装性好） 通过获取具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合。 缺点： 对象过多，不易理解 继承 两个类之间是“Is-A”关系可使用继承；Is-A 表示一个类是另一个类的”一种” 优点： 有效使用继承会有助于对问题的理解，降低复杂度（严格遵循里氏代换原则） 缺点： 滥用继承反而会增加系统构建和维护的难度以及系统的复杂度 “白盒”复用，因为父类的内部细节对于子类而言通常是可见的。（封装性差） 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性 继承只能在有限的环境中使用（如类没有声明为不能被继承） 具体实例 数据保存在不同的数据库中[6] 迪米特法则作用降低系统的耦合度，使类与类之间保持松散的耦合关系。 如何做？ 思考软件实体之间的交互；确定只和“朋友”打交道 不要和“陌生人”说话、只与你的直接朋友通信；对于一个对象，其朋友包括以下几类： 当前 对象本身 (this)； 参数对象：以参数形式传入到当前对象方法中的对象； 当前对象的 成员对象；如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所 创建的对象 应该尽量减少对象之间的交互 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用 如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用 在类之间的设计上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及 在单个类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限，一个类型应当尽量设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低 具体实例 一个多操作的窗口[7] 接口隔离原则作用 系统解开耦合，从而容易重构，更改和重新部署 如何做？ 接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来 接口职责要单一将大接口中的方法根据 职责不同 分别放在不同的小接口中，以确保每个接口都承担某一单一角色。 为不同的客户端提供宽窄不同的接口接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可。 注意：在使用接口隔离原则时，我们需要注意控制接口的粒度。接口太小会导致系统中接口泛滥，不利于维护；接口太大将违背接口隔离原则，灵活性较差，使用起来很不方便。 一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法 具体实例 将文件内容转为不同的数据格式存储[5] 总结 不要过度使用设计模式，一切从简。 设计原则 说明 开闭原则 对扩展开放，对修改关闭 里氏替换原则 不要破坏继承体系 依赖倒置原则 面向接口编程 单一职责原则 类要职责单一 接口隔离原则 接口要精简单一 迪米特法则 软件实体间要降低耦合 合成复用原则 复用时要合理使用继承和组合 设计原则之间的关系，个人总结如下： 参考资料 面向对象设计原则概述 面向对象设计原则之开闭原则 面向对象设计原则之里氏代换原则 面向对象设计原则之依赖倒转原则 面向对象设计原则之接口隔离原则 面向对象设计原则之合成复用原则 面向对象设计原则之迪米特法则 面向对象设计原则之单一职责原则","tags":[{"name":"OO","slug":"OO","permalink":"http://yoursite.com/tags/OO/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"面向对象","slug":"技术之路/面向对象","permalink":"http://yoursite.com/categories/技术之路/面向对象/"}]},{"title":"Pandoc","date":"2016-01-04T00:00:00.000Z","path":"开源软件简析/pandoc/","text":"Pandoc 简介pandoc 是一个 markdown 文档转换工具，可以把 markdown 转换为诸多的格式，可以定制格式，编写过滤器等。pandoc 支持的格式，可以参考官网：http://www.pandoc.org pandoc 的语法，请看：官网英文 / 中文翻译 pandoc 过滤器编写，请看：https://github.com/jgm/pandoc/wiki/Pandoc-Filters 如何自定义样式Html 样式Html 可以指定 css 文件进行样式修改 方式一：引入 css 文件 1234table&#123;border-collapse:collapse;border:1px solid #CCC;background:#efefef;&#125;table caption&#123;text-align:left; background-color:#fff; line-height:2em; font-size:14px; font-weight:bold; &#125;table th&#123;text-align:left; font-weight:bold;height:26px; line-height:26px; font-size:12px; border:1px solid #CCC;&#125;table td&#123;height:20px; font-size:12px; border:1px solid #CCC;background-color:#fff;&#125; 1$ pandoc -s -c [cssfile] [mdfile] -o [htmlname] 方式二：页面内置样式（写入 header） 123456&lt;style type=\"text/css\"&gt;table&#123;border-collapse:collapse;border:1px solid #CCC;background:#efefef;&#125;table caption&#123;text-align:left; background-color:#fff; line-height:2em; font-size:14px; font-weight:bold; &#125;table th&#123;text-align:left; font-weight:bold;height:26px; line-height:26px; font-size:12px; border:1px solid #CCC;&#125;table td&#123;height:20px; font-size:12px; border:1px solid #CCC;background-color:#fff;&#125;&lt;/style&gt; 1$ pandoc -s -H [cssfile] [mdfile] -o [htmlname] Docx 样式pandoc 可以使用 docx 模板进行渲染（注意：模板是修改样式，而不是内容） 可以把自己修改后的样式保存为「word 模板」 1$ pandoc --reference-docx=[模板路径] [mdfile] -o [docxname] Docx 模板分享自己的 docx 模板（不断更新中） 技术文档docx模板 TeX 模板见 Phodal Huang 毕业设计模板 (百度盘备份) 使用方法：需要保存为*.docx 文件，然后使用 --template 选项指定模板 生成 Html 幻灯片利用 markdown 直接生成 web-based slideshow；可以自定义 css ，足够灵活。 支持那些幻灯片框架？pandoc 包含5种 html 幻灯片框架： DZSlides Slidy S5 Slideous reveal.js 实际上可以使用任何幻灯片框架（比如Google I/O HTML5 slide template），只要让Pandoc在渲染HTML时使用你指定的模板即可. 生成默认模板的幻灯片pandoc 内置 dzslides 框架 1$ pandoc [*.md] -o [*.html] -t dzslides -s 可选配置渐进显示 生成幻灯片时加入 -i 选项，用于控制列表的显示效果（逐条渐入） 两段文字显示之间的人为停顿: ... 强制分割默认是2级标题分割。可以使用-----------------强制分割;也可以使用 --slide-level 选项覆盖默认的 Slide level 代码高亮风格控制代码高亮风格的选项有： –highlight-style pygments –highlight-style kate –highlight-style monochrome –highlight-style espresso –highlight-style haddock –highlight-style tango –highlight-style zenburn 自定义样式这里着重分析下 reveal.js ；为什么？因为只有它有提示板。 安装reveal.js1$ git clone https://github.com/hakimel/reveal.js 生成幻灯片 Html1$ pandoc [*.md] -o [*.html] -t revealjs -s [-V theme=beige] 支持的样式： default：（默认）深灰色背景，白色文字 beige：米色背景，深色文字 sky：天蓝色背景，白色细文字 night：黑色背景，白色粗文字 serif：浅色背景，灰色衬线文字 simple：白色背景，黑色文字 solarized：奶油色背景，深青色文字 提示板按 s 触发； 增加小抄： 123456&lt;aside class=\"notes\"&gt; * 这里是提示1 * 这里是提示2&lt;/aside&gt; 参考资料 Markdown+Pandoc→HTML幻灯片速成","tags":[{"name":"pandoc","slug":"pandoc","permalink":"http://yoursite.com/tags/pandoc/"},{"name":"ppt","slug":"ppt","permalink":"http://yoursite.com/tags/ppt/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"GitFlow","date":"2016-01-02T09:06:00.000Z","path":"技术之路/GIT/git-flow/","text":"目前收集到的工作流有以下几种，其中最常用的是 Gitflow 和 Forking + Pull request Git工作流集中式 svn 形式的代码管理 所有的代码都在 master 分支上开发（线性开发） 功能分支 以集中式工作流为基础，不同的是新功能在新分支上开发 开发完毕发起 pull request 讨论通过后合并到 master Gitflow 来源2010 年初，荷兰的程序员 Vincent Driessen 在他自己的博客 http://nvie.com/ 发表了一篇文章 《A successful Git branching model》 简述 在功能分支的基础上，增加了维护和开发的便利性 两个长期分支：master 和 develop；三个短期分支：feature，release，hotfix 5个分支说明 master 分支只做发布 develop 分支做开发功能集成 feature 分支来自 develop 分支，用于新特性开发，被合并到 develop 分支 release 分支来自 develop 分支，用于预发布与测试，被合并到 master 分支和 develop 分支 hotfix 分支来自 master 分支，用于修改线上bug，被合并回 master 分支 和 develop 分支/release 分支 插件123456git flow feature start // 开始一个特性的开发git flow feature finish // 完成一个特性的开发git flow release start // 开始一次 releasegit flow release finish // 完成一次 releasegit flow hotfix start // 开始一个线上bug修复git flow hotfix finish // 完成一个线上bug修复 详情见 git flow Forking + Pull request 利用分支合并，方便接受其他贡献者的提交，而无须开放项目权限 贡献者 push 自己的代码到自己的服务端仓库，发起 pull request 项目的维护者review 后合并 github，osc 等都使用此种工作流 本地添加远程项目1git remote add [upstream-name] [upstream-url] pull request的注意事项 base fork 与 head fork 的区别 base fork : 请求 pull requeat 的分支，通常是被 fork 的分支（维护者）； head fork ：希望被合并的分支，通常是自己fork 的分支（贡献者） fork 的项目和原有项目保持同步 方式1：分步处理 需要预览和对比，则使用： 123$ git remote update [upstream-name]$ git checkout [branch-name]$ git rebase [upstream/branch-name] ​方式2：一步处理 不需要预览则使用： 1$ git pull --rebase [upstream-name] [branch-name] 方式3：脚本处理 123456789101112131415161718192021222324252627#!/bin/bashgup() &#123; local br br=\\`git branch 2&gt; /dev/null|\\\\grep &apos;^*&apos;|sed -e &apos;s/..//;s/\\\\n//&apos;\\` tainted=\\`git status --porcelain | \\\\grep -v &apos;^\\\\?\\\\?&apos;\\` if [[ $br == master ]]; then if [[ $tainted == &apos;&apos; ]]; then echo git stash git stash fi echo git fetch git fetch echo git rebase FETCH_HEAD $br git rebase FETCH_HEAD $br else if [[ -n $br ]]; then if [[ $tainted == &apos;&apos; ]]; then echo git stash git stash fi echo git pull --rebase origin $br git pull --rebase origin $br else echo seems not in any branch fi fi&#125; 方式4：使用 github 等自带的页面处理 base fork 选择自己的 fork 分支（贡献者）； head fork 选择被 fork 的分支（维护者）；然后发起 pull request 使用 merge 还是 rebase？ 开发以 pull request + review 为主的模式，merge 最合适 第一次合并/单人开发/同步上游改动时，rebase 最合适 参考资料 一个成功的 Git 分支模型 git-flow 备忘清单 Git Workflows and Tutorials git 里 push request 注意事项","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"GIT","slug":"技术之路/GIT","permalink":"http://yoursite.com/categories/技术之路/GIT/"}]},{"title":"Web Servive","date":"2015-12-24T16:05:00.000Z","path":"技术之路/架构设计/web-servive/","text":"WhatWeb服务是一种服务导向架构的技术，通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作。 Why以下观点来自维基百科： 重复使用的应用程序组件 连接现有的软件，在不同的应用程序和平台之间交换数据 How有三种普遍实现方式： 远程过程调用（RPC） 面向动作；目前有很多开源的 RPC 框架：YAR、GRPC、Thrift 等 RPC式WEB服务实质上是利用一个简单的映射，以把用户请求直接转化成为一个特定语言编写的函数或方法. 服务导向架构（SOA[P]） 面向消息； 遵从服务导向架构（Service-oriented architecture，SOA）概念来构筑WEB服务，在服务导向架构中，通讯由消息驱动，而不再是某个动作（方法调用）。 作为与RPC方式的最大差别，SOA方式更加关注如何去连接服务而不是去特定某个实现的细节。 通常使用 SOAP 风格；由 UDDI、 SOAP 和 WSDL 构成；他们之间的关系如下图： SOAP一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP。 WSDL一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息。 UDDI一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务。 表述性状态转移（REST） 面向资源； 表述性状态转移式（Representational state transfer，REST），是一种架构风格，把接口限定在一组广为人知的标准动作中（比如HTTP的GET、POST、PUT、DELETE）以供调用。 REST 的 基本特征： 客户端和服务器结构 连接协议具有无状态性 能够利用Cache机制增进性能 层次化的系统 REST 的三要素： 唯一的资源标识 简单的方法 一定的表达方式 三要素关系图： REST 是以 资源 为中心, 名词 即资源的地址, 动词 即施加于名词上的一些有限操作, 表达 是对各种资源形态的抽象.以HTTP为例, 名词即为URI(统一资源标识), 动词包括POST, GET, PUT, DELETE等(还有其它不常用的2个,所以 整个动词集合是有限的), 资源的形态(如text, html, image, pdf等) 参考资料 Web服务-维基百科 Web services-维基百科 面向服务的体系结构 REST 远程过程调用 Webservice学习笔记五，Web Service实践之REST vs RPC Webservice学习笔记六，SOAP, REST and XML-RPC报文格式收集 rest-vs-soap Restful-User-Experience","tags":[{"name":"web-service","slug":"web-service","permalink":"http://yoursite.com/tags/web-service/"},{"name":"soa","slug":"soa","permalink":"http://yoursite.com/tags/soa/"},{"name":"rpc","slug":"rpc","permalink":"http://yoursite.com/tags/rpc/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"架构设计","slug":"技术之路/架构设计","permalink":"http://yoursite.com/categories/技术之路/架构设计/"}]},{"title":"ActiveMQ","date":"2015-11-07T07:55:00.000Z","path":"技术之路/中间件/MQ/activemq/","text":"什么是 activeMQ？一个开源消息队列,使用 java 开发,属于 apache 基金会.官方网站:http://activemq.apache.org官方文档:http://activemq.apache.org/getting-started.html php 如何和 activeMQ 通信？采用 stomp 协议php 安装 stomp 的扩展 1pecl install stomp 采用第三方的类库:https://github.com/dejanb/stomp-php php 如何监控 activeMQ 中队列的状态？activeMQ 需要打开StatisticsPlugin方法:http://activemq.apache.org/statisticsplugin.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 获取指定队列的待处理消息数量 * * @param string $queue 待查询的队列名 * * @return mixed 成功返回待处理的消息数量 */function getMQStatus($queue)&#123; $result = $num = FALSE; $statusqueue = &quot;/queue/ActiveMQ.Statistics.Destination.&#123;$queue&#125;&quot;;//固定格式 //$statusqueue = &quot;/queue/ActiveMQ/Statistics/Destination/&#123;$queue&#125;&quot;;//固定格式 //开启ActiveMQ $link = stomp_connect(&apos;tcp://192.168.221.129:6161&apos;);//broker 的地址 if (!$link) &#123; die(&quot;Can&apos;t connect MQ !!&quot;); &#125; if (FALSE !== $link) &#123; //查询之后的结果存放处 $resultqueue = &quot;/queue/test_status_&#123;$queue&#125;&quot;; //设定采用JSON格式 stomp_subscribe($link, $resultqueue, array(&quot;transformation&quot; =&gt; &quot;jms-map-json&quot;)); //送出空字符串 $result = stomp_send($link, $statusqueue, &apos;&apos;, array(&quot;reply-to&quot; =&gt; $resultqueue)); if (FALSE === $result) &#123; echo &quot; send error&quot; . PHP_EOL; &#125; //取得状态 while (stomp_has_frame($link)) &#123; $frame = stomp_read_frame($link); if (FALSE != $frame) &#123; stomp_ack($link, $frame[&apos;headers&apos;][&apos;message-id&apos;]); $obj = json_decode($frame[&apos;body&apos;], TRUE);//$obj 包含队列的所有信息 //print_r($obj); //取得目前数量（尚可取得其他状态） foreach ($obj[&apos;map&apos;][&apos;entry&apos;] as $pitem) &#123; if (&apos;size&apos; == $pitem[&apos;string&apos;]) &#123; $num = $pitem[&apos;long&apos;]; break; &#125; &#125; &#125; &#125; stomp_unsubscribe($link, $resultqueue); stomp_close($link); &#125; return $num;&#125;$num = getMQStatus(&apos;spider&apos;);","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"activeMQ","slug":"activeMQ","permalink":"http://yoursite.com/tags/activeMQ/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"中间件","slug":"技术之路/中间件","permalink":"http://yoursite.com/categories/技术之路/中间件/"},{"name":"MQ","slug":"技术之路/中间件/MQ","permalink":"http://yoursite.com/categories/技术之路/中间件/MQ/"}]}]}