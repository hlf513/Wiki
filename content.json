{"pages":[],"posts":[{"title":"TCP/IP 协议","date":"2017-11-11T03:00:00.000Z","path":"技术之路/计算机网络/tcp-ip-协议/","text":"指代整个协议族；由两个重要的协议：传输层的 TCP协议 和网络层的 IP协议 组成。 传输层TCP 协议定义 TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义 数据传输 三次握手WHY 为什么要三次握手？为了防止已失效的客户端连接请求突然又传送到了服务端，若没有客户端确认，则会占用服务端的资源。 HOW 客户端 传输 服务端 SYN(x) -&gt; SYN(x) SYN(y)-ACK(x+1) &lt;- SYN(y)+ACK(x+1) ACK(y+1) -&gt; ACK(Y+1) 必须是客户端发起的SYN SYN: 同步序列编号（Synchronize Sequence Numbers）ACK: 确认编号（Acknowledgement Number） 四次挥手WHY 为什么要四次挥手？全双工通信，所以必须双方都确认 FIN 才可以关闭连接 HOW 客户端 传输 服务端 FIN(客户端传输完毕) -&gt; FIN ACK &lt;- ACK（先确认） FIN &lt;- FIN （服务端传输完毕） ACK -&gt; ACK 客户端、服务端都可以发起 FIN FIN: 数据传输完毕 (Finsh) 包头结构 名称 长度 源端口 16位 目标端口 16位 序列号 32位 回应序号 32位 TCP头长度 4位 reserved 6位 控制代码 6位 窗口大小 16位 偏移量 16位 校验和 16位 选项 32位(可选) TCP包头的最小长度，为20字节。 UDP 协议定义一种无连接的传输层协议；可靠性通过「应用层」保证。 数据传输不提供数据包分组、组装和不能对数据包进行排序 包头结构 名称 长度 源端口 16位 目的端口 16位 长度 16位 校验和 16位 UDP包头只有8个字节 常见的协议DNS 应用场景： 面向数据报方式 网络数据大多为短消息 拥有大量Client 对数据安全性无特殊要求 网络负担非常重，但对响应速度要求高 TCP vs UDP - TCP UDP 可靠性 可靠（面向连接） 不可靠（无连接） 有序性 有序 无序 占用资源 多 少 程序结构 复杂 简单 数据模式 数据流[1]（字节流） 数据报文[2] 通信模式 点对点 一对一，一对多，多对一，多对多 首部开销 20字节 8字节 通信信道 全双工 不可靠信道 网络层IP 协议作用IP协议是TCP/IP协议簇中的核心协议，也是TCP/IP的载体。所有的TCP，UDP，ICMP及IGMP数据都以 IP数据报 格式传输。IP提供不可靠的，无连接的数据传送服务；如果发生某种错误，IP会丢失该数据，然后发送ICMP消息给信源端 IP数据报 IP路由选择局域网经过ARP协议将目的主机的IP地址解析为MAC地址 非局域网主机通过IP数据报连接目的主机时，按照如下步骤搜索: 搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机 搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要子网掩码的协助。如果找到路由器，则将该包发向路由器。 搜索路由表，如果匹配同子网路由器失败，则匹配同网号路由器，如果找到路由器，则将该包发向路由器。 搜索路由表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包 如果都失败了，就丢掉这个包。 如何查看路由表 参考资料 维基百科-TCP 百科-TCP CDSN-TCP IP协议-CSDN IP协议-百度经验 1.可以合并多个请求数据(放在缓冲区中)，一次/多次读取完 ↩2.发送几次请求，就需要接收几次；一次只能读取一个完整的报文 ↩","tags":[],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"计算机网络","slug":"技术之路/计算机网络","permalink":"http://yoursite.com/categories/技术之路/计算机网络/"}]},{"title":"网络参考模型","date":"2017-11-10T18:52:00.000Z","path":"技术之路/计算机网络/网络参考模型/","text":"OSI 参考模型 国际标准化组织(ISO) 和 国际电报电话咨询委员会(CCITT) 联合制定了 OSI（Open System Interconnect） WHYOSI参考模型是计算机网路体系结构发展的产物；其目的是为异种计算机互连提供 一个共同的基础和标准框架 ，并为保持相关标准的一致性和兼容性提供共同的参考。 WHAT实现「开放系统互连」所建立的「通信功能」的「分层模型」；分七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 HOW 每一层的功能是独立的，利用下一层为上一层提供服务； 同等层实体之间通信由该层的协议管理。 除物理层之外，每层都会在原始数据前添加一串属于自己的协议头；接收端向上传递过程中会删除自己的协议头 服务：下一层向上一层提供的「通信功能」和「层之间的会话规定」。协议：两个开放系统中的 同等层之间的通信规则和约定 1～4层协议称为下层协议 5～7层协议称为上层协议 分层说明应用层 (Application)网络服务与最终用户的一个接口。协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP 表示层（Presentation Layer）数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）格式有，JPEG、ASCll、DECOIC、加密格式等 会话层（Session Layer）建立、管理、终止会话。（在五层模型里面已经合并到了应用层）对应主机进程，指本地主机与远程主机正在进行的会话 传输层 (Transport)定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层 网络层 (Network)进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP 数据链路层 (Link)建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。 物理层（Physical Layer）建立、维护、断开物理连接。（由底层网络定义协议） TCP/IP 参考模型 TCP/IP是先有了协议，才制定TCP/IP模型。目前是互联网的事实标准 WHYARPANET是由美国国防部DoD（U.S.Department of Defense）赞助的研究网络。逐渐地它通过租用的电话线连结了数百所大学和政府部门。当无线网络和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。 WHAT由 TCP、IP 两个协议演进过来的，共分为四层：网络访问层、互联网层、传输层和应用层 HOW 分层说明应用层为用户提供所需要的各种服务协议有：HTTP、FTP、Telnet、DNS、SMTP等. 传输层为应用层提供端到端的通信功能协议有：TCP、UDP 网络互联层负责分配地址和传送二进制数据。协议有：IP、IGMP、ICMPIP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。 网络接口层负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，所以其具体实现的方法随着网络类型的不同而不同。 OSI 比对 TCP/IP 参考资料 科来协议图 百科-七层模型 百科-TCP/IP参考模型","tags":[],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"计算机网络","slug":"技术之路/计算机网络","permalink":"http://yoursite.com/categories/技术之路/计算机网络/"}]},{"title":"欢迎来到我的知识库！","date":"2017-11-08T13:20:17.000Z","path":"index/","text":"何为「知识库」？在这个信息爆炸的年代，获取信息的成本接近于0，每天都有很多新的信息蜂拥而来；过往针对这些信息，我都是放在云笔记中（尝试过有道、印象、为知、蚂蚁等），但是放在笔记中不等于掌握，所以需要进一步的进行归纳和整理，所以才有了「知识库」。 为什么要用 github page 作为「知识库」?之前都是放在云笔记中，但是不利于查找和分享，同时有些需求云笔记不太能满足我；这边整理了下自己对「知识库」的需求： 无限级分类 可以全文搜索 内容有目录 可以方便查询 便于进行知识梳理 保证数据不会丢失 内容有更新历史 所以最终选择了使用 github page。 「知识库」和「博客」有什么区别？个人学习的过程是：收集-&gt;整理-&gt;吸收-&gt;输出 收集：采用「evernote」进行信息的收集整理：采用「知识库」进行信息/知识的整理吸收：采用「博客」对知识进行深入的剖析/个人见解输出：在工作/学习中「实战」 综上所述，「知识库」是对知识的整理，「博客」是对知识的剖析","tags":[],"categories":[]},{"title":"YAR","date":"2017-11-07T14:35:00.000Z","path":"技术之路/程序语言/PHP/yar/","text":"What一个轻量级可并行的 RPC 框架，支持三种打包协议（msgpack,json,php）,传输协议支持 http（tcp/unix以后会支持）​ github 地址：https://github.com/laruence/yarphp 官网：http://php.net/manual/zh/book.yar.php Why鸟哥举了两个场景(传统 web 应用)： 一个进程，一个请求，但是涉及到多个没有依赖性的数据源，只能串行处理（依次等待所有数据源处理）完毕后才能响应； yar 可以并行处理，减少时间开销 一个应用系统随着业务的增加，人员流失，只做加法，等到不可维护性的时候，只能重构 yar 可以给系统进行解耦（实际上是 soa 思想） Howserver放置在 web 服务器上，通过 http 访问(默认get访问会输出 doc 信息) client 串行调用 并行调用（yar 内部使用 libcurl + epoll ） 高级进阶Yar 协议分析Yar整个协议由82字节长度的yar_header + 8字节的数据打包协议(MSGPACK、JSON、PHP) + N字节的Body组成。 安全性 未验证 123456789typedef struct _yar_header &#123; unsigned int id; // transaction id unsigned short version; // protocl version unsigned int magic_num; // default is: 0x80DFEC60 unsigned int reserved; unsigned char provider[32]; // reqeust from who unsigned char token[32]; // request token, used for authentication unsigned int body_len; // request body len&#125; struct _yar_header中需要注意的是magic_num值。该值在Client与Server都应该保持一致。否则视为不合法的数据。我们可以通过修改这个值，定制一个yar框架，防止其他人恶意请求。 跨语言 利用 yar 可以接收 struct 实现 client 12345array( &quot;i&quot; =&gt; &apos;&apos;, // transaction id &quot;m&quot; =&gt; &apos;&apos;, // the method which being called &quot;p&quot; =&gt; array(), // parameters) server 1234567array( &quot;i&quot; =&gt; &apos;&apos;, &quot;s&quot; =&gt; &apos;&apos;, //status &quot;r&quot; =&gt; &apos;&apos;, //return value &quot;o&quot; =&gt; &apos;&apos;, //output &quot;e&quot; =&gt; &apos;&apos;, //error or exception) 参考资料 Yar – 并行的RPC框架(Concurrent RPC framework) YAR 并行RPC框架研究 Yar协议分析与跨语言实现","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"yar","slug":"yar","permalink":"http://yoursite.com/tags/yar/"},{"name":"php_ext","slug":"php-ext","permalink":"http://yoursite.com/tags/php-ext/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"程序语言","slug":"技术之路/程序语言","permalink":"http://yoursite.com/categories/技术之路/程序语言/"},{"name":"PHP","slug":"技术之路/程序语言/PHP","permalink":"http://yoursite.com/categories/技术之路/程序语言/PHP/"}]},{"title":"MAC 必备软件","date":"2017-11-06T15:25:00.000Z","path":"效率工具/mac/","text":"系统 Vanilla：隐藏菜单栏 Spectacle：窗口分屏 Coffitivity：白噪音 Enpass：密码管理工具 TeamViewer：远程控制 Tickeys：打字音效 Lantern：“VPN” 学习 Anki：复习工具 Evernote：收集资料 Leanote：笔记 MarginNote Pro：学习 pdf 神器（收费） MindNode：思维导图（收费） 工作 Atom：编辑器 Charles：抓包工具（收费） Dash：文档（收费） iTerm 2：终端 PhpStorm：PHP 的 IDE Sequel Pro：Mysql 客户端 SourceTree：Git 客户端 Sublime Text：轻量可定制编辑器 Typora：MD 编辑器","tags":[],"categories":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/categories/效率工具/"}]},{"title":"Blog 系统之 Hexo","date":"2017-11-05T06:26:00.000Z","path":"开源软件简析/blog/","text":"Blog 系统之前用的是 Octopress ，由于不更新了，且使用的是 ruby 开发，生成 html 比较慢，所以迁移到 hexo。 Hexo安装 hexohexo 文档 1234$ npm install -g hexo-cli$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 安装完毕后，请自行修改 /_config.yml 最后别忘记添加 CNAME 主题采用 Hiker 主题；[中文说明] [Github] 删除作者自己的 cnzz 统计代码 12345678910# source/js/scripts.js 中，删除以下代码var s = [ '&lt;div style=\"display: none;\"&gt;', '&lt;script src=\"https://s11.cnzz.com/z_stat.php?id=1260716016&amp;web_id=1260716016\" language=\"JavaScript\"&gt;&lt;/script&gt;', '&lt;/div&gt;' ].join(''); var di = $(s); $('#container').append(di); 修改主题的配置文件 12345# /themes/hiker/_config.yml# 清空以下信息，都是作者本人信息social:donate:# 其他数据请自行填充 Atom 配置 采用 atom 作为 md 的编辑器 详细配置见：atom-hexo配置 Hexo 命令 详细命令清单见：hexo 命令 新增文章1$ hexo new [layout] &lt;title&gt; 预览1$ hexo g 实时更新预览1$ hexo g -w 发布1$ hexo d -g 自定义命令配置 bash/zsh 的配置文件 .basrc/.zshrc 增加如下命令 123export BLOG_PATH=\"blog的目录\"alias blog_root=\"cd $BLOG_PATH/\"PATH=\"...:$BLOG_PATH/shell\" 进入 Hexo 根目录1blog_root 预览1blog_preview 生成 html1blog_generate 发布1blog_deploy 打开 atom1blog_atom","tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"Atom 编辑器","date":"2017-11-04T21:51:00.000Z","path":"开源软件简析/atom/","text":"安装插件 markdown-preview-enhanced ：增强版 md 预览 markdown-writer ：写博客必备利器 tool-bar ：工具栏基类 tool-bar-markdown-writer ： md-writer的工具栏 vim-mode-plus ：vim 插件 markdown-table-editor ：表格编辑工具 atom-terminal ：终端 tool-bar-markdown-writer 修改文件 ~/.atom/packages/tool-bar-markdown-writer/lib/tool-bar-markdown-writer.coffee 增加如下功能： 增加 publish-draft Preview markdown 增加支持 markdown-preview-enhanced 新增的配置如下：12345678910111213&#123; 'icon': 'content-duplicate' 'tooltip': 'Publish Draft' 'callback': 'markdown-writer:publish-draft'&#125;&#123; 'icon': 'markdown' 'tooltip': 'Preview Markdown' 'data': ['markdown-preview-enhanced', 'markdown-preview-plus','markdown-preview'] 'visible': (data) -&gt; pkg = data.find (pkg) -&gt; !!atom.packages.getLoadedPackage(pkg) \"#&#123;pkg&#125;:toggle\" if pkg&#125; Atom 配置文件123456789101112131415161718192021\"*\": core: packagesWithKeymapsDisabled: [ \"markdown-preview\" ] telemetryConsent: \"no\" \"exception-reporting\": userId: \"5a8289c3-5832-4d26-af7b-3235427b72da\" \"markdown-preview-enhanced\": enableExtendedTableSyntax: true imageDropAction: \"copy to image folder\" mathRenderingOption: \"MathJax\" \"markdown-writer\": fileExtension: \".md\" renameImageOnCopy: true \"tool-bar\": &#123;&#125; \"tool-bar-markdown-writer\": &#123;&#125; \"vim-mode-plus\": notifiedCoffeeScriptNoLongerSupportedToExtendVMP: true welcome: showOnStartup: false Simiki 配置 主要使用的是 md-writer 生成项目专用的配置文件： 1点击 packages -&gt; markdown-writer -&gt; configurations -&gt; create project configs 最终在项目的根目录下生成 _mdwriter.cson 修改如下配置： 1234567891011121314151617181920212223242526272829303132# Directory to drafts from siteLocalDirsiteDraftsDir: \"content/\"# Directory to posts from siteLocalDirsitePostsDir: \"content/\"# Directory to images from siteLocalDir# - E.g. to use the current filename directory, can use &#123;directory&#125;siteImagesDir: \"attach/img/&#123;year&#125;/&#123;month&#125;/\"# Filename format of new drafts creatednewDraftFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Filename format of new posts creatednewPostFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Front matter date format, determines the &#123;date&#125; in frontMatterfrontMatterDate: \"&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;\"# Front matter templatefrontMatter: \"\"\"---title: \"&#123;title&#125;\"date: \"&#123;date&#125;\"layout: \"page\"---[TOC]\"\"\"# File extension of posts/draftsfileExtension: \".md\"# File slug separatorslugSeparator: \"-\"tableExtraPipes: true Hexo 配置 主要使用的是 md-writer 生成项目专用的配置文件： 1点击 packages -&gt; markdown-writer -&gt; configurations -&gt; create project configs 最终在项目的根目录下生成 _mdwriter.cson 修改如下配置： 12345678910111213141516171819202122232425262728293031323334353637siteEngine: \"hexo\"# Website URL of your blogsiteUrl: \"http://www.helongfei.com\"# Directory to drafts from siteLocalDirsiteDraftsDir: \"source/_drafts/\"# Directory to posts from siteLocalDirsitePostsDir: \"source/_posts/&#123;year&#125;/\"# Directory to images from siteLocalDir# - E.g. to use the current filename directory, can use &#123;directory&#125;siteImagesDir: \"source/images/&#123;year&#125;/&#123;month&#125;/\"# Filename format of new drafts creatednewDraftFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Filename format of new posts creatednewPostFileName: \"&#123;slug&#125;&#123;extension&#125;\"# Front matter date format, determines the &#123;date&#125; in frontMatterfrontMatterDate: \"&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;\"# Front matter templatefrontMatter: \"\"\"---layout: \"&#123;layout&#125;\"title: \"&#123;title&#125;\"date: \"&#123;date&#125;\"---\"\"\"# File extension of posts/draftsfileExtension: \".md\"# File slug separatorslugSeparator: \"-\"# Table row continuation# - Enable to auto insert table columns when you press enter in a table rowtableNewLineContinuation: true","tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"Wiki 系统之 Simiki","date":"2017-11-03T16:00:00.000Z","path":"开源软件简析/wiki/","text":"Wiki 系统需求：git+md 系统 实现方式 缺点 优点 dokuwiki php+文本 编辑器不好用；数据量大搜索可能有性能问题（txt） 插件丰富，txt移植方便 mediawiki php+mysql 配置复杂；visualeditor 加载慢 功能全面，visualeditor simiki git+md 全量生成html；图片支持不好 可定制 gitbook git+md 全量生成 html ( 渲染巨慢 ) 有编辑器 Simiki 安装simiki 文档 123pip install simikimkdir mywiki &amp;&amp; cd mywikisimiki init 配置 _config.yml 123456789101112url:title:keywords:description:author:theme: yasimple_x2markdown: - fenced_code - extra - codehilite(css_class=hlcode, linenums=False) - toc(title=Table of Contents) 增加 CNAME 文件 为了域名解析；文本内容为待解析域名 Atom 配置 使用 Atom 作为 md 编辑器 详细配置见 Atom-simike 配置 发布fab需要_config.yml增加如下配置项： 1234deploy: - type: git remote: origin branch: gh-pages 发布的时候如下命令： 1fab deploy #不支持python3 shell使用自定义命令： 1wiki_deploy simiki 命令生成 html1simiki g 预览 wiki1simiki p 实时生成 html1simiki p -w","tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"Codeception 之验收测试","date":"2016-05-02T07:38:09.000Z","path":"技术之路/测试/codeception/","text":"Acceptance Testing验收测试针对整个站点进行测试，模拟真实用户的访问流程。 写测试的人员不需要知道网站的内部实现。 两种测试类型PhpBrowser配置tests/acceptance.suite.yml 123456class_name: AcceptanceTestermodules: enabled: - PhpBrowser: url: - \\Helper\\Acceptance Selenium WebDriver配置tests/acceptance.suite.yml 1234567class_name: AcceptanceTestermodules: enabled: - WebDriver: url: browser: chrome - \\Helper\\Acceptance 配置Selenium环境 下载Selenium Standalone Server 下载Google Chrome Driver 启动： 1234//启动selenium-serverjava -jar selenium-server-standalone-2.53.0.jar//启动Chrome Driver./chromedriver 编写测试 测试写在tests/acceptance,后缀为Cept，例如：SiginCept.php PhpBrowser测试文档参考：PHP Browser actions Assertions Grabbers Comments Cookies, Urls, Title Selenium WebDriver测试文档参考：Selenium WebDriver Session Snapshots 其他DB配置 SQL语句放在 /tests/_data 下 DB-config修改codeception.yml Debug 命令行增加 --debug 手动输出 codecept_debug() 手动下一步 pauseExecution 记录测试 Recorder extension 参考资料 Acceptance Testing介绍 PHP Browser介绍 PHP Browser文档 Selenium WebDriver文档","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"Codeception","slug":"Codeception","permalink":"http://yoursite.com/tags/Codeception/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"测试","slug":"技术之路/测试","permalink":"http://yoursite.com/categories/技术之路/测试/"}]},{"title":"RBAC","date":"2016-04-10T06:36:00.000Z","path":"技术之路/权限控制/rbac/","text":"前言在权限设计中，若权限比较复杂，使用简单的权限判断，则会使代码比较冗长，逻辑比较复杂，不利用维护和扩展。这时可以考虑使用 RBAC。 RBAC 介绍RBAC（Role-Based Access Control ）基于角色的访问控制。抽象出来就是用户，角色和权利三个方面。在权利和用户之间，增加一个角色，使其不再耦合在一起，方便维护和扩展。 一个角色拥有多个权利，一个用户想拥有某些权利时，只需要附给用户相应的角色即可。若一些用户需要相同的角色，则建立起用户组即可。 RBAC 分类RBAC0 RBAC核心,其他分类都是建立在此基础上 主要有四部分组成： 用户 角色 权限 会话 用户和角色是多对多关系，角色和权限是多对多关系。 一个会话只能由一个用户创建，会话和角色是多对多关系。一般会有8张表来设计(若不需要用户组，则是5张表)： RBAC1 基于 RBAC0 的角色分级；角色有了继承和包含的层级 这种模型使用 RBAC0 也是可以实现的，但是会造成数据冗余 RBAC2 基于 RBAC0 的角色限制（互斥，数量限制等） RBAC3 组合 RBAC1 和 RBAC2 RBAC 总结通常使用 RBAC0 就可以解决大部分权限问题，其他的细节在具体的设计中具体分析。RBAC 只是一种设计思想，我们在设计的过程中要具体问题具体分析，灵活的使用，不要照本宣科。 参考资料 权限管理——RBAC模型总结 RBAC RBAC权限管理 基于角色的访问控制","tags":[{"name":"rbac","slug":"rbac","permalink":"http://yoursite.com/tags/rbac/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"权限控制","slug":"技术之路/权限控制","permalink":"http://yoursite.com/categories/技术之路/权限控制/"}]},{"title":"PSR","date":"2016-04-02T16:45:00.000Z","path":"技术之路/程序语言/PHP/php-psr/","text":"PSR PSR 来自 PHP FIG(框架协同工作组) 现有规范 PSR-0/PSR-4 自动加载（2014.10.21起弃用，请使用 PSR-4） PSR-1 基本规范 PSR-2 代码风格 PSR-3 日志接口 PSR-0/PSR-4 自动加载class 指 class,interface,trait和其他相似的结构 PSR-0(弃用)按照目录拼接类名 1234/path/to/src/ VendorFoo/ Bar/ Baz.php # VendorFoo_Bar_Baz PSR-4 类名中下划线转为目录 每个命名空间必须有顶级命名空间（vender） 1234Vendor_Name |- Name_space |- Class |-Name.php # \\Vendor_Name\\Name_space\\Class_Name 自动加载方法 函数 12345678910111213141516&lt;?phpfunction autoload($className)&#123; $className = ltrim($className, &apos;\\\\&apos;); $fileName = &apos;&apos;; $namespace = &apos;&apos;; if ($lastNsPos = strrpos($className, &apos;\\\\&apos;)) &#123; $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $fileName = str_replace(&apos;\\\\&apos;, DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; &#125; $fileName .= str_replace(&apos;_&apos;, DIRECTORY_SEPARATOR, $className) . &apos;.php&apos;; require $fileName;&#125; 类: SplClassLoader PSR-1 基本代码规范 「文件」源文件必须只使用 &lt;?php 和 &lt;?= 这两种标签。 「文件」源文件中php代码的编码格式必须只使用不带字节顺序标记(BOM)的UTF-8。 「类」类名(class name) 必须使用骆驼式(StudlyCaps)写法。 「类」类(class)中的常量必须只由大写字母和下划线(_)组成。 「类」方法名(method name) 必须使用驼峰式(cameCase)。 「文件」一个源文件建议只用来做声明（类(class)，函数(function)，常量(constant)等）或者只用来做一些引起副作用的操作（例如：输出信息，修改.ini配置等）,但不建议同时做这两件事。 PSR-2 代码风格指南针对 PSR-1 的继承和扩展 「缩进」代码必须使用4个空格来进行缩进，而不是用制表符。 「行」一行代码的长度不建议有硬限制；软限制必须为120个字符，建议每行代码80个字符或者更少；非空行不可有空格；一行不可多于一个语句. 「文件」纯 php 文件 `必须` 省略;`必须`以空行结束123456789- 「命名空间」在`命名空间(namespace)`的声明下面`必须`有一行空行，并且在`导入(use)`的声明下面也`必须`有一行空行。- 「类」`类(class)`的左花括号`必须`放到其声明下面自成一行，右花括号则`必须`放到类主体下面自成一行。- 「方法」`方法(method)`的左花括号`必须`放到其声明下面自成一行，右花括号则`必须`放到方法主体的下一行。- 「属性|方法」所有的`属性(property)`和`方法(method)` `必须`有可见性声明；`抽象(abstract)`和`终结(final)`声明`必须`在可见性声明之前；而`静态(static)`声明`必须`在可见性声明之后。- 「关键字和常量」关键字和常量(true，false，null)`必须`小写- 「控制结构」在控制结构关键字的后面`必须`有一个空格；而`方法(method)`和`函数(function)`的关键字的后面`不可`有空格。- 「控制结构」控制结构的左花括号`必须`跟其放在同一行，右花括号`必须`放在该控制结构代码主体的下一行。- 「控制结构」控制结构的左括号之后`不可`有空格，右括号之前也`不可`有空格。- 「类」`不建议`使用`_`来表明方法和属性的保护性 &lt;?phpnamespace Vendor\\Package; use FooInterface;use BarClass as Bar;use OtherVendor\\OtherPackage\\BazClass; class Foo extends Bar implements FooInterface, Bar{ public function sampleFunction($a, $b = null) { if ($a === $b) { bar(); } elseif ($a &gt; $b) { $foo-&gt;bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { $foo-&gt;bar( $longArgument, $longerArgument, $muchLongerArgument ); $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument = null ) use ($var1) { // body }; } public function aVeryLongMethodName( ClassTypeHint $arg1, &amp;$arg2, array $arg3 = [] ) { switch ($expr) { case 0: echo &apos;First case, with a break&apos;; break; case 1: echo &apos;Second case, which falls through&apos;; // no break case 2: case 3: case 4: echo &apos;Third case, return instead of break&apos;; return; default: echo &apos;Default case&apos;; break; } while ($expr) { // structure body } do { // structure body; } while ($expr); for ($i = 0; $i &lt; 10; $i++) { // for body } foreach ($iterable as $key =&gt; $value) { // foreach body } try { // try body } catch (FirstExceptionType $e) { // catch body } catch (OtherExceptionType $e) { // catch body } } }``` PSR-3 日志接口主要目标是让类库获得一个Psr\\Log\\LoggerInterface对象并能通过简单通用的方式来写日志 8个等级（debug, info, notice, warning, error, critical, alert, emergency） log 方法(等级，日志)； 等级必须一致，否则必须抛出Psr\\Log\\InvalidArgumentException 日志必须是字符串，或者是可__toString的对象 …. 代码检查工具PHP Mess DetectorPHP项目体检工具，根据你设定的标准（如单一文件代码体积，未使用的参数个数，未使用的方法数）检查PHP代码，超出设定的标准时报警。 PHP Copy Paste Detector顾名思义，检查冗余代码的 PHP Dead Code Detector看名字就知道了，检查从未被调用过的方法 PHP Code SnifferPHPLint持续集成jenkins把上述工具以plugins形式整合起来 xinc+phing跟上述工具集成起来做持续集成后的自动化打包发布 参考资料 PHP PSR代码标准中文版 PHP中有什么好的代码自动检查工具吗","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"PSR","slug":"PSR","permalink":"http://yoursite.com/tags/PSR/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"程序语言","slug":"技术之路/程序语言","permalink":"http://yoursite.com/categories/技术之路/程序语言/"},{"name":"PHP","slug":"技术之路/程序语言/PHP","permalink":"http://yoursite.com/categories/技术之路/程序语言/PHP/"}]},{"title":"UML","date":"2016-02-28T15:22:00.000Z","path":"技术之路/面向对象/uml/","text":"UML 类图中的关系关联关系用于表示一类对象与另一类对象之间有联系程序中，通常将一个类的对象作为另一个类的成员变量 双向关联 单向关联 自关联 在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联 多重性关联 表示两个关联对象在数量上的对应关系 表示方式 多重性说明 1..1 表示另一个类的一个对象只与该类的一个对象有关系 0..* 表示另一个类的一个对象与该类的零个或多个对象有关系 1..* 表示另一个类的一个对象与该类的一个或多个对象有关系 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系 m..n 表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n) 聚合关系 整体（整体对象）和部分（成员对象）可以分开独立存在 这里表示的是：汽车和发动机还有个更形象的比喻：雁群和雁子 程序中，成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中 组合关系 整体和部分不可分开，有相同的生命周期 这里表示的是：头和嘴还有个更形象的比喻：雁子和翅膀 程序中，通常在整体类的构造方法中直接实例化成员类 依赖关系 表示一个事物「使用」另一个事物时使用依赖关系 程序中，依赖关系体现在某个类的方法使用另一个类的对象作为参数 将一个类的对象作为另一个类中方法的参数 在一个类的方法中将另一个类的对象作为其局部变量 在一个类的方法中调用另一个类的静态方法 泛化关系 泛化关系就是继承关系 接口与实现关系 总结各种关系的强弱顺序： 泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖 参考资料 深入浅出UML类图（二） 深入浅出UML类图（三） UML类图几种关系的总结","tags":[{"name":"uml","slug":"uml","permalink":"http://yoursite.com/tags/uml/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"面向对象","slug":"技术之路/面向对象","permalink":"http://yoursite.com/categories/技术之路/面向对象/"}]},{"title":"设计原则","date":"2016-02-21T06:04:00.000Z","path":"技术之路/面向对象/oo-principle/","text":"前言在面对一个复杂项目的时候，为了提高项目的 扩展性、 复用性、 可维护性，我们往往会进行抽象设计；而这些原则是从许多成功设计方案中总结出的指导性原则，为我们学习设计模式和设计系统提供了很好的帮助。 设计原则 设计原则名称 定义 使用频率 开闭原则(Open-Closed Principle, OCP) 一个软件实体对扩展开放，而对修改关闭 ★★★★★ 里氏代换原则(Liskov Substitution Principle, LSP) 所有引用基类对象的地方能够透明地使用其子类的对象 ★★★★★ 依赖倒转原则(Dependence Inversion Principle, DIP) 抽象不应该依赖于细节，细节应该依赖于抽象 ★★★★★ 单一职责原则(Single Responsibility Principle, SRP) 一个类只负责一个功能领域中的相应职责 ★★★★☆ 合成复用原则(Composite Reuse Principle, CRP) 尽量使用对象组合，而不是继承来达到复用的目的 ★★★★☆ 迪米特法则(Law of Demeter, LoD) 一个软件实体应当尽可能少地与其他实体发生相互作用 ★★★☆☆ 接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口 ★★☆☆☆ 开闭原则「软件实体」可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 作用 在项目的迭代过程中，出现新的需求或者需求改动时，在不修改现有代码的情况下，就可扩展新的行为。(总目标) 如何做？ 思考增加需求时，如何实现？ 抽象化是开闭原则的关键把 可能会发生变化的地方 （ 要对需求的变更有预见性 ）放到抽象类中，具体的实现在子类中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可。 避免过度使用遵循开闭原则，通常会引入新的抽象层次， 增加代码的复杂度。需要把注意力集中在设计中 最有可能改变的地方 ，然后应用开闭原则。每个地方都采用开闭原则，是一种浪费，也没必要，还会导致代码变得复杂且难以理解。 具体实例 多图表-柱状、饼状[2] 里氏替换原则作用 里氏代换原则是实现开闭原则的重要方式之一；保证整个继承体系不被破坏。 如何做？ 子类不能重新定义父类的方法/属性 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法 尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。（运行时，子类实例替换父类实例） 具体实例 给不同等级的客户发送邮件[3] 依赖倒转原则作用 依赖倒转原则就是面向对象设计的主要实现机制之一；它是系统抽象化的具体实现。依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 如何做？ 要针对接口编程，而不是针对实现编程 传递参数时或在关联关系中，尽量引用层次高的抽象层类；使用 接口和抽象类 进行变量类型声明、参数类型声明等使用继承时，遵循里氏替换原则 针对抽象层编程，而将具体类的对象通过 [依赖注入] 的方式注入到其他对象中;[依赖注入]是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象；主要有以下三种方式：构造注入、设值注入（Setter注入）、接口注入 具体实例 存储不同格式的文件到数据库[4] 单一职责原则作用 单一职责原则是实现 高内聚、低耦合 的指导方针；提高类的复用性。当一个模块或一个类被设计成只支持一组相关功能时，我们说它具有「高内聚」。 如何做？ 发现类的不同职责并将其分离；一个类应该只有一个引起变化的原因 将不同的职责(变化原因)封装在不同的类中 如果多个职责总是同时发生改变则可将它们封装在同一类中 随着系统的成长，随时查看某个类是否超过一个变化原因, 具体实例 客户关系管理[8] 合成复用原则作用 程序设计中，确定复用是用继承还是组合 如何做？ 要判断使用组合/聚合关系（关联关系）还是继承 组合/聚合 优先考虑；两个类之间是“Has-A”的关系应使用组合或聚合；Has-A 表示某一个角色具有某一项责任 优点： “黑盒”复用，因为被包含对象的内部细节对外是不可见（封装性好） 通过获取具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合。 缺点： 对象过多，不易理解 继承 两个类之间是“Is-A”关系可使用继承；Is-A 表示一个类是另一个类的”一种” 优点： 有效使用继承会有助于对问题的理解，降低复杂度（严格遵循里氏代换原则） 缺点： 滥用继承反而会增加系统构建和维护的难度以及系统的复杂度 “白盒”复用，因为父类的内部细节对于子类而言通常是可见的。（封装性差） 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性 继承只能在有限的环境中使用（如类没有声明为不能被继承） 具体实例 数据保存在不同的数据库中[6] 迪米特法则作用降低系统的耦合度，使类与类之间保持松散的耦合关系。 如何做？ 思考软件实体之间的交互；确定只和“朋友”打交道 不要和“陌生人”说话、只与你的直接朋友通信；对于一个对象，其朋友包括以下几类： 当前 对象本身 (this)； 参数对象：以参数形式传入到当前对象方法中的对象； 当前对象的 成员对象；如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所 创建的对象 应该尽量减少对象之间的交互 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用 如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用 在类之间的设计上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及 在单个类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限，一个类型应当尽量设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低 具体实例 一个多操作的窗口[7] 接口隔离原则作用 系统解开耦合，从而容易重构，更改和重新部署 如何做？ 接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来 接口职责要单一将大接口中的方法根据 职责不同 分别放在不同的小接口中，以确保每个接口都承担某一单一角色。 为不同的客户端提供宽窄不同的接口接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可。 注意：在使用接口隔离原则时，我们需要注意控制接口的粒度。接口太小会导致系统中接口泛滥，不利于维护；接口太大将违背接口隔离原则，灵活性较差，使用起来很不方便。 一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法 具体实例 将文件内容转为不同的数据格式存储[5] 总结 不要过度使用设计模式，一切从简。 设计原则 说明 开闭原则 对扩展开放，对修改关闭 里氏替换原则 不要破坏继承体系 依赖倒置原则 面向接口编程 单一职责原则 类要职责单一 接口隔离原则 接口要精简单一 迪米特法则 软件实体间要降低耦合 合成复用原则 复用时要合理使用继承和组合 设计原则之间的关系，个人总结如下： 参考资料 面向对象设计原则概述 面向对象设计原则之开闭原则 面向对象设计原则之里氏代换原则 面向对象设计原则之依赖倒转原则 面向对象设计原则之接口隔离原则 面向对象设计原则之合成复用原则 面向对象设计原则之迪米特法则 面向对象设计原则之单一职责原则","tags":[{"name":"OO","slug":"OO","permalink":"http://yoursite.com/tags/OO/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"面向对象","slug":"技术之路/面向对象","permalink":"http://yoursite.com/categories/技术之路/面向对象/"}]},{"title":"Pandoc","date":"2016-01-04T00:00:00.000Z","path":"开源软件简析/pandoc/","text":"Pandocpandoc 是一个 markdown 文档转换工具，可以把 markdown 转换为诸多的格式，可以定制格式，编写过滤器等。pandoc 支持的格式，可以参考官网：http://www.pandoc.org pandoc 的语法，请看：官网英文 / 中文翻译 pandoc 过滤器编写，请看：https://github.com/jgm/pandoc/wiki/Pandoc-Filters 如何自定义样式Html 样式Html 可以指定 css 文件进行样式修改 方式一：引入 css 文件 1234table&#123;border-collapse:collapse;border:1px solid #CCC;background:#efefef;&#125;table caption&#123;text-align:left; background-color:#fff; line-height:2em; font-size:14px; font-weight:bold; &#125;table th&#123;text-align:left; font-weight:bold;height:26px; line-height:26px; font-size:12px; border:1px solid #CCC;&#125;table td&#123;height:20px; font-size:12px; border:1px solid #CCC;background-color:#fff;&#125; 1$ pandoc -s -c [cssfile] [mdfile] -o [htmlname] 方式二：页面内置样式（写入 header） 123456&lt;style type=\"text/css\"&gt;table&#123;border-collapse:collapse;border:1px solid #CCC;background:#efefef;&#125;table caption&#123;text-align:left; background-color:#fff; line-height:2em; font-size:14px; font-weight:bold; &#125;table th&#123;text-align:left; font-weight:bold;height:26px; line-height:26px; font-size:12px; border:1px solid #CCC;&#125;table td&#123;height:20px; font-size:12px; border:1px solid #CCC;background-color:#fff;&#125;&lt;/style&gt; 1$ pandoc -s -H [cssfile] [mdfile] -o [htmlname] Docx 样式pandoc 可以使用 docx 模板进行渲染（注意：模板是修改样式，而不是内容） 可以把自己修改后的样式保存为「word 模板」 1$ pandoc --reference-docx=[模板路径] [mdfile] -o [docxname] Docx 模板分享自己的 docx 模板（不断更新中） 技术文档docx模板 TeX 模板见 Phodal Huang 毕业设计模板 (百度盘备份) 使用方法：需要保存为*.docx 文件，然后使用 --template 选项指定模板 生成 Html 幻灯片利用 markdown 直接生成 web-based slideshow；可以自定义 css ，足够灵活。 支持那些幻灯片框架？pandoc 包含5种 html 幻灯片框架： DZSlides Slidy S5 Slideous reveal.js 实际上可以使用任何幻灯片框架（比如Google I/O HTML5 slide template），只要让Pandoc在渲染HTML时使用你指定的模板即可. 生成默认模板的幻灯片pandoc 内置 dzslides 框架 1$ pandoc [*.md] -o [*.html] -t dzslides -s 可选配置渐进显示 生成幻灯片时加入 -i 选项，用于控制列表的显示效果（逐条渐入） 两段文字显示之间的人为停顿: ... 强制分割默认是2级标题分割。可以使用-----------------强制分割;也可以使用 --slide-level 选项覆盖默认的 Slide level 代码高亮风格控制代码高亮风格的选项有： –highlight-style pygments –highlight-style kate –highlight-style monochrome –highlight-style espresso –highlight-style haddock –highlight-style tango –highlight-style zenburn 自定义样式这里着重分析下 reveal.js ；为什么？因为只有它有提示板。 安装reveal.js1$ git clone https://github.com/hakimel/reveal.js 生成幻灯片 Html1$ pandoc [*.md] -o [*.html] -t revealjs -s [-V theme=beige] 支持的样式： default：（默认）深灰色背景，白色文字 beige：米色背景，深色文字 sky：天蓝色背景，白色细文字 night：黑色背景，白色粗文字 serif：浅色背景，灰色衬线文字 simple：白色背景，黑色文字 solarized：奶油色背景，深青色文字 提示板按 s 触发； 增加小抄： 123456&lt;aside class=\"notes\"&gt; * 这里是提示1 * 这里是提示2&lt;/aside&gt; 参考资料 Markdown+Pandoc→HTML幻灯片速成","tags":[{"name":"pandoc","slug":"pandoc","permalink":"http://yoursite.com/tags/pandoc/"},{"name":"ppt","slug":"ppt","permalink":"http://yoursite.com/tags/ppt/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"categories":[{"name":"开源软件简析","slug":"开源软件简析","permalink":"http://yoursite.com/categories/开源软件简析/"}]},{"title":"GitFlow","date":"2016-01-02T09:06:00.000Z","path":"技术之路/GIT/git-flow/","text":"目前收集到的工作流有以下几种，其中最常用的是 Gitflow 和 Forking + Pull request Git工作流集中式 svn 形式的代码管理 所有的代码都在 master 分支上开发（线性开发） 功能分支 以集中式工作流为基础，不同的是新功能在新分支上开发 开发完毕发起 pull request 讨论通过后合并到 master Gitflow 来源2010 年初，荷兰的程序员 Vincent Driessen 在他自己的博客 http://nvie.com/ 发表了一篇文章 《A successful Git branching model》 简述 在功能分支的基础上，增加了维护和开发的便利性 两个长期分支：master 和 develop；三个短期分支：feature，release，hotfix 5个分支说明 master 分支只做发布 develop 分支做开发功能集成 feature 分支来自 develop 分支，用于新特性开发，被合并到 develop 分支 release 分支来自 develop 分支，用于预发布与测试，被合并到 master 分支和 develop 分支 hotfix 分支来自 master 分支，用于修改线上bug，被合并回 master 分支 和 develop 分支/release 分支 插件123456git flow feature start // 开始一个特性的开发git flow feature finish // 完成一个特性的开发git flow release start // 开始一次 releasegit flow release finish // 完成一次 releasegit flow hotfix start // 开始一个线上bug修复git flow hotfix finish // 完成一个线上bug修复 详情见 git flow Forking + Pull request 利用分支合并，方便接受其他贡献者的提交，而无须开放项目权限 贡献者 push 自己的代码到自己的服务端仓库，发起 pull request 项目的维护者review 后合并 github，osc 等都使用此种工作流 本地添加远程项目1git remote add [upstream-name] [upstream-url] pull request的注意事项 base fork 与 head fork 的区别 base fork : 请求 pull requeat 的分支，通常是被 fork 的分支（维护者）； head fork ：希望被合并的分支，通常是自己fork 的分支（贡献者） fork 的项目和原有项目保持同步 方式1：分步处理 需要预览和对比，则使用： 123$ git remote update [upstream-name]$ git checkout [branch-name]$ git rebase [upstream/branch-name] ​方式2：一步处理 不需要预览则使用： 1$ git pull --rebase [upstream-name] [branch-name] 方式3：脚本处理 123456789101112131415161718192021222324252627#!/bin/bashgup() &#123; local br br=\\`git branch 2&gt; /dev/null|\\\\grep &apos;^*&apos;|sed -e &apos;s/..//;s/\\\\n//&apos;\\` tainted=\\`git status --porcelain | \\\\grep -v &apos;^\\\\?\\\\?&apos;\\` if [[ $br == master ]]; then if [[ $tainted == &apos;&apos; ]]; then echo git stash git stash fi echo git fetch git fetch echo git rebase FETCH_HEAD $br git rebase FETCH_HEAD $br else if [[ -n $br ]]; then if [[ $tainted == &apos;&apos; ]]; then echo git stash git stash fi echo git pull --rebase origin $br git pull --rebase origin $br else echo seems not in any branch fi fi&#125; 方式4：使用 github 等自带的页面处理 base fork 选择自己的 fork 分支（贡献者）； head fork 选择被 fork 的分支（维护者）；然后发起 pull request 使用 merge 还是 rebase？ 开发以 pull request + review 为主的模式，merge 最合适 第一次合并/单人开发/同步上游改动时，rebase 最合适 参考资料 一个成功的 Git 分支模型 git-flow 备忘清单 Git Workflows and Tutorials git 里 push request 注意事项","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"GIT","slug":"技术之路/GIT","permalink":"http://yoursite.com/categories/技术之路/GIT/"}]},{"title":"Web Servive","date":"2015-12-24T16:05:00.000Z","path":"技术之路/架构设计/web-servive/","text":"WhatWeb服务是一种服务导向架构的技术，通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作。 Why以下观点来自维基百科： 重复使用的应用程序组件 连接现有的软件，在不同的应用程序和平台之间交换数据 How有三种普遍实现方式： 远程过程调用（RPC） 面向动作；目前有很多开源的 RPC 框架：YAR、GRPC、Thrift 等 RPC式WEB服务实质上是利用一个简单的映射，以把用户请求直接转化成为一个特定语言编写的函数或方法. 服务导向架构（SOA[P]） 面向消息； 遵从服务导向架构（Service-oriented architecture，SOA）概念来构筑WEB服务，在服务导向架构中，通讯由消息驱动，而不再是某个动作（方法调用）。 作为与RPC方式的最大差别，SOA方式更加关注如何去连接服务而不是去特定某个实现的细节。 通常使用 SOAP 风格；由 UDDI、 SOAP 和 WSDL 构成；他们之间的关系如下图： SOAP一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP。 WSDL一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息。 UDDI一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务。 表述性状态转移（REST） 面向资源； 表述性状态转移式（Representational state transfer，REST），是一种架构风格，把接口限定在一组广为人知的标准动作中（比如HTTP的GET、POST、PUT、DELETE）以供调用。 REST 的 基本特征： 客户端和服务器结构 连接协议具有无状态性 能够利用Cache机制增进性能 层次化的系统 REST 的三要素： 唯一的资源标识 简单的方法 一定的表达方式 三要素关系图： REST 是以 资源 为中心, 名词 即资源的地址, 动词 即施加于名词上的一些有限操作, 表达 是对各种资源形态的抽象.以HTTP为例, 名词即为URI(统一资源标识), 动词包括POST, GET, PUT, DELETE等(还有其它不常用的2个,所以 整个动词集合是有限的), 资源的形态(如text, html, image, pdf等) 参考资料 Web服务-维基百科 Web services-维基百科 面向服务的体系结构 REST 远程过程调用 Webservice学习笔记五，Web Service实践之REST vs RPC Webservice学习笔记六，SOAP, REST and XML-RPC报文格式收集 rest-vs-soap Restful-User-Experience","tags":[{"name":"web-service","slug":"web-service","permalink":"http://yoursite.com/tags/web-service/"},{"name":"soa","slug":"soa","permalink":"http://yoursite.com/tags/soa/"},{"name":"rpc","slug":"rpc","permalink":"http://yoursite.com/tags/rpc/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"架构设计","slug":"技术之路/架构设计","permalink":"http://yoursite.com/categories/技术之路/架构设计/"}]},{"title":"ActiveMQ","date":"2015-11-07T07:55:00.000Z","path":"技术之路/中间件/MQ/activemq/","text":"什么是 activeMQ？一个开源消息队列,使用 java 开发,属于 apache 基金会.官方网站:http://activemq.apache.org官方文档:http://activemq.apache.org/getting-started.html php 如何和 activeMQ 通信？采用 stomp 协议php 安装 stomp 的扩展 1pecl install stomp 采用第三方的类库:https://github.com/dejanb/stomp-php php 如何监控 activeMQ 中队列的状态？activeMQ 需要打开StatisticsPlugin方法:http://activemq.apache.org/statisticsplugin.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 获取指定队列的待处理消息数量 * * @param string $queue 待查询的队列名 * * @return mixed 成功返回待处理的消息数量 */function getMQStatus($queue)&#123; $result = $num = FALSE; $statusqueue = &quot;/queue/ActiveMQ.Statistics.Destination.&#123;$queue&#125;&quot;;//固定格式 //$statusqueue = &quot;/queue/ActiveMQ/Statistics/Destination/&#123;$queue&#125;&quot;;//固定格式 //开启ActiveMQ $link = stomp_connect(&apos;tcp://192.168.221.129:6161&apos;);//broker 的地址 if (!$link) &#123; die(&quot;Can&apos;t connect MQ !!&quot;); &#125; if (FALSE !== $link) &#123; //查询之后的结果存放处 $resultqueue = &quot;/queue/test_status_&#123;$queue&#125;&quot;; //设定采用JSON格式 stomp_subscribe($link, $resultqueue, array(&quot;transformation&quot; =&gt; &quot;jms-map-json&quot;)); //送出空字符串 $result = stomp_send($link, $statusqueue, &apos;&apos;, array(&quot;reply-to&quot; =&gt; $resultqueue)); if (FALSE === $result) &#123; echo &quot; send error&quot; . PHP_EOL; &#125; //取得状态 while (stomp_has_frame($link)) &#123; $frame = stomp_read_frame($link); if (FALSE != $frame) &#123; stomp_ack($link, $frame[&apos;headers&apos;][&apos;message-id&apos;]); $obj = json_decode($frame[&apos;body&apos;], TRUE);//$obj 包含队列的所有信息 //print_r($obj); //取得目前数量（尚可取得其他状态） foreach ($obj[&apos;map&apos;][&apos;entry&apos;] as $pitem) &#123; if (&apos;size&apos; == $pitem[&apos;string&apos;]) &#123; $num = $pitem[&apos;long&apos;]; break; &#125; &#125; &#125; &#125; stomp_unsubscribe($link, $resultqueue); stomp_close($link); &#125; return $num;&#125;$num = getMQStatus(&apos;spider&apos;);","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"activeMQ","slug":"activeMQ","permalink":"http://yoursite.com/tags/activeMQ/"}],"categories":[{"name":"技术之路","slug":"技术之路","permalink":"http://yoursite.com/categories/技术之路/"},{"name":"中间件","slug":"技术之路/中间件","permalink":"http://yoursite.com/categories/技术之路/中间件/"},{"name":"MQ","slug":"技术之路/中间件/MQ","permalink":"http://yoursite.com/categories/技术之路/中间件/MQ/"}]}]}