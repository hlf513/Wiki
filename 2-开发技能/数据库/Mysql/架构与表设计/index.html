<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title> 架构与表设计 | 贺龙飞的知识库</title>
    
    
        <meta name="keywords" content="mysql">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="数据表设计存储引擎 默认使用innodb 引擎，基本抛弃 myisam（只读也不一定比 innodb 快） text/blob 垂直拆分后，转成 myisam 表，innodb 存 blob 会产生大量的磁盘碎片  各存储引擎区别：存储引擎 字符集默认使用utf-8 注意字符集问题，server=&amp;gt;database(trigger、stored procedure、event schedul">
<meta name="keywords" content="mysql">
<meta property="og:type" content="article">
<meta property="og:title" content=" 架构与表设计">
<meta property="og:url" content="http://yoursite.com/2-开发技能/数据库/Mysql/架构与表设计/index.html">
<meta property="og:site_name" content="贺龙飞的知识库">
<meta property="og:description" content="数据表设计存储引擎 默认使用innodb 引擎，基本抛弃 myisam（只读也不一定比 innodb 快） text/blob 垂直拆分后，转成 myisam 表，innodb 存 blob 会产生大量的磁盘碎片  各存储引擎区别：存储引擎 字符集默认使用utf-8 注意字符集问题，server=&amp;gt;database(trigger、stored procedure、event schedul">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-03T16:04:44.532Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content=" 架构与表设计">
<meta name="twitter:description" content="数据表设计存储引擎 默认使用innodb 引擎，基本抛弃 myisam（只读也不一定比 innodb 快） text/blob 垂直拆分后，转成 myisam 表，innodb 存 blob 会产生大量的磁盘碎片  各存储引擎区别：存储引擎 字符集默认使用utf-8 注意字符集问题，server=&amp;gt;database(trigger、stored procedure、event schedul">
    

    
        <link rel="alternate" href="/atom.xml" title="贺龙飞的知识库" type="application/atom+xml">
    

    
        <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">贺龙飞的知识库</span>
            </a>
            <nav id="main-nav">
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            1-基础知识
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Linux
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/1-基础知识/Linux/源码编译说明/">源码编译说明</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据结构与算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/1-基础知识/数据结构与算法/概述/">概述</a></li>  <li class="file"><a href="/1-基础知识/数据结构与算法/线性表/">线性表</a></li>  <li class="file"><a href="/1-基础知识/数据结构与算法/栈/">栈</a></li>  <li class="file"><a href="/1-基础知识/数据结构与算法/队列/">队列</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            计算机网络
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/1-基础知识/计算机网络/http-协议/">Http 协议</a></li>  <li class="file"><a href="/1-基础知识/计算机网络/tcp-ip-协议/">TCP/IP 协议</a></li>  <li class="file"><a href="/1-基础知识/计算机网络/网络参考模型/">网络参考模型</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            2-开发技能
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            GIT
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/GIT/git-flow/">GitFlow</a></li>  <li class="file"><a href="/2-开发技能/GIT/git/">Git 常用命令</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            安全
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/安全/Web攻击手段/">WEB 攻击手段</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            数据库
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Mysql
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/数据库/Mysql/分析问题/">分析问题</a></li>  <li class="file"><a href="/2-开发技能/数据库/Mysql/基础知识/">基础知识</a></li>  <li class="file"><a href="/2-开发技能/数据库/Mysql/常用Sql/">常用SQL</a></li>  <li class="file"><a href="/2-开发技能/数据库/Mysql/常用函数/">常用函数</a></li>  <li class="file"><a href="/2-开发技能/数据库/Mysql/常见错误/">常见错误</a></li>  <li class="file"><a href="/2-开发技能/数据库/Mysql/性能优化/">性能优化</a></li>  <li class="file active"><a href="/2-开发技能/数据库/Mysql/架构与表设计/"> 架构与表设计</a></li>  <li class="file"><a href="/2-开发技能/数据库/Mysql/运维指南/">运维指南</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            权限控制
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/权限控制/rbac/">RBAC</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            测试
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/测试/codeception/">Codeception 之验收测试</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            程序语言
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            PHP
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            扩展
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/程序语言/PHP/扩展/openssl替换mcrypt/">Openssl替换mcrypt加解密</a></li>  <li class="file"><a href="/2-开发技能/程序语言/PHP/扩展/yar/">YAR</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            框架
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/程序语言/PHP/框架/lumen项目初始化/">Lumen项目初始化</a></li>  <li class="file"><a href="/2-开发技能/程序语言/PHP/框架/laravel项目初始化/">Laravel项目初始化</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/2-开发技能/程序语言/PHP/php-psr/">PHP 规范</a></li>  <li class="file"><a href="/2-开发技能/程序语言/PHP/编译安装/">编译安装</a></li>  <li class="file"><a href="/2-开发技能/程序语言/PHP/类库汇总/">类库汇总</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            面向对象
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2-开发技能/面向对象/oo-principle/">设计原则</a></li>  <li class="file"><a href="/2-开发技能/面向对象/uml/">UML</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            3-架构设计
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            中间件
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            MQ
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/3-架构设计/中间件/MQ/activemq/">ActiveMQ</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            架构设计
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/3-架构设计/架构设计/web-servive/">Web Servive</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            4-开源软件
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/4-开源软件/atom/">Atom 编辑器</a></li>  <li class="file"><a href="/4-开源软件/blog/">Blog 系统之 Hexo</a></li>  <li class="file"><a href="/4-开源软件/pandoc/">Pandoc</a></li>  <li class="file"><a href="/4-开源软件/wiki/">Wiki 系统之 Simiki</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            5-效率工具
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/5-效率工具/mac/">MAC 必备软件</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/index/">欢迎来到贺龙飞的知识库！</a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-2-开发技能/数据库/Mysql/架构与表设计" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/2-开发技能/">2-开发技能</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/2-开发技能/数据库/">数据库</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/2-开发技能/数据库/Mysql/">Mysql</a>
    </div>

                        
                            <div class="article-meta-button">
                                <a href="https://github.com/hlf513/wiki/commits/master/source/_posts/2-开发技能/数据库/Mysql/架构与表设计.md" rel="external nofollow noopener noreferrer" target="_blank"> History </a>
                            </div>
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
             架构与表设计
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据表设计"><span class="toc-text">数据表设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#存储引擎"><span class="toc-text">存储引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符集"><span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字段类型"><span class="toc-text">字段类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原则"><span class="toc-text">基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储技巧"><span class="toc-text">存储技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引"><span class="toc-text">索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高级特性使用"><span class="toc-text">高级特性使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存与数据库结合"><span class="toc-text">缓存与数据库结合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读取"><span class="toc-text">读取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点"><span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用？"><span class="toc-text">如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何确定热点数据"><span class="toc-text">如何确定热点数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写入"><span class="toc-text">写入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点-1"><span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用"><span class="toc-text">如何使用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步更新风险"><span class="toc-text">异步更新风险</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反范式设计（冗余）"><span class="toc-text">反范式设计（冗余）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#反范式设计的概念"><span class="toc-text">反范式设计的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冗余结构设计所面临的典型场景"><span class="toc-text">冗余结构设计所面临的典型场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冗余造成的问题"><span class="toc-text">冗余造成的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冗余设计方案"><span class="toc-text">冗余设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于展现的冗余设计"><span class="toc-text">基于展现的冗余设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于查询的冗余设计"><span class="toc-text">基于查询的冗余设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于统计的冗余结构"><span class="toc-text">基于统计的冗余结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于-io-压力优化的冗余"><span class="toc-text">基于 io 压力优化的冗余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#历史数据表"><span class="toc-text">历史数据表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#主从架构"><span class="toc-text">主从架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本认识"><span class="toc-text">基本认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优点"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局限性"><span class="toc-text">局限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#潜在优化点"><span class="toc-text">潜在优化点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式设计"><span class="toc-text">分布式设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#目标"><span class="toc-text">目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#防止单点隐患"><span class="toc-text">防止单点隐患</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方便系统扩容"><span class="toc-text">方便系统扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全可控，成本可控"><span class="toc-text">安全可控，成本可控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分库-amp-分表"><span class="toc-text">分库&amp;分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点-1"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局限性-1"><span class="toc-text">局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#推荐方案"><span class="toc-text">推荐方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本认识-1"><span class="toc-text">基本认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#去关联化原则"><span class="toc-text">去关联化原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分库方案"><span class="toc-text">分库方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安全性拆分"><span class="toc-text">安全性拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于业务逻辑拆分"><span class="toc-text">基于业务逻辑拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于负载压力拆分"><span class="toc-text">基于负载压力拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#混合拆分组合"><span class="toc-text">混合拆分组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分表方案"><span class="toc-text">分表方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#纵向分表（常见为忙闲分表）"><span class="toc-text">纵向分表（常见为忙闲分表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#横向切表"><span class="toc-text">横向切表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#热点数据分表"><span class="toc-text">热点数据分表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
                </div>
            
        
        
            <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ol>
<li><strong>默认使用innodb 引擎</strong>，基本抛弃 myisam（只读也不一定比 innodb 快）</li>
<li><strong>text/blob 垂直拆分后，转成 myisam 表</strong>，innodb 存 blob 会产生大量的磁盘碎片</li>
</ol>
<p>各存储引擎区别：<a href="/技术之路/数据库/Mysql/基础知识/#数据引擎">存储引擎</a></p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><strong>默认使用utf-8</strong></p>
<p>注意字符集问题，server=&gt;database(trigger、stored procedure、event scheduler)=&gt;table=&gt;column<br>不要同时指定字符集（character set）和校验集（collect set），避免出现和默认对应关系不一致</p>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol>
<li>越小越好</li>
<li>字段都NOT NULL<ul>
<li>默认都加上NOT NULL约束，必须为NULL用0表示</li>
<li>在对该字段进行COUNT(*)统计时，统计结果更准确（值为NULL的不会被COUNT统计进去）</li>
</ul>
</li>
</ol>
<h3 id="存储技巧"><a href="#存储技巧" class="headerlink" title="存储技巧"></a>存储技巧</h3><ol>
<li><p><strong>可使用枚举类型</strong><br>ENUM的内部存储机制是采用TINYINT或SMALLINT（并非CHAR/VARCHAR），性能一点都不差</p>
</li>
<li><p><strong>存储ipv4地址</strong><br>用INT UNSIGNED存储IPV4地址，用INET_ATON()、INET_NTOA()进行转换</p>
</li>
<li><p><strong>存储日期时间</strong><br><strong>一个常识性误导：建议用TIMESTAMP取代DATETIME。</strong><br>从5.6开始，建议优先选择DATETIME存储日期时间。因为它的可用范围比TIMESTAMP更大，物理存储上仅比TIMESTAMP多1个字节，整体性能上的损失并不大。</p>
</li>
<li><p><strong>InnoDB表行记录物理长度不超过8KB</strong><br><strong>InnoDB的data page默认是16KB的情况下。</strong><br>当实际存储长度超过8KB（尤其有TEXT/BLOB列）且读写频繁的话, 则最好把这些列拆分到子表中，不要和主表放在一起存储。如果不太频繁，可以考虑继续保留在主表中<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率">[1]</span></a></sup>。</p>
</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol>
<li>显式指定自增 int/bigint unsigned not null 作为主键(有主键 TPS 提升9%，不要使用 uuid，性能差)</li>
<li>选择适当的索引顺序，选择性高条件靠前</li>
<li>基数（ Cardinality ）很低（30%以下）的字段不创建索引（MySQL还不支持 bitmap 索引）</li>
<li>常用排序（ORDER BY）、分组（GROUP BY）、取唯一（DISTINCT）字段上创建索引</li>
<li>单表索引数量不超过5个</li>
<li>不使用外键</li>
<li>超过20个长度的字符串列（不需要排序），创建前缀索引而非整列索引<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="例如：`ALTER TABLE t1 ADD INDEX(user(20))`
前缀索引的长度可以基于对该字段的统计得出，一般略大于平均长度一点就可以了。">[6]</span></a></sup><ul>
<li>优点:有效提高索引利用率</li>
<li>缺点:对这个列排序时用不到前缀索引</li>
</ul>
</li>
</ol>
<h2 id="高级特性使用"><a href="#高级特性使用" class="headerlink" title="高级特性使用"></a>高级特性使用</h2><ol>
<li><p><strong>是否使用分区表？</strong><br>在可以提升性能或者运维便利性的场景下，还是建议使用分区表。例如：日志系统，按时间纬度进行分区，方便删除历史数据</p>
</li>
<li><p><strong>是否使用存储过程、触发器？</strong><br>单机可用，分布式舍弃。（存储器场景：不变的业务逻辑）</p>
</li>
<li><p><strong>是否使用视图？</strong><br>MySQL因为没有物化视图，因此视图尽量少用（不用）</p>
</li>
</ol>
<h1 id="缓存与数据库结合"><a href="#缓存与数据库结合" class="headerlink" title="缓存与数据库结合"></a>缓存与数据库结合</h1><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以减少数据库读取请求<br>缺点：增加代码复杂度、增加维护难度</p>
<h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul>
<li>评估进入缓存的数据规模，以及命中率优化<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实景分析： 前端请求先连接缓存，缓存未命中连接数据库，进行查询，未命中状态比单纯连接数据库查询多了一次连接和查询的操作；如果缓存命中率很低，则这个额外的操作非但不能提高查询效率，反而为系统带来了额外的负载和复杂性，得不偿失。">[2]</span></a></sup><ul>
<li>不是所有数据都适合被缓存，也并不是进入了缓存就意味着效率提升</li>
<li>命中率是第一要评估的数据；<strong>核心在于如何判断哪些属于热点数据</strong></li>
</ul>
</li>
<li>善于利用内存，请注意数据存储的格式及压缩算法。</li>
</ul>
<h3 id="如何确定热点数据"><a href="#如何确定热点数据" class="headerlink" title="如何确定热点数据"></a>如何确定热点数据</h3><p>见<a href="#热点数据分表">下文</a></p>
<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：减少数据库写入<code>i/o</code>压力<br>缺点：数据不能第一时间持久化，有丢失风险</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h3><p>缓存实时更新，数据库异步更新（使用队列,请注意使用<code>increment</code>来维持队列序号）</p>
<ul>
<li>不要通过<code>get-&gt;处理数据-&gt;set-&gt;更新数据</code>的方式维护队列<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例:
`$var=Memcache_get($memcon,”var”);$var++;memcache_set($memcon,”var”,$var);`
这样一个脚本，使用apache ab去跑，100个并发，跑10000次，然后输出缓存存取的数据，很遗憾，并不是1000，而是5000多，6000多这样的数字，中间的数字全在 get & set的过程中丢掉了。原因：读写间隔中其他并发写入，导致数据丢失。">[3]</span></a></sup>。 使用<code>increment</code>存储队列编号，用标记+编号作为<code>key</code>存储队列内容<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例2:
用memcache_increment来做这个操作，同样跑测试会得到完整的10000，一条数据不会丢。">[4]</span></a></sup>。</li>
<li>后台基于缓存队列读取更新数据并更新数据库<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：
某论坛热门贴，前端不断有views=views+1数据更新请求。
缓存实时更新该状态
后台任务对数据库做异步更新时，假设执行周期是5分钟，那么五分钟可能会接收到这样的请求多达数十次乃至数百次，合并更新后只执行一次update即可。
类似操作还包括游戏打怪，生命和经验的变化；个人主页访问次数的变化等。">[5]</span></a></sup><ul>
<li>基于队列读取后可以合并更新</li>
<li><strong>更新合并率</strong>是重要指标</li>
</ul>
</li>
</ul>
<h3 id="异步更新风险"><a href="#异步更新风险" class="headerlink" title="异步更新风险"></a>异步更新风险</h3><ul>
<li><strong>前后端同时写，可能导致覆盖风险。</strong><ul>
<li>使用后端异步更新，前端应用程序不要写数据库，否则可能造成写入冲突。</li>
<li>一种兼容的解决方案是，前端和后端不要写相同的字段<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：
用户在线上时，后台异步更新用户状态。管理员后台屏蔽用户是直接更新数据库。结果管理员屏蔽某用户操作完成后，因该用户在线有操作，后台异步更新程序再次基于缓存更新用户状态，用户状态被复活，屏蔽失效。">[7]</span></a></sup>。</li>
</ul>
</li>
<li><strong>缓存数据丢失或服务崩溃可能导致数据丢失风险。</strong><ul>
<li>如缓存中间出现故障，则缓存队列数据不会回写到数据库，而用户会认为已经完成，此时会带来比较明显的用户体验问题。</li>
<li>一个不彻底的解决方案是，确保高安全性，高重要性数据实时数据更新，而低安全性数据通过缓存异步回写方式完成。此外，使用相对数值操作而不是绝对数值操作更安全<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例：支付信息，道具的购买与获得，一旦丢失会对用户造成极大的伤害。而经验值，访问数字，如果只丢失了很少时间的内容，用户还是可以容忍的。
">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例：如果使用 `Views=Views+…`的操作，一旦出现数据格式错误，从binlog中反推是可以进行数据还原，但是如果使用Views=特定值的操作，一旦缓存中数据有错误，则直接被赋予了一个错误数据，无法回溯！">[9]</span></a></sup>。</li>
</ul>
</li>
<li><strong>异步更新如出现队列阻塞可能导致数据丢失风险。</strong><ul>
<li>异步更新通常是使用缓存队列后，在后台由cron或其他守护进程写入数据库。</li>
<li>如果队列生成的速度&gt;后台更新写入数据库的速度，就会产生阻塞，导致数据越累计越多，数据库响应迟缓，而缓存队列无法迅速执行，导致溢出或者过期失效。</li>
<li>解决办法：使用 MQ 队列产品而不使用 memcache 来进行缓存异步更新</li>
</ul>
</li>
</ul>
<h1 id="反范式设计（冗余）"><a href="#反范式设计（冗余）" class="headerlink" title="反范式设计（冗余）"></a>反范式设计（冗余）</h1><ul>
<li>适度冗余可以减少查询请求</li>
<li>适度冗余可以解决分表带来的索引查询问题</li>
<li>适度冗余可以解决统计类负载较高的查询问题</li>
<li>适度冗余可以减少 io 请求频次，提高 io 支撑能力(cpu 换 io)</li>
</ul>
<h2 id="反范式设计的概念"><a href="#反范式设计的概念" class="headerlink" title="反范式设计的概念"></a>反范式设计的概念</h2><ul>
<li>无外键，无连表查询，强调索引,去关联化</li>
<li>不考虑触发器及其他内部的存储过程</li>
<li>便于分布式设计，允许适度冗余，为了容量扩展允许适度开销。</li>
<li>基于业务自由优化，基于i/o 或查询设计，无须遵循范式结构设计。</li>
</ul>
<h2 id="冗余结构设计所面临的典型场景"><a href="#冗余结构设计所面临的典型场景" class="headerlink" title="冗余结构设计所面临的典型场景"></a>冗余结构设计所面临的典型场景</h2><ul>
<li>原有展现程序涉及多个表的查询，希望精简查询程序</li>
<li>数据表拆分往往基于主键，而原有数据表往往存在非基于主键的关键查询，无法在分表结构中完成。</li>
<li>存在较多数据统计需求（count, sum等），效率低下。</li>
</ul>
<h2 id="冗余造成的问题"><a href="#冗余造成的问题" class="headerlink" title="冗余造成的问题"></a>冗余造成的问题</h2><p>一致性问题–业务层校验</p>
<h2 id="冗余设计方案"><a href="#冗余设计方案" class="headerlink" title="冗余设计方案"></a>冗余设计方案</h2><h3 id="基于展现的冗余设计"><a href="#基于展现的冗余设计" class="headerlink" title="基于展现的冗余设计"></a>基于展现的冗余设计</h3><p>冗余特征：字段简单，更改度不高<br>为了简化展现程序，在一些数据表中往往存在冗余字段<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：
论坛板块的发帖量，回帖量，每日新增数据等。
网站每日新增用户数等。
参见Discuz论坛系统数据结构，有较多相关结构。
参见前文分段积分结构，是典型用于统计的冗余结构。
后台可以通过源数据表更新该数字。
Redis的Zset类型可以理解为存在一种冗余统计结构。">[13]</span></a></sup></p>
<h3 id="基于查询的冗余设计"><a href="#基于查询的冗余设计" class="headerlink" title="基于查询的冗余设计"></a>基于查询的冗余设计</h3><ul>
<li>涉及分表操作后，一些常见的索引查询可能需要跨表，带来不必要的麻烦。确认查询请求远大于写入请求时，应设置便于查询项的冗余表。</li>
<li>冗余表要点<ul>
<li>数据一致性，简单说：同增，同删，同更新。</li>
<li>可以做全冗余，或者只做主键关联的冗余，比如通过用户名查询uid，再基于uid查询源表。</li>
</ul>
</li>
</ul>
<p>实战示例<sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例1: 用户分表
将用户库分成若干数据表;基于用户名的查询和基于uid的查询都是高并发请求。
用户分表基于uid分成数据表，同时基于用户名做对应冗余表。
如果允许多方式登陆，可以有如下设计方法：
`uid,passwd,用户信息等等，主数据表，基于uid分表`
`ukey,ukeytype,uid 基于ukey分表，便于用户登陆的查询。分解成如下两个SQL:`
`select uid from ulist_key_13 where ukey=’$username’ and ukeytype=‘login’;`
`select * from ulist_uid_23 where uid=$uid and passwd=’$passwd’;`
`ukeytype定义用户的登陆依据，比如用户名，手机号，邮件地址，网站昵称等。 Ukey+ukeytype 必须唯一`
`此种方式需要登陆密码统一，对于第三方connect接入模式，可以通过引申额外字段完成`">[10]</span></a></sup><sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例2：用户游戏积分排名
表结构 uid,gameid,score 参见前文实时积分排行。表内容巨大，需要拆表。
需求1：基于游戏id查询积分排行
需求2：基于用户id查询游戏积分记录
解决方案：建立完全相同的两套表结构，其一以uid为拆表主键，其二以gameid为拆表主键，用户提交积分时，向两个数据结构同时提交。">[11]</span></a></sup><sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例3：全冗余查询结构
主信息表仅包括 主键及备注memo字段（text类型），只支持主键查询，可以基于主键拆表。所以需要展现和存储的内容均在memo字段重体现。
对每一个查询条件，建立查询冗余表，以查询条件字段为主键，以主信息表主键id 为内容。
日常查询只基于查询冗余表，然后通过in的方式从主信息表获得内容。
优点是结构扩展非常方便，只需要扩展新的查询信息表即可，核心思路是，只有查询才需要独立的索引结构，展现无需独立字段。
缺点是只适合于相对固定的查询架构，对于更加灵活的组合查询束手无策。">[12]</span></a></sup></p>
<h3 id="基于统计的冗余结构"><a href="#基于统计的冗余结构" class="headerlink" title="基于统计的冗余结构"></a>基于统计的冗余结构</h3><ul>
<li>为了减少会涉及大规模影响结果集的表数据操作，比如count，sum操作。应将一些统计类数据通过冗余数据结构保存。</li>
<li>冗余数据结构可能以字段方式存在，也可能以独立数据表结构存在，但是都应能通过源数据表恢复。</li>
</ul>
<p>实战示例<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：
论坛板块的发帖量，回帖量，每日新增数据等。
网站每日新增用户数等。
参见Discuz论坛系统数据结构，有较多相关结构。
参见前文分段积分结构，是典型用于统计的冗余结构。
后台可以通过源数据表更新该数字。
Redis的Zset类型可以理解为存在一种冗余统计结构。">[13]</span></a></sup></p>
<h3 id="基于-io-压力优化的冗余"><a href="#基于-io-压力优化的冗余" class="headerlink" title="基于 io 压力优化的冗余"></a>基于 io 压力优化的冗余</h3><p><strong>现象：</strong></p>
<p>单次请求多次写入的情况</p>
<ul>
<li>请求频次较高，io 压力较大</li>
<li>存在高频读取请求，数据可靠性要求高</li>
</ul>
<p><strong>可用方案:</strong></p>
<ul>
<li>数据压缩存储</li>
<li>写入缓存队列</li>
<li>通过冗余结构，合并为一次写入<sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="游戏组队，5个武将。（建立临时的武将表，定时更新到主表）
">[14]</span></a></sup><sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实时统计">[15]</span></a></sup></li>
</ul>
<h3 id="历史数据表"><a href="#历史数据表" class="headerlink" title="历史数据表"></a>历史数据表</h3><p>历史数据表对应于热点数据表，将需求较少又不能丢弃的数据存入，仅在少数情况下被访问。</p>
<h1 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h1><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul>
<li>读写分离对负载的减轻远远不如分库分表来的直接。</li>
<li>写压力会传递给从表，只读从库一样有写压力，一样会产生读写锁！</li>
<li>一主多从结构下，主库是单点隐患，很难解决（如主库当机，从库可以响应读写，但是无法自动担当主库的分发功能）</li>
<li>主从延迟也是重大问题。一旦有较大写入问题，如表结构更新，主从会产生巨大延迟。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>部署简单</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul>
<li>io 压力无法分布，性价比不高（主是多线程写，从是单线程写；分担读压力，不能分担写压力）</li>
<li>同步延时避免不了</li>
<li>一主多从，主库单点，很难自动故障转移（一从转主，其他从不能自动关联到这个新主）</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一主一从</p>
<ul>
<li>在线热备</li>
<li>异地分布<ul>
<li>写分布，读统一。</li>
<li>仍然困难重重，受限于网络环境问题巨多！</li>
</ul>
</li>
<li>自动障碍转移<ul>
<li>主崩溃，从自动接管</li>
</ul>
</li>
<li>个人建议，负载均衡主要使用分库方案，主从主要用于热备和障碍转移。</li>
</ul>
<h2 id="潜在优化点"><a href="#潜在优化点" class="headerlink" title="潜在优化点"></a>潜在优化点</h2><p>为了减少写压力，有些人建议主不建索引提升i/o性能，从建立索引满足查询要求。个人认为这样维护较为麻烦。而且从本身会继承主的i/o压力，因此优化价值有限。该思路特此分享，不做推荐(caoz观点)。</p>
<h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><ul>
<li>设计分布式之前，先优化单机：</li>
<li>单机读 qps 几千很容易</li>
<li>单机写 qps 几千很容易</li>
<li>数据量最少在3000万以上（具体业务具体分析）</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="防止单点隐患"><a href="#防止单点隐患" class="headerlink" title="防止单点隐患"></a>防止单点隐患</h3><p><strong>lvs nginx（轮询，自动切换）</strong></p>
<ul>
<li>所谓单点隐患，就是某台设备出现故障，会导致整体系统的不可用，这个设备就是单点隐患。</li>
<li>理解连带效应，所谓连带效应，就是一种问题会引发另一种故障，举例而言，memcache+mysql是一种常见缓存组合，在前端压力很大时，如果memcache崩溃，理论上数据会通过mysql读取，不存在系统不可用情况，但是mysql无法对抗如此大的压力冲击，会因此连带崩溃。因A系统问题导致B系统崩溃的连带问题，在运维过程中会频繁出现。<sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例： 在mysql连接不及时释放的应用环境里，当网络环境异常（同机房友邻服务器遭受拒绝服务攻击，出口阻塞），网络延迟加剧，空连接数急剧增加，导致数据库连接过多崩溃。
">[16]</span></a></sup><sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：前端代码 通常我们封装 mysql_connect和memcache_connect，二者的顺序不同，会产生不同的连带效应。如果mysql_connect在前，那么一旦memcache连接阻塞，会连带mysql空连接过多崩溃。">[17]</span></a></sup><ul>
<li>连带效应是常见的系统崩溃，日常分析崩溃原因的时候需要认真考虑连带效应的影响，头疼医头，脚疼医脚是不行的。</li>
</ul>
</li>
</ul>
<h3 id="方便系统扩容"><a href="#方便系统扩容" class="headerlink" title="方便系统扩容"></a>方便系统扩容</h3><ul>
<li>数据容量增加后，要考虑能够将数据分布到不同的服务器上。</li>
<li>请求压力增加时，要考虑将请求压力分布到不同服务器上。</li>
<li>扩容设计时需要考虑防止单点隐患。</li>
</ul>
<h3 id="安全可控，成本可控"><a href="#安全可控，成本可控" class="headerlink" title="安全可控，成本可控"></a>安全可控，成本可控</h3><ul>
<li>数据安全，业务安全</li>
<li>人力资源成本 &gt; 带宽流量成本 &gt; 硬件成本<ul>
<li>成本与流量的关系曲线应低于线性增长（流量为横轴，成本为纵轴）。</li>
<li>规模优势</li>
</ul>
</li>
</ul>
<h2 id="分库-amp-分表"><a href="#分库-amp-分表" class="headerlink" title="分库&amp;分表"></a>分库&amp;分表</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>负载分担较好</li>
<li>不存在同步延迟</li>
<li>拆分方法灵活</li>
</ul>
<h3 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li>需要有备份和自动故障转移的方案</li>
<li>需要应用端配合，无法完全满足关联查询的需求</li>
</ul>
<h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><ul>
<li>以分库、分表为负载和数据支撑方案</li>
<li>以主从结构为热备和故障转移方案</li>
<li>使用中间件作为分布式数据库的前端（amoeba，要去关联化）</li>
<li>数据一致性问题解决<ul>
<li>前端校验</li>
<li>后端 cron 定时跑数据</li>
</ul>
</li>
</ul>
<h3 id="基本认识-1"><a href="#基本认识-1" class="headerlink" title="基本认识"></a>基本认识</h3><ul>
<li>用分库&amp;拆表是解决数据库容量问题的唯一途径。</li>
<li>分库&amp;拆表也是解决性能压力的最优选择。</li>
<li>分库 – 不同的数据表放到不同的数据库服务器中（也可能是虚拟服务器）</li>
<li>拆表 – 一张数据表拆成多张数据表，可能位于同一台服务器，也可能位于多台服务器（含虚拟服务器）。</li>
</ul>
<h3 id="去关联化原则"><a href="#去关联化原则" class="headerlink" title="去关联化原则"></a>去关联化原则</h3><ul>
<li>摘除数据表之间的关联，是分库的基础工作。</li>
<li>摘除关联的目的是，当数据表分布到不同服务器时，查询请求容易分发和处理。</li>
<li>学会理解反范式数据结构设计，所谓反范式，第一要点是不用外键，不允许Join操作，不允许任何需要跨越两个表的查询请求。第二要点是适度冗余减少查询请求<sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="比如说，信息表，fromuid, touid, message字段外，还需要一个fromuname字段记录用户名，这样查询者通过touid查询后，能够立即得到发信人的用户名，而无需进行另一个数据表的查询。">[18]</span></a></sup></li>
<li>去关联化处理会带来额外的考虑，比如说，某一个数据表内容的修改，对另一个数据表的影响。这一点需要在程序或其他途径去考虑。</li>
</ul>
<h3 id="分库方案"><a href="#分库方案" class="headerlink" title="分库方案"></a>分库方案</h3><h4 id="安全性拆分"><a href="#安全性拆分" class="headerlink" title="安全性拆分"></a>安全性拆分</h4><p>运维优化，易于管理</p>
<ul>
<li>将高安全性数据与低安全性数据分库，这样的好处第一是便于维护，第二是高安全性数据的数据库参数配置可以以安全优先，而低安全性数据的参数配置以性能优先。参见运维优化相关部分。</li>
<li>安全性开启参数：sync_binlog，innodb_flush_log_at_trx_commit = 2(丢失最后1s 数据);开启后性能下降10~100倍</li>
</ul>
<h4 id="基于业务逻辑拆分"><a href="#基于业务逻辑拆分" class="headerlink" title="基于业务逻辑拆分"></a>基于业务逻辑拆分</h4><p>易于管理，对应用端友好，负载不能均分</p>
<ul>
<li>根据数据表的内容构成，业务逻辑拆分，便于日常维护和前端调用。</li>
<li>基于业务逻辑拆分，可以减少前端应用请求发送到不同数据库服务器的频次，从而减少链接开销。</li>
<li>基于业务逻辑拆分，可保留部分数据关联，前端web工程师可在限度范围内执行关联查询。</li>
</ul>
<h4 id="基于负载压力拆分"><a href="#基于负载压力拆分" class="headerlink" title="基于负载压力拆分"></a>基于负载压力拆分</h4><p>负载相对可以均摊；管理不方便</p>
<ul>
<li>基于负载压力对数据结构拆分，便于直接将负载分担给不同的服务器。</li>
<li>基于负载压力拆分，可能拆分后的数据库包含不同业务类型的数据表，日常维护会有一定的烦恼。</li>
</ul>
<h4 id="混合拆分组合"><a href="#混合拆分组合" class="headerlink" title="混合拆分组合"></a>混合拆分组合</h4><ul>
<li>基于安全与业务拆分为数据库实例，但是可以使用不同端口放在同一个服务器上。</li>
<li>基于负载可以拆分为更多数据库实例分布在不同数据库上</li>
</ul>
<p>例如:</p>
<ul>
<li>基于安全拆分出A数据库实例，</li>
<li>基于业务拆分出B,C数据库实例，</li>
<li>C数据库存在较高负载，基于负载拆分为C1,C2,C3,C4等 实例。</li>
<li>数据库服务器完全可以做到 A+B+C1为一台，C2,C3,C4各单独一台。</li>
</ul>
<h3 id="分表方案"><a href="#分表方案" class="headerlink" title="分表方案"></a>分表方案</h3><p>数据量过大或者访问压力过大的数据表需要切分</p>
<h4 id="纵向分表（常见为忙闲分表）"><a href="#纵向分表（常见为忙闲分表）" class="headerlink" title="纵向分表（常见为忙闲分表）"></a>纵向分表（常见为忙闲分表）</h4><ul>
<li>单数据表字段过多，可将频繁更新的整数数据与非频繁更新的字符串数据切分<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例: user表 ，个人简介，地址，QQ号，联系方式，头像 这些字段为字符串类型，更新请求少； 最后登录时间，在线时常，访问次数，信件数这些字段为整数型字段，更新频繁，可以将后面这些更新频繁的字段独立拆出一张数据表，表内容变少，索引结构变少，读写请求变快。">[19]</span></a></sup></li>
<li>过于频繁的，使用 nosql（memcached，redis 等）</li>
</ul>
<h4 id="横向切表"><a href="#横向切表" class="headerlink" title="横向切表"></a>横向切表</h4><ul>
<li>等分切表，如哈希切表或其他基于对某数字取余的切表。等分切表的优点是负载均分；缺点是当容量继续增加时无法方便的扩容，需要重新进行数据的切分或转表。而且一些关键主键不易处理。（只能基于差存条件进行拆分，否则没法查询）</li>
<li>递增切表，比如每1kw用户开一个新表，优点是可以适应数据的自增趋势；缺点是往往新数据负载高（最新的表），压力分配不平均。</li>
<li>日期切表，适用于日志记录式数据，优缺点等同于递增切表。</li>
<li>个人倾向于递增切表，具体根据应用场景决定。</li>
</ul>
<h4 id="热点数据分表"><a href="#热点数据分表" class="headerlink" title="热点数据分表"></a>热点数据分表</h4><p>将数据量较大的数据表中将读写频繁的数据抽取出来，形成热点数据表。通常一个庞大数据表经常被读写的内容往往具有一定的集中性，如果这些集中数据单独处理，就会极大减少整体系统的负载。</p>
<p><strong>热点数据表与旧有数据关系:</strong></p>
<ul>
<li>可以是一张冗余表，即该表数据丢失不会妨碍使用，因源数据仍存在于旧有结构中。优点是安全性高，维护方便，缺点是写压力不能分担，仍需要同步写回原系统。</li>
<li>可以是非冗余表，即热点数据的内容原有结构不再保存，优点是读写效率全部优化；缺点是当热点数据发生变化时，维护量较大。</li>
<li>具体方案选择需要根据读写比例决定，在读频率远高于写频率情况下，优先考虑冗余表方案。</li>
</ul>
<p><strong>数据存储：</strong><br>热点数据表可以用单独的优化的硬件存储，比如昂贵的闪存卡或大内存系统。</p>
<p><strong>热点数据表的重要指标:</strong></p>
<ul>
<li>热点数据的定义需要根据业务模式自行制定策略，常见策略为，按照最新的操作时间；按照内容丰富度等等。</li>
<li>数据规模，比如从1000万条数据，抽取出100万条热点数据。</li>
<li>热点命中率，比如查询10次，多少次命中在热点数据内。</li>
<li>理论上，数据规模越小，热点命中率越高，说明效果越好。需要根据业务自行评估。</li>
</ul>
<p><strong>热点数据表的动态维护:</strong></p>
<ul>
<li>加载热点数据方案选择<ul>
<li>定时从旧有数据结构中按照新的策略获取</li>
<li>在从旧有数据结构读取时动态加载到热点数据</li>
</ul>
</li>
<li>剔除热点数据方案选择<ul>
<li>基于特定策略，定时将热点数据中访问频次较少的数据剔除</li>
<li>如热点数据是冗余表，则直接删除即可，如不是冗余表，需要回写给旧有数据结构。</li>
</ul>
</li>
</ul>
<p>通常，热点数据往往是基于缓存或者key-value方案冗余存储，所以这里提到的热点数据表，其实更多是理解思路，用到的场合可能并不多。（适合组合条件场景，数据规模中等，像淘宝的数据量就需要第三方搜索引擎）</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://imysql.com/2014/09/28/mysql-optimization-case-blob-stored-in-innodb-optimization.shtml" rel="external nofollow noopener noreferrer" target="_blank">[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率</a></li>
<li>《Mysql 性能优化教程-曹政》</li>
</ul>
<!--以下是脚注-->
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实景分析： 前端请求先连接缓存，缓存未命中连接数据库，进行查询，未命中状态比单纯连接数据库查询多了一次连接和查询的操作；如果缓存命中率很低，则这个额外的操作非但不能提高查询效率，反而为系统带来了额外的负载和复杂性，得不偿失。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例:<br><code>$var=Memcache_get($memcon,”var”);$var++;memcache_set($memcon,”var”,$var);</code><br>这样一个脚本，使用apache ab去跑，100个并发，跑10000次，然后输出缓存存取的数据，很遗憾，并不是1000，而是5000多，6000多这样的数字，中间的数字全在 get &amp; set的过程中丢掉了。原因：读写间隔中其他并发写入，导致数据丢失。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例2:<br>用memcache_increment来做这个操作，同样跑测试会得到完整的10000，一条数据不会丢。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>某论坛热门贴，前端不断有views=views+1数据更新请求。<br>缓存实时更新该状态<br>后台任务对数据库做异步更新时，假设执行周期是5分钟，那么五分钟可能会接收到这样的请求多达数十次乃至数百次，合并更新后只执行一次update即可。<br>类似操作还包括游戏打怪，生命和经验的变化；个人主页访问次数的变化等。<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">例如：<code>ALTER TABLE t1 ADD INDEX(user(20))</code><br>前缀索引的长度可以基于对该字段的统计得出，一般略大于平均长度一点就可以了。<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>用户在线上时，后台异步更新用户状态。管理员后台屏蔽用户是直接更新数据库。结果管理员屏蔽某用户操作完成后，因该用户在线有操作，后台异步更新程序再次基于缓存更新用户状态，用户状态被复活，屏蔽失效。<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例：支付信息，道具的购买与获得，一旦丢失会对用户造成极大的伤害。而经验值，访问数字，如果只丢失了很少时间的内容，用户还是可以容忍的。<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例：如果使用 <code>Views=Views+…</code>的操作，一旦出现数据格式错误，从binlog中反推是可以进行数据还原，但是如果使用Views=特定值的操作，一旦缓存中数据有错误，则直接被赋予了一个错误数据，无法回溯！<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例1: 用户分表<br>将用户库分成若干数据表;基于用户名的查询和基于uid的查询都是高并发请求。<br>用户分表基于uid分成数据表，同时基于用户名做对应冗余表。<br>如果允许多方式登陆，可以有如下设计方法：<br><code>uid,passwd,用户信息等等，主数据表，基于uid分表</code><br><code>ukey,ukeytype,uid 基于ukey分表，便于用户登陆的查询。分解成如下两个SQL:</code><br><code>select uid from ulist_key_13 where ukey=’$username’ and ukeytype=‘login’;</code><br><code>select <em> from ulist_uid_23 where uid=$uid and passwd=’$passwd’;</em></code><br><code>ukeytype定义用户的登陆依据，比如用户名，手机号，邮件地址，网站昵称等。 Ukey+ukeytype 必须唯一</code><br><code>此种方式需要登陆密码统一，对于第三方connect接入模式，可以通过引申额外字段完成</code><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例2：用户游戏积分排名<br>表结构 uid,gameid,score 参见前文实时积分排行。表内容巨大，需要拆表。<br>需求1：基于游戏id查询积分排行<br>需求2：基于用户id查询游戏积分记录<br>解决方案：建立完全相同的两套表结构，其一以uid为拆表主键，其二以gameid为拆表主键，用户提交积分时，向两个数据结构同时提交。<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例3：全冗余查询结构<br>主信息表仅包括 主键及备注memo字段（text类型），只支持主键查询，可以基于主键拆表。所以需要展现和存储的内容均在memo字段重体现。<br>对每一个查询条件，建立查询冗余表，以查询条件字段为主键，以主信息表主键id 为内容。<br>日常查询只基于查询冗余表，然后通过in的方式从主信息表获得内容。<br>优点是结构扩展非常方便，只需要扩展新的查询信息表即可，核心思路是，只有查询才需要独立的索引结构，展现无需独立字段。<br>缺点是只适合于相对固定的查询架构，对于更加灵活的组合查询束手无策。<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">举例，信息表 message，存在字段 fromuid,touid,msg,sendtime 四个字段，其中 touid+sendtime是复合索引。存在查询为 select  from message where touid=$uid order by sendtime desc limit 0,30;<br>展示程序需要显示发送者姓名，此时通常会在message表中增加字段fromusername，甚至有的会增加fromusersex，从而无需连表查询直接输出信息的发送者姓名和性别。这就是一种简单的，为了避免连表查询而使用的冗余字段设计。<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>论坛板块的发帖量，回帖量，每日新增数据等。<br>网站每日新增用户数等。<br>参见Discuz论坛系统数据结构，有较多相关结构。<br>参见前文分段积分结构，是典型用于统计的冗余结构。<br>后台可以通过源数据表更新该数字。<br>Redis的Zset类型可以理解为存在一种冗余统计结构。<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">游戏组队，5个武将。（建立临时的武将表，定时更新到主表）<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实时统计<a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例： 在mysql连接不及时释放的应用环境里，当网络环境异常（同机房友邻服务器遭受拒绝服务攻击，出口阻塞），网络延迟加剧，空连接数急剧增加，导致数据库连接过多崩溃。<a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：前端代码 通常我们封装 mysql_connect和memcache_connect，二者的顺序不同，会产生不同的连带效应。如果mysql_connect在前，那么一旦memcache连接阻塞，会连带mysql空连接过多崩溃。<a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">比如说，信息表，fromuid, touid, message字段外，还需要一个fromuname字段记录用户名，这样查询者通过touid查询后，能够立即得到发信人的用户名，而无需进行另一个数据表的查询。<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例: user表 ，个人简介，地址，QQ号，联系方式，头像 这些字段为字符串类型，更新请求少； 最后登录时间，在线时常，访问次数，信件数这些字段为整数型字段，更新频繁，可以将后面这些更新频繁的字段独立拆出一张数据表，表内容变少，索引结构变少，读写请求变快。<a href="#fnref:19" rev="footnote"> ↩</a></span></li></ol></div></div>
            </div>
        
        <footer class="article-footer">
          <div style="float:left">
            
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/mysql/">mysql</a>
    </div>

          </div>
          <div style="float:right">
            
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2-开发技能/数据库/Mysql/架构与表设计/">
            <time datetime="2017-11-16T15:35:00.000Z" itemprop="datePublished">2017-11-16</time>
        </a>
    </div>


          </div>
        </footer>
    </div>
</article>


    



    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>

</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
          Copyright © 2018 贺龙飞. Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
          <p>
        本作品采用<a rel="external nofollow noopener noreferrer" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
        </p>
        <p style="display:none">
        <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1267343220'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1267343220%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
        </p>
        </div>
    </div>
</footer>

        

    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
