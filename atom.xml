<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贺龙飞的知识库</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-16T13:34:36.381Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>贺龙飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Openssl替换mcrypt加解密</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/openssl%E6%9B%BF%E6%8D%A2mcrypt/"/>
    <id>http://yoursite.com/2-开发技能/程序语言/PHP/openssl替换mcrypt/</id>
    <published>2018-01-16T06:15:00.000Z</published>
    <updated>2018-01-16T13:34:36.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>PHP官方文档显示：</p><blockquote><p>Warning 本扩展从 PHP 7.1.0 开始废弃；自 PHP 7.2.0 起，会移到 PECL。</p></blockquote><p>地址：<a href="https://secure.php.net/manual/zh/intro.mcrypt.php" rel="external nofollow noopener noreferrer" target="_blank">https://secure.php.net/manual/zh/intro.mcrypt.php</a></p><a id="more"></a><h1 id="加解密方法替换公式"><a href="#加解密方法替换公式" class="headerlink" title="加解密方法替换公式"></a>加解密方法替换公式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl_encrypt() = base64_encode(mcrypt_encrypt())</span><br><span class="line">openssl_decrypt() = mcrypt_decrypt(base64_decode($encryptString))</span><br></pre></td></tr></table></figure><h1 id="钉钉的开放平台消息体加解密"><a href="#钉钉的开放平台消息体加解密" class="headerlink" title="钉钉的开放平台消息体加解密"></a>钉钉的开放平台消息体加解密</h1><p>因官方给的是<code>mcrypt</code>方案，所以参考官方给的示例，修改为php7版本。<br>Github 地址：<a href="https://github.com/hlf513/dingtalk-crypto" rel="external nofollow noopener noreferrer" target="_blank">dingtalk-crypto</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require hlf_513/dingtalk-crypto</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$crypto = <span class="keyword">new</span> Crypto(</span><br><span class="line">    $token,</span><br><span class="line">    $encodingAesKey,</span><br><span class="line">    $suiteKey</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$string = <span class="string">'success'</span>;</span><br><span class="line">$timestamp = <span class="string">'1515664989185'</span>;</span><br><span class="line">$nonce = <span class="string">'53IP1CdM'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line">$ret = $crypto-&gt;encryptMsg($string, $timestamp, $nonce);</span><br><span class="line">$ret = json_decode($ret, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line">$ret = $crypto-&gt;decryptMsg($ret[<span class="string">'msg_signature'</span>], $timestamp, $nonce, $ret[<span class="string">'encrypt'</span>]);</span><br><span class="line"><span class="comment">// output: $ret === 'success'</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://blog.csdn.net/sapperlab/article/details/56672443" rel="external nofollow noopener noreferrer" target="_blank">php7.1微信公众平台消息安全模式的加密及解密</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;PHP官方文档显示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Warning 本扩展从 PHP 7.1.0 开始废弃；自 PHP 7.2.0 起，会移到 PECL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://secure.php.net/manual/zh/intro.mcrypt.php&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://secure.php.net/manual/zh/intro.mcrypt.php&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="openssl" scheme="http://yoursite.com/tags/openssl/"/>
    
      <category term="mcrypt" scheme="http://yoursite.com/tags/mcrypt/"/>
    
  </entry>
  
  <entry>
    <title>类库汇总</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/%E7%B1%BB%E5%BA%93%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2-开发技能/程序语言/PHP/类库汇总/</id>
    <published>2018-01-09T06:46:00.000Z</published>
    <updated>2018-01-09T15:57:54.164Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h1><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><ul><li><a href="https://www.easywechat.com/" rel="external nofollow noopener noreferrer" target="_blank">easyWechat</a></li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;SDK&quot;&gt;&lt;a href=&quot;#SDK&quot; class=&quot;header
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序语言" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="composer" scheme="http://yoursite.com/tags/composer/"/>
    
  </entry>
  
  <entry>
    <title>PHP 规范</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/php-psr/"/>
    <id>http://yoursite.com/2-开发技能/程序语言/PHP/php-psr/</id>
    <published>2018-01-09T00:00:00.000Z</published>
    <updated>2018-01-09T15:52:55.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="PHP-Standards-Recommendations"><a href="#PHP-Standards-Recommendations" class="headerlink" title="PHP Standards Recommendations"></a>PHP Standards Recommendations</h1><blockquote><p>PSR 来自 PHP FIG(框架协同工作组)</p></blockquote><p>官网：<a href="http://www.php-fig.org/psr/" rel="external nofollow noopener noreferrer" target="_blank">http://www.php-fig.org/psr/</a></p><p>现有规范</p><ul><li>PSR-0/PSR-4 自动加载（2014.10.21起弃用，请使用 PSR-4）</li><li>PSR-1 基本规范</li><li>PSR-2 代码风格</li><li>PSR-3 日志接口</li><li>PSR-6 Caching Interface</li><li>PSR-7 HTTP Message Interface</li><li>PSR-11 Container Interface</li><li>PSR-13 Hypermedia Links</li><li>PSR-16 Simple Cache</li></ul><h2 id="PSR-0-PSR-4"><a href="#PSR-0-PSR-4" class="headerlink" title="PSR-0/PSR-4"></a>PSR-0/PSR-4</h2><blockquote><p>自动加载<br>class 指 class,interface,trait和其他相似的结构</p></blockquote><h3 id="PSR-0-弃用"><a href="#PSR-0-弃用" class="headerlink" title="PSR-0(弃用)"></a>PSR-0(弃用)</h3><p>按照目录拼接类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/path/to/src/</span><br><span class="line">    VendorFoo/</span><br><span class="line">        Bar/</span><br><span class="line">            Baz.php     # VendorFoo_Bar_Baz</span><br></pre></td></tr></table></figure><h3 id="PSR-4"><a href="#PSR-4" class="headerlink" title="PSR-4"></a>PSR-4</h3><ol><li>类名中下划线转为目录</li><li>每个命名空间必须有顶级命名空间（vender）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vendor_Name</span><br><span class="line">  |- Name_space</span><br><span class="line">    |- Class</span><br><span class="line">    |-Name.php   # \Vendor_Name\Name_space\Class_Name</span><br></pre></td></tr></table></figure><h3 id="自动加载方法"><a href="#自动加载方法" class="headerlink" title="自动加载方法"></a>自动加载方法</h3><ul><li>函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function autoload($className)</span><br><span class="line">&#123;</span><br><span class="line">    $className = ltrim($className, &apos;\\&apos;);</span><br><span class="line">    $fileName  = &apos;&apos;;</span><br><span class="line">    $namespace = &apos;&apos;;</span><br><span class="line">    if ($lastNsPos = strrpos($className, &apos;\\&apos;)) &#123;</span><br><span class="line">        $namespace = substr($className, 0, $lastNsPos);</span><br><span class="line">        $className = substr($className, $lastNsPos + 1);</span><br><span class="line">        $fileName  = str_replace(&apos;\\&apos;, DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;</span><br><span class="line">    &#125;</span><br><span class="line">    $fileName .= str_replace(&apos;_&apos;, DIRECTORY_SEPARATOR, $className) . &apos;.php&apos;;</span><br><span class="line"></span><br><span class="line">    require $fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类: <a href="http://gist.github.com/221634" rel="external nofollow noopener noreferrer" target="_blank">SplClassLoader</a></li></ul><h2 id="PSR-1"><a href="#PSR-1" class="headerlink" title="PSR-1"></a>PSR-1</h2><blockquote><p>基本代码规范  </p></blockquote><ul><li>「文件」源文件<code>必须</code>只使用 <code>&lt;?php</code> 和 <code>&lt;?=</code> 这两种标签。</li><li>「文件」源文件中php代码的编码格式<code>必须</code>只使用不带<code>字节顺序标记(BOM)</code>的<code>UTF-8</code>。</li><li>「类」<code>类名(class name)</code> <code>必须</code>使用<code>骆驼式(StudlyCaps)</code>写法。</li><li>「类」<code>类(class)</code>中的常量<code>必须</code>只由大写字母和<code>下划线(_)</code>组成。</li><li>「类」<code>方法名(method name)</code> <code>必须</code>使用<code>驼峰式(cameCase)</code>。</li><li>「文件」一个源文件<code>建议</code>只用来做声明（<code>类(class)</code>，<code>函数(function)</code>，<code>常量(constant)</code>等）或者只用来做一些引起副作用的操作（例如：输出信息，修改<code>.ini</code>配置等）,但<code>不建议</code>同时做这两件事。</li></ul><h2 id="PSR-2"><a href="#PSR-2" class="headerlink" title="PSR-2"></a>PSR-2</h2><blockquote><p>代码风格指南<br>针对 PSR-1 的继承和扩展</p></blockquote><ul><li>「缩进」代码<code>必须</code>使用4个空格来进行缩进，而不是用制表符。</li><li>「行」一行代码的长度<code>不建议</code>有硬限制；软限制<code>必须</code>为120个字符，<code>建议</code>每行代码80个字符或者更少；非空行<code>不可</code>有空格；一行<code>不可</code>多于一个语句.</li><li>「文件」纯 php 文件 <figure class="highlight plain"><figcaption><span>`必须` 省略;`必须`以空行结束</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 「命名空间」在`命名空间(namespace)`的声明下面`必须`有一行空行，并且在`导入(use)`的声明下面也`必须`有一行空行。</span><br><span class="line">- 「类」`类(class)`的左花括号`必须`放到其声明下面自成一行，右花括号则`必须`放到类主体下面自成一行。</span><br><span class="line">- 「方法」`方法(method)`的左花括号`必须`放到其声明下面自成一行，右花括号则`必须`放到方法主体的下一行。</span><br><span class="line">- 「属性|方法」所有的`属性(property)`和`方法(method)` `必须`有可见性声明；`抽象(abstract)`和`终结(final)`声明`必须`在可见性声明之前；而`静态(static)`声明`必须`在可见性声明之后。</span><br><span class="line">- 「关键字和常量」关键字和常量(true，false，null)`必须`小写</span><br><span class="line">- 「控制结构」在控制结构关键字的后面`必须`有一个空格；而`方法(method)`和`函数(function)`的关键字的后面`不可`有空格。</span><br><span class="line">- 「控制结构」控制结构的左花括号`必须`跟其放在同一行，右花括号`必须`放在该控制结构代码主体的下一行。</span><br><span class="line">- 「控制结构」控制结构的左括号之后`不可`有空格，右括号之前也`不可`有空格。</span><br><span class="line">- 「类」`不建议`使用`_`来表明方法和属性的保护性</span><br></pre></td></tr></table></figure></li></ul><p>&lt;?php<br>namespace Vendor\Package;</p><p>use FooInterface;<br>use BarClass as Bar;<br>use OtherVendor\OtherPackage\BazClass;</p><p>class Foo extends Bar implements<br>    FooInterface,<br>    Bar<br>{<br>    public function sampleFunction($a, $b = null)<br>    {<br>        if ($a === $b) {<br>            bar();<br>        } elseif ($a &gt; $b) {<br>            $foo-&gt;bar($arg1);<br>        } else {<br>            BazClass::bar($arg2, $arg3);<br>        }<br>    }</p><pre><code>final public static function bar(){   $foo-&gt;bar(        $longArgument,        $longerArgument,        $muchLongerArgument    );    $longArgs_shortVars = function (        $longArgument,        $longerArgument,        $muchLongerArgument = null    ) use ($var1) {       // body    };} public function aVeryLongMethodName(    ClassTypeHint $arg1,    &amp;$arg2,    array $arg3 = []) {    switch ($expr) {        case 0:            echo &apos;First case, with a break&apos;;            break;        case 1:            echo &apos;Second case, which falls through&apos;;            // no break        case 2:        case 3:        case 4:            echo &apos;Third case, return instead of break&apos;;            return;        default:            echo &apos;Default case&apos;;            break;    }    while ($expr) {        // structure body    }    do {        // structure body;    } while ($expr);    for ($i = 0; $i &lt; 10; $i++) {        // for body    }    foreach ($iterable as $key =&gt; $value) {        // foreach body    }    try {        // try body    } catch (FirstExceptionType $e) {        // catch body    } catch (OtherExceptionType $e) {        // catch body    }}</code></pre><p>}<br>```</p><h2 id="PSR-3"><a href="#PSR-3" class="headerlink" title="PSR-3"></a>PSR-3</h2><blockquote><p>日志接口<br>主要目标是让类库获得一个Psr\Log\LoggerInterface对象并能通过简单通用的方式来写日志  </p></blockquote><ol><li>8个等级（debug, info, notice, warning, error, critical, alert, emergency）</li><li>log 方法(等级，日志)；<ul><li>等级<code>必须</code>一致，否则<code>必须</code>抛出<code>Psr\Log\InvalidArgumentException</code></li><li>日志<code>必须</code>是字符串，或者是可<code>__toString</code>的对象</li></ul></li><li>….</li></ol><h1 id="代码检查工具"><a href="#代码检查工具" class="headerlink" title="代码检查工具"></a>代码检查工具</h1><h2 id="PHP-Mess-Detector"><a href="#PHP-Mess-Detector" class="headerlink" title="PHP Mess Detector"></a><a href="http://phpmd.org/" rel="external nofollow noopener noreferrer" target="_blank">PHP Mess Detector</a></h2><p>PHP项目体检工具，根据你设定的标准（如单一文件代码体积，未使用的参数个数，未使用的方法数）检查PHP代码，超出设定的标准时报警。</p><h2 id="PHP-Copy-Paste-Detector"><a href="#PHP-Copy-Paste-Detector" class="headerlink" title="PHP Copy Paste Detector"></a><a href="https://github.com/sebastianbergmann/phpcpd" rel="external nofollow noopener noreferrer" target="_blank">PHP Copy Paste Detector</a></h2><p>顾名思义，检查冗余代码的</p><h2 id="PHP-Dead-Code-Detector"><a href="#PHP-Dead-Code-Detector" class="headerlink" title="PHP Dead Code Detector"></a><a href="https://github.com/sebastianbergmann/phpdcd" rel="external nofollow noopener noreferrer" target="_blank">PHP Dead Code Detector</a></h2><p>看名字就知道了，检查从未被调用过的方法</p><h2 id="PHP-Code-Sniffer"><a href="#PHP-Code-Sniffer" class="headerlink" title="PHP Code Sniffer"></a><a href="http://pear.php.net/package/PHP_CodeSniffer" rel="external nofollow noopener noreferrer" target="_blank">PHP Code Sniffer</a></h2><h2 id="PHPLint"><a href="#PHPLint" class="headerlink" title="PHPLint"></a><a href="http://www.icosaedro.it/phplint/" rel="external nofollow noopener noreferrer" target="_blank">PHPLint</a></h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/hfcorriez/fig-standards" rel="external nofollow noopener noreferrer" target="_blank">PHP PSR代码标准中文版</a></li><li><a href="https://segmentfault.com/q/1010000000119048" rel="external nofollow noopener noreferrer" target="_blank">PHP中有什么好的代码自动检查工具吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;PHP-Standards-Recommendations&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序语言" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="PSR" scheme="http://yoursite.com/tags/PSR/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://yoursite.com/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/1-基础知识/数据结构与算法/队列/</id>
    <published>2018-01-07T10:40:00.000Z</published>
    <updated>2018-01-07T16:13:27.320Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>队列是只允许在一端进行插入操作，另一端进行删除操作的线性表。</p></blockquote><p>队列是一种「先进先出」的线性表。</p><p><img src="/images/2018/01/07/队列.png" alt="队列"></p><p><strong>术语：</strong></p><p>队头：允许删除的一端<br>队尾：允许插入的一端</p><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p><img src="/images/2018/01/07/队列的-adt.png" alt="队列的 ADT"></p><p>只能队尾插入；队头删除。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>入队</strong><br><img src="/images/2018/01/07/队列-入队.png" alt="队列-入队"></p><p>时间复杂度：O(1)</p><p><strong>出队</strong><br><img src="/images/2018/01/07/队列-出队.png" alt="队列-出队"><br>时间复杂度：O(n)</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><blockquote><p>循环队列：头尾相接的存储结构</p></blockquote><p><img src="/images/2018/01/07/循环队列.png" alt="循环队列"></p><p>额外两个指针：<br>front 指针：指向队头元素；<br>rear 指针：指向队尾元素的下一个位置；</p><p>因为空队列和队列满时，front=rear，所以增加一个 flag，若空队列为0，若队列满为1。</p><p><img src="/images/2018/01/07/循环队列的顺序存储结构.png" alt="循环队列的顺序存储结构"></p><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><blockquote><p>链式存储：只能尾进头出的单链表，简称：链队列。</p></blockquote><p><img src="/images/2018/01/08/队列链式存储.png" alt="队列链式存储"></p><p><img src="/images/2018/01/08/队列的链式存储-空队列.png" alt="队列的链式存储-空队列"><br>空队列时，front、rear 都指向头结点。</p><p><img src="/images/2018/01/08/链队列的结构定义.png" alt="链队列的结构定义"></p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p><strong>入队</strong><br><img src="/images/2018/01/08/链队列-入队.png" alt="链队列-入队"><br>链表队列尾部插入结点；时间复杂度：O(1)。</p><p><strong>出队</strong><br><img src="/images/2018/01/08/链队列-出队.png" alt="链队列-出队"><br>时间复杂度：O(1)。</p><h3 id="循环队列与链队列的区别"><a href="#循环队列与链队列的区别" class="headerlink" title="循环队列与链队列的区别"></a>循环队列与链队列的区别</h3><p><strong>时间上：</strong><br>都是 O(1)。</p><p><strong>空间上：</strong><br>循环队列：固定长度；有元素个数限制或浪费的问题。<br>链队列：每个元素需要额外的指针域，但没有元素个数限制/浪费；更加灵活。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话数据结构》</li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="1-基础知识" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://yoursite.com/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/"/>
    <id>http://yoursite.com/1-基础知识/数据结构与算法/栈/</id>
    <published>2018-01-07T06:41:00.000Z</published>
    <updated>2018-01-07T15:32:19.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>栈是限定仅在表尾进行插入和删除操作的线性表。</p></blockquote><p>栈又被成为「<strong>后进先出</strong>」的线性表</p><p><img src="/images/2018/01/07/栈.png" alt="栈"></p><p><strong>栈顶</strong>：允许进栈出栈的一端<br><strong>栈底</strong>：栈的底部<br><strong>空栈</strong>：没有数据元素的栈<br><strong>进栈</strong>：数据元素进入栈的操作<br><strong>出栈</strong>：数据元素从栈中移出的操作</p><p><strong>注意：最先进的元素肯定会最后出栈吗？</strong><br>不一定；元素可以在任何时刻进出栈，不是所有的元素都进栈后才能出栈。</p><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p><img src="/images/2018/01/07/栈的-adt.png" alt="栈的 ADT"></p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>栈的顺序存储其实也是线性表的顺序存储的简化，简称：顺序栈。</p><p><img src="/images/2018/01/07/顺序栈的结构定义.png" alt="顺序栈的结构定义"><br><img src="/images/2018/01/07/顺序栈.png" alt="顺序栈"></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><p><img src="/images/2018/01/07/顺序栈-进栈.png" alt="顺序栈-进栈"><br><img src="/images/2018/01/07/顺序栈-进栈-结构定义.png" alt="顺序栈-进栈-结构定义"><br>时间复杂度：O(1)</p><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><p><img src="/images/2018/01/07/顺序栈-出栈-结构定义.png" alt="顺序栈-出栈-结构定义"><br>时间复杂度：O(1)</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>空间大小相对固定</li><li>若有两个相同数据类型的栈，则可使用两个数组的两端做栈底（前提：一个栈增、一个栈减）</li></ol><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><blockquote><p>栈的链式存储，简称：链栈</p></blockquote><p><img src="/images/2018/01/07/链栈.png" alt="链栈"></p><p>通常链栈是不需要头结点的。<br>空栈时 <code>top = NULL</code>。</p><p><img src="/images/2018/01/07/链栈-结构定义.png" alt="链栈-结构定义"></p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><h4 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h4><p><img src="/images/2018/01/07/链栈-进栈.png" alt="链栈-进栈"></p><p><img src="/images/2018/01/07/链栈-进栈-结构定义1.png" alt="链栈-进栈-结构定义1"><br><img src="/images/2018/01/07/链栈-进栈-结构定义2.png" alt="链栈-进栈-结构定义2"></p><p>时间复杂度：O(1)</p><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><p><img src="/images/2018/01/07/链栈-出栈.png" alt="链栈-出栈"><br><img src="/images/2018/01/07/链栈-出栈-结构定义.png" alt="链栈-出栈-结构定义"></p><p>时间复杂度：O(1)</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>空间大小不可控。</p><h1 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h1><p>栈是种特殊的线性表；简化了程序设计问题。</p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>用栈实现「斐波那契」。</p><p><strong>迭代与递归的区别：</strong><br>迭代：循环结构；不需要调用函数和占用额外的内存。<br>递归：选择结构；建立大量的函数副本，占用大量的内存；还可增加代码的可读性。</p><h2 id="四则运算表达式"><a href="#四则运算表达式" class="headerlink" title="四则运算表达式"></a>四则运算表达式</h2><p>用栈实现「后缀表达式」(逆波兰)。</p><p>规则：</p><ol><li>从左到右遍历</li><li>若是数字则输出</li><li>若是符号，则判断栈顶符号优先级，若是表达式是右括号或优先级低于栈顶符号，则栈顶符号依次判断优先级输出；流程图如下：</li></ol><p><img src="/images/2018/01/07/后缀表达式-符号判断.png" alt="后缀表达式-符号判断"></p><p>例：<code>9+(3-1)*3+10/2</code> =&gt; <code>9 3 1 - 3 * + 10 2 / +</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话数据结构》</li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="1-基础知识" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>源码编译说明</title>
    <link href="http://yoursite.com/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/1-基础知识/Linux/源码编译说明/</id>
    <published>2018-01-02T16:28:00.000Z</published>
    <updated>2018-01-09T16:04:50.504Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通常需要三步：</p><ol><li><p>检查依赖并根据系统环境和参数生成对应的 makefile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line"># ./configure -h 查看参数</span><br></pre></td></tr></table></figure></li><li><p>编译生成设定的目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>把目标文件安装至系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li></ol><h1 id="make-解析"><a href="#make-解析" class="headerlink" title="make 解析"></a>make 解析</h1><p>以下是常规的 make 命令：</p><p><strong> make all </strong><br>产生我们设定的目标（例：可执行文件、动态库等）；只输入<code>make</code>默认是<code>make all</code>。</p><p><strong> make clean </strong><br>清除编译产生的可执行文件及目标文件(object file，*.o)。</p><p><strong> make install </strong><br>将程序安装至系统中。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。如果用bin_PROGRAMS宏的话，程序会被安装至/usr/local/bin这个目录。</p><p><strong> make dist </strong><br>将程序和相关的档案包装成一个压缩文件以供发布。执行完在目录下会产生一个以 PACKAGE-VERSION.tar.gz 为名称的文件。 PACKAGE和VERSION这两个变数是根据 configure.ini 文件中 AM_INIT_AUTOMAKE(PACKAGE，VERSION) 的定义。</p><p><strong> make distcheck </strong><br>和<code>make dist</code>类似，但是加入检查包装后的压缩文件是否正常。这个目标除了把程序和相关文件包装成 tar.gz 文件外，还会自动把这个压缩文件解开，执行 <code>configure</code>，并且进行 <code>make all</code> 的动作，确认编译无误后，会显示这个 tar.gz 文件可供发布了。这个检查非常有用，检查过关的包，基本上可以给任何一个具备GNU开发环境-的人去重新编译。</p><p><strong> make distclean </strong><br>除了清除可执行文件和目标文件外，把<code>configure</code>所产生的 Makefile 也清除掉。</p><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="1-基础知识" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>编译安装</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2-开发技能/程序语言/PHP/编译安装/</id>
    <published>2018-01-02T15:35:00.000Z</published>
    <updated>2018-01-09T15:52:55.465Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p><a href="https://secure.php.net/downloads.php" rel="external nofollow noopener noreferrer" target="_blank">https://secure.php.net/downloads.php</a></p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="检查依赖并生成-makefile-文件"><a href="#检查依赖并生成-makefile-文件" class="headerlink" title="检查依赖并生成 makefile 文件"></a>检查依赖并生成 makefile 文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># php7.2.0</span></span><br><span class="line"></span><br><span class="line">./configure  --prefix=/data/soft/php-7.2.0 --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --with-openssl --<span class="built_in">enable</span>-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-curl --with-gd=/usr/<span class="built_in">local</span>/gd --with-gettext --with-libxml-dir=/usr --<span class="built_in">enable</span>-xml --<span class="built_in">enable</span>-sockets --<span class="built_in">enable</span>-fpm --<span class="built_in">enable</span>-zip --<span class="built_in">enable</span>-soap --with-mhash=/usr/<span class="built_in">local</span>/include --with-config-file-path=/data/soft/php-7.2.0/etc --with-config-file-scan-dir=/data/soft/php-7.2.0/etc/php.d --with-bz2</span><br></pre></td></tr></table></figure><p>具体的参数可以通过 <code>./configure --help</code> 查看；根据你的实际应用选择不同的参数。</p><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="安装到系统"><a href="#安装到系统" class="headerlink" title="安装到系统"></a>安装到系统</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要一定权限</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h1><p>配置文件存在于下载的源码的根目录下；有两个：</p><ul><li>php.ini-production</li><li>php.ini-development</li></ul><p><strong>两个配置文件的区别：（基于7.2.0源码）</strong></p><table><thead><tr><th>development</th><th>production</th><th>说明</th></tr></thead><tbody><tr><td>error_reporting = E_ALL</td><td>error_reporting = E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT</td><td>显示除去E_STRICT、E_DEPRECATED外的所有错误</td></tr><tr><td>display_errors = On</td><td>display_errors = Off</td><td>是否显示错误</td></tr><tr><td>display_startup_errors = On</td><td>display_startup_errors = Off</td><td>是否显示 PHP 启动时的错误</td></tr><tr><td>mysqlnd.collect_memory_statistics = On</td><td>mysqlnd.collect_memory_statistics = Off</td><td>是否启用mysql内存访问统计，可以通过下列函数获取信息mysqli_get_client_stats(), mysqli_get_connection_stats(), mysqli_get_cache_stats()</td></tr><tr><td>zend.assertions = 1</td><td>zend.assertions = -1</td><td>与assert()函数相关：<br> 1 - 生成和执行代码 (开发模式) <br> 0 - 生成代码，但在执行时跳过它 <br> -1 - 不生成代码 (生产环境)</td></tr></tbody></table><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;下载源码&quot;&gt;&lt;a href=&quot;#下载源码&quot; class=&quot;head
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序语言" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="http://yoursite.com/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/1-基础知识/数据结构与算法/线性表/</id>
    <published>2018-01-01T12:53:00.000Z</published>
    <updated>2018-01-04T17:08:40.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>线性表是零个或多个具有相同类型的数据元素的有限序列。</p></blockquote><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(list)</span><br><span class="line">Data</span><br><span class="line">  线性表的数据对象集合为&#123;a1....an&#125;，每个元素的类型均为 DataType。其中，除第一个元素 a1 外，每一个元素有且只有一个前驱元素，除了最后一个元素 an 外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">  InitList(*L): 初始化操作，建立一个空的线性表 L</span><br><span class="line">  ListEmpty(L): 若线性表为空，返回 true，否则返回 false</span><br><span class="line">  ClearList(*L): 将线性表清空</span><br><span class="line">  GetElem(L,i,*e): 将线性表 L 中第 i 个位置元素值返回给 e</span><br><span class="line">  LocateElem(L,e): 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。</span><br><span class="line">  ListInsert(*L,i,e): 在线性表 L 中的第 i 个位置插入新元素 e</span><br><span class="line">  ListDelete(*L,i,*e): 删除线性表 L 中第 i 个位置元素，并用 e 返回其值</span><br><span class="line">  ListLength(L): 返回线性表 L 的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><blockquote><p>线性表的顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><p><img src="/images/2018/01/01/线性表顺序存储结构.png" alt="线性表顺序存储结构"></p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>通常使用「一维数组」来实现</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>直接根据「数组」下标获取；时间复杂度：O(1)。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>思路：</p><ol><li>如果插入位置不合理，抛出异常</li><li>若线性表长度 &gt;= 数组长度，则抛出异常或动态增加容量</li><li>从最后一个元素开始向前遍历到第 i 个位置，分别将他们都向后移动一个位置</li><li>将要插入元素填入位置 i 处</li><li>表长加1</li></ol><p>时间复杂度 O(n)。</p><p><img src="/images/2018/01/01/线性表-顺序存储-插入.png" alt="线性表-顺序存储-插入"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>思路：</p><ol><li>若删除位置不合理，抛出异常</li><li>取出删除元素</li><li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li><li>表长减1</li></ol><p>时间复杂度 O(n)。</p><p><img src="/images/2018/01/01/线性表-顺序存储-删除.png" alt="线性表-顺序存储-删除"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>无需为表示表中元素的逻辑关系而增加额外的存储空间（指针）</li><li>可以快速读取表中的任一位置的元素</li></ul><p><strong>缺点：</strong></p><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>会造成存储空间的「碎片」</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>已知固定长度</li><li>不经常更新（新增、删除）</li></ul><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>结点：</strong> 数据域 + 指针域<br><strong>头指针：</strong> 链表中第一个结点的存储位置，通常作为链表名称；链表的必要元素<br><strong>头结点：</strong> 链表的第一个结点前附设的一个结点，数据域一般为空，也可存放公共数据；存在的作用是使对第一个结点的操作和其他的结点保持一致<br><strong>前驱结点：</strong> 当前结点的前一个结点<br><strong>后继结点：</strong> 当前结点的下一个结点</p><p><img src="/images/2018/01/01/头指针与头结点.png" alt="头指针与头结点"></p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote><p>n 个结点链接成一个链表，每个结点只有一个指针域</p></blockquote><p><img src="/images/2018/01/01/线性表-链式存储-单链表.png" alt="线性表-链式存储-单链表"></p><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><h5 id="整表创建"><a href="#整表创建" class="headerlink" title="整表创建"></a>整表创建</h5><p>思路：</p><ol><li>声明一结点 p 和计数器变量 i</li><li>初始化一空链表 L</li><li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表</li><li>循环<ul><li>生成一新结点赋值给 p</li><li>随机生成一数字赋值给 p 的数据域 p-&gt;Data</li><li>将 p 插入到头结点与前一结点之间</li></ul></li></ol><h5 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h5><p>思路：</p><ol><li>声明一结点 p 和 q</li><li>将第一个结点赋值给 p</li><li>循环<ul><li>将下一结点赋值给 q</li><li>释放 p</li><li>将 q 赋值给 p</li></ul></li></ol><h5 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h5><p>思路：</p><ol><li>声明一个结点 p 指向链表第一个结点，初始化 j 从1开始</li><li>当 j &lt; 1 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加1</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li><li>否则查找成功，返回结点 p 的数据</li></ol><p>最坏情况的时间复杂度 O(n)</p><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><p>思路：</p><ol><li>声明一结点 p 指向链表第一个结点，初始化 j 从1开始</li><li>当 j &lt; 1 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加1</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li><li>否则查找成功，在系统中生成一个空结点 s</li><li>将数据元素 e 赋值给 s-&gt;data</li><li>单链表的插入标准语句 s-&gt;next=p-&gt;next; p-&gt;next=s</li><li>返回成功</li></ol><p>最坏情况的时间复杂度 O(n)</p><p><img src="/images/2018/01/02/线性表-链式存储-单链表-插入.png" alt="线性表-链式存储-单链表-插入"></p><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>思路：</p><ol><li>声明一结点 p 指向链表第一个结点，初始化 j 从1开始</li><li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加1</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在</li><li>否则查找成功，将欲删除的结点 p-&gt;next 赋值给 q</li><li>单链表的删除标准语句 p-&gt;next=q-&gt;next</li><li>将 q 结点中的数据赋值给 e，作为返回</li><li>释放 q 结点</li><li>返回成功</li></ol><p>最坏情况的时间复杂度 O(n)</p><p><img src="/images/2018/01/02/线性表-链式存储-单链表-删除.png" alt="线性表-链式存储-单链表-删除"></p><h4 id="与顺序存储结构对比"><a href="#与顺序存储结构对比" class="headerlink" title="与顺序存储结构对比"></a>与顺序存储结构对比</h4><p><img src="/images/2018/01/02/单链表-vs-顺序存储.png" alt="单链表 vs 顺序存储"></p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>频繁更新（插入、删除）</li><li>表空间未知</li></ul><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>使用「数组」实现单链表；数组有两个元素：数据+指针。</p><p><img src="/images/2018/01/01/线性表-链式存储-静态链表.png" alt="线性表-链式存储-静态链表"></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote><p>循环链表：将单链表的终端结点的指针由 null 改为指向头结点，就使整个单链表形成一个环</p></blockquote><p><img src="/images/2018/01/02/线性表-链式存储-循环链表-空链表.png" alt="线性表-链式存储-循环链表-空链表"></p><p><img src="/images/2018/01/02/线性表-链式存储-循环链表-非空链表.png" alt="线性表-链式存储-循环链表-非空链表"></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote><p>双向链表：在单链表的每个结点中，再设置一个指向其前驱结点的指针域</p></blockquote><p><img src="/images/2018/01/02/线性表-链式存储-双向链表-空链表.png" alt="线性表-链式存储-双向链表-空链表"></p><p><img src="/images/2018/01/02/线性表-链式存储-双向链表-非空链表.png" alt="线性表-链式存储-双向链表-非空链表"></p><h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><h5 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h5><p><img src="/images/2018/01/02/线性表-链式存储-双向链表-插入.png" alt="线性表-链式存储-双向链表-插入"></p><h5 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h5><p><img src="/images/2018/01/02/线性表-链式存储-双向链表-删除.png" alt="线性表-链式存储-双向链表-删除"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话数据结构》<!--以下是脚注--></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="1-基础知识" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>概述</title>
    <link href="http://yoursite.com/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/1-基础知识/数据结构与算法/概述/</id>
    <published>2017-12-31T10:16:00.000Z</published>
    <updated>2018-01-01T08:31:32.649Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote><p>数据结构是相互之间存在一种或多种定关系的数据元素的集合。</p></blockquote><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="/images/2017/12/31/组成.png" alt="组成"></p><p>注意：</p><ul><li>数据项是数据的最小单元</li><li>数据元素是讨论问题时在数据结构中建立数据模型的着眼点</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><blockquote><p>逻辑结构：数据对象中数据元素之间的关系。</p></blockquote><h4 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h4><p><img src="/images/2017/12/31/集合结构.png" alt="集合结构"><br>数据元素同属于一个集合，互相之间没有关系。</p><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><p><img src="/images/2017/12/31/线性结构.png" alt="线性结构"></p><p>数据元素之间是一对一的关系</p><h4 id="树性结构"><a href="#树性结构" class="headerlink" title="树性结构"></a>树性结构</h4><p><img src="/images/2017/12/31/树形结构.png" alt="树形结构"></p><p>数据元素之间是一对多的关系</p><h4 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h4><p><img src="/images/2017/12/31/图形结构.png" alt="图形结构"><br>数据元素之间是多对多的关系</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><blockquote><p>物理结构：数据的逻辑结构在计算机中的存储形式。</p></blockquote><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p><img src="/images/2017/12/31/顺序存储结构.png" alt="顺序存储结构"></p><p>数据元素放在地址连续的存储单元里。</p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p><img src="/images/2017/12/31/链式存储结构.png" alt="链式存储结构"><br>数据元素放在任意位置的存储单元里；每个数据元素需要一个额外的指定地址。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><blockquote><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>输入（0个或多个）</li><li>输出（至少1个）</li><li>有穷性（在可接受的时间内执行完毕）</li><li>确定性（每个算法步骤不能有二义性）</li><li>可行性（每个算法步骤都是实际可执行，而不是理论可行）</li></ul><h2 id="设计的要求"><a href="#设计的要求" class="headerlink" title="设计的要求"></a>设计的要求</h2><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><blockquote><p>正确性：算法至少应该具有输入、输出和加工处理无歧义、能正确反映问题的需求、能够得到问题的正确答案。</p></blockquote><p>算法程序的正确，大体分为以下四个层次：</p><ol><li>没有语法错误</li><li>对合法的输入数据能够产生满足要求的输出结果</li><li>对非法的输入数据能够产生满足规格说明的结果</li><li>对精心设计的测试数据有满足要求的输出结果</li></ol><p>因为测试层次4的代价比较昂贵；所以一般情况下，我们把层次3作为一个算法是否正确的标准。</p><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><blockquote><p>可读性：算法设计是为了方便阅读、理解和交流。</p></blockquote><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><blockquote><p>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名的结果。</p></blockquote><h3 id="高效率低存储"><a href="#高效率低存储" class="headerlink" title="高效率低存储"></a>高效率低存储</h3><p>高效率：算法的执行时间短<br>低储存：算法在执行过程中占用的存储空间低</p><h2 id="效率的度量方法"><a href="#效率的度量方法" class="headerlink" title="效率的度量方法"></a>效率的度量方法</h2><h3 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h3><p>通过实际测试不同算法的运行时间来比较效率的高低。因为会有不准确，成本高等缺点，所以不予采纳。</p><p>不准确：硬件不同、测试数据的规模不同<br>成本高：需要实现各种算法、设计测试数据</p><h3 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h3><p>经过分析，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。计算对运行时间有消耗的基本操作的执行次数，即可测定运行时间。</p><h4 id="理论依据"><a href="#理论依据" class="headerlink" title="理论依据"></a>理论依据</h4><p>通过对比算法的「<strong>关键执行次数</strong>」的函数的渐进增长性，基本可以分析出：<br>某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。(函数渐进增长)</p><h4 id="如何判断算法的好坏？"><a href="#如何判断算法的好坏？" class="headerlink" title="如何判断算法的好坏？"></a>如何判断算法的好坏？</h4><p>通常我们使用「时间复杂度」来考核一个算法的好坏。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><blockquote><p>算法的时间复杂度，也就是算法的时间量度，计算公式记作：T(n) = O(f(n))，表示随着 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同；其中 n 表示问题规模，f(n) 是问题规模的某个函数。</p></blockquote><p>一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。</p><h6 id="复杂度的渐进表示法"><a href="#复杂度的渐进表示法" class="headerlink" title="复杂度的渐进表示法"></a>复杂度的渐进表示法</h6><ul><li>T(n) = O(f(n)) 表示存在常数 C&gt;0，N&gt;0 使得当 n&gt;N 时有 T(n) &lt;= C*f(n)</li><li>T(n) = Ω(g(n)) 表示存在常数 C&gt;0，N&gt;0 使得当 n&gt;N 时有 T(n) &gt;= C*g(n)</li><li>T(n) = 𝚯(h(n)) 表示同时有 T(n) = O(h(n)) 和 T(n) = Ω(h(n))</li></ul><p>O：上界<br>Ω：下界<br>𝚯：即是上界也是下界</p><p>注意：<br>O 通常是找最小的上界<br>Ω 通常是找最大的下界</p><h6 id="推导大-O-阶的方法"><a href="#推导大-O-阶的方法" class="headerlink" title="推导大 O 阶的方法"></a>推导大 O 阶的方法</h6><p>获取大 O 阶：</p><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>运行次数函数只保留最高阶项</li><li>若最高阶项存在且不是1，则去除与其相乘的常数。</li><li>若两段算法分别有复杂度 T1(n) = O(f1(n)) 和 T2(n) = O(f2(n))则<ul><li>T1(n) + T2(n) = max(O(f1(n)),O(f2(n)))</li><li>T1(n) <em> T2(n) = O(f1(n) </em> f2(n))</li></ul></li><li>若 T(n) 是关于 n 的 k 阶多项式，那么 T(n) = 𝚯(n^k)</li><li>一个 for 循环的时间复杂度等于循环次数 * 循环体代码的复杂度</li><li>if-else 结构的复杂度取决于 if 的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大</li></ol><p><img src="/images/2017/12/31/常见时间复杂度.png" alt="常见时间复杂度"></p><h6 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h6><p>最坏情况：运行时间的最坏情况。<br>平均情况：期望得到的运行时间；无法通过分析估算，一般是通过运行一定数量的数据后估算出来的。</p><p>一般情况下，我们提到的运行时间都是指：最坏时间复杂度。</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><blockquote><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中 n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话数据结构》</li><li>《浙大-数据结构》</li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;head
      
    
    </summary>
    
      <category term="1-基础知识" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Lumen项目初始化</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/%E6%A1%86%E6%9E%B6/lumen%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2-开发技能/程序语言/PHP/框架/lumen项目初始化/</id>
    <published>2017-12-29T15:23:00.000Z</published>
    <updated>2017-12-29T16:02:30.233Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h1><p>在 <code>bootstrap/app.php</code> 写入：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;configureMonologUsing(<span class="function"><span class="keyword">function</span><span class="params">($monolog)</span> </span>&#123;</span><br><span class="line">     $monolog-&gt;pushHandler(</span><br><span class="line">          <span class="keyword">new</span> \Monolog\Handler\RotatingFileHandler(</span><br><span class="line">               storage_path(<span class="string">'logs/data-entry.log'</span>),</span><br><span class="line">               env(<span class="string">'APP_LOG_MAX_FILES'</span>, <span class="number">30</span>),</span><br><span class="line">               constant(<span class="string">'\\Monolog\\Logger::'</span> . strtoupper(env(<span class="string">'APP_LOG_LEVEL'</span>, <span class="string">'debug'</span>)))</span><br><span class="line">          )</span><br><span class="line">     );</span><br><span class="line">     <span class="keyword">return</span> $monolog;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="调试、异常、错误码"><a href="#调试、异常、错误码" class="headerlink" title="调试、异常、错误码"></a>调试、异常、错误码</h1><blockquote><p>见laravel项目初始化</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;开启日志&quot;&gt;&lt;a href=&quot;#开启日志&quot; class=&quot;head
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序语言" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
      <category term="框架" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="Lumen" scheme="http://yoursite.com/tags/Lumen/"/>
    
  </entry>
  
  <entry>
    <title>Laravel项目初始化</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/%E6%A1%86%E6%9E%B6/laravel%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2-开发技能/程序语言/PHP/框架/laravel项目初始化/</id>
    <published>2017-12-29T15:10:00.000Z</published>
    <updated>2017-12-29T16:57:54.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="配置-PHPSTORM"><a href="#配置-PHPSTORM" class="headerlink" title="配置 PHPSTORM"></a>配置 PHPSTORM</h1><ol><li>安装 ide-helper : <a href="https://github.com/barryvdh/laravel-ide-helper" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/barryvdh/laravel-ide-helper</a></li><li>安装 phpstorm 的 tools<ol><li>进入设置 Preferences | Tools | Command Line Tool Support</li><li>选择 tool bases on Symfony console</li></ol></li></ol><h1 id="生产环境监控"><a href="#生产环境监控" class="headerlink" title="生产环境监控"></a>生产环境监控</h1><p>Sentry ：<a href="https://sentry.io/for/laravel/" rel="external nofollow noopener noreferrer" target="_blank">https://sentry.io/for/laravel/</a></p><h1 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h1><p>修改 <code>config/app.php</code> 中 <code>&#39;timezone&#39; =&gt; &#39;Asia/Shanghai&#39;,</code></p><h1 id="Web-应用"><a href="#Web-应用" class="headerlink" title="Web 应用"></a>Web 应用</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>php-debuger : <a href="https://github.com/barryvdh/laravel-debugbar" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/barryvdh/laravel-debugbar</a></p><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p>entrust: <a href="https://github.com/Zizaco/entrust" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Zizaco/entrust</a></p><h1 id="Api-应用"><a href="#Api-应用" class="headerlink" title="Api 应用"></a>Api 应用</h1><h2 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h2><p>clockwork : <a href="https://github.com/itsgoingd/clockwork" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/itsgoingd/clockwork</a></p><h2 id="开启-SQL-日志"><a href="#开启-SQL-日志" class="headerlink" title="开启 SQL 日志"></a>开启 SQL 日志</h2><p>写入：<code>AppServiceProvider-&gt;boot()</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听运行的sql,写入到log中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;app-&gt;environment() !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    \DB::listen(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="params">($sql)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">foreach</span> ($sql-&gt;bindings <span class="keyword">as</span> $i =&gt; $binding) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($binding <span class="keyword">instanceof</span> \DateTime) &#123;</span><br><span class="line">                    $sql-&gt;bindings[$i] = $binding-&gt;format(<span class="string">'\'Y-m-d H:i:s\''</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (is_string($binding)) &#123;</span><br><span class="line">                        $sql-&gt;bindings[$i] = <span class="string">"'$binding'"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Insert bindings into query</span></span><br><span class="line">            $query = str_replace(<span class="keyword">array</span>(<span class="string">'%'</span>, <span class="string">'?'</span>), <span class="keyword">array</span>(<span class="string">'%%'</span>, <span class="string">'%s'</span>), $sql-&gt;sql);</span><br><span class="line">            $query = vsprintf($query, $sql-&gt;bindings);</span><br><span class="line">            <span class="comment">// Save the query to Log file</span></span><br><span class="line">            \Log::debug(<span class="string">'SQL'</span>, [$query]);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="comment">// end_if</span></span><br></pre></td></tr></table></figure><h2 id="关闭-Cookie"><a href="#关闭-Cookie" class="headerlink" title="关闭 Cookie"></a>关闭 Cookie</h2><blockquote><p>api 应用时使用。</p></blockquote><p>注释以下文件中的 cookie 相关：</p><ol><li>app/Http/Kernel.php</li><li>config/app.php</li></ol><h2 id="Helper-函数"><a href="#Helper-函数" class="headerlink" title="Helper 函数"></a>Helper 函数</h2><p><code>app/Common/Helper.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应成功</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span><span class="params">(array $data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$json = [</span><br><span class="line"><span class="string">'statusCode'</span> =&gt; \App\Common\Status::Success,</span><br><span class="line"><span class="string">'message'</span>    =&gt; <span class="string">'ok'</span>,</span><br><span class="line"><span class="string">'data'</span>       =&gt; $data,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response()-&gt;json($json);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $errData</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed $detail</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span><span class="params">(array $errData, $detail = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">isset</span>($errData[<span class="string">'errCode'</span>]) <span class="keyword">or</span> ! <span class="keyword">isset</span>($errData[<span class="string">'errMsg'</span>])) &#123;</span><br><span class="line">fail(\App\Common\Status::SystemError[<span class="string">'codeException'</span>]);</span><br><span class="line">&#125;</span><br><span class="line">$json = [</span><br><span class="line"><span class="string">'statusCode'</span> =&gt; $errData[<span class="string">'errCode'</span>],</span><br><span class="line"><span class="string">'message'</span>    =&gt; $errData[<span class="string">'errMsg'</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">if</span> (App::environment() != <span class="string">'production'</span>) &#123;</span><br><span class="line">$json[<span class="string">'detail'</span>] = $detail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response()-&gt;json($json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><p><code>app/Common/Status.php</code>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Common</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Status</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> Success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100 + 001</span></span><br><span class="line"><span class="keyword">const</span> SystemError = [</span><br><span class="line"><span class="string">'codeException'</span> =&gt; [</span><br><span class="line"><span class="string">'errCode'</span> =&gt; <span class="number">100001</span>,</span><br><span class="line"><span class="string">'errMsg'</span>  =&gt; <span class="string">'The format of errorCode was error'</span></span><br><span class="line">]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 101 + 001</span></span><br><span class="line"><span class="keyword">const</span> ClientError = [</span><br><span class="line"><span class="string">'paramException'</span> =&gt; [</span><br><span class="line"><span class="string">'errCode'</span> =&gt; <span class="number">101001</span>,</span><br><span class="line"><span class="string">'errMsg'</span>  =&gt; <span class="string">'The given data was invalid'</span></span><br><span class="line">],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 102 + 001</span></span><br><span class="line"><span class="keyword">const</span> Access = [</span><br><span class="line"><span class="string">'fail'</span>        =&gt; [</span><br><span class="line"><span class="string">'errCode'</span> =&gt; <span class="number">102001</span>,</span><br><span class="line"><span class="string">'errMsg'</span>  =&gt; <span class="string">'No access'</span></span><br><span class="line">],</span><br><span class="line"><span class="string">'noLogin'</span>     =&gt; [</span><br><span class="line"><span class="string">'errCode'</span> =&gt; <span class="number">102002</span>,</span><br><span class="line"><span class="string">'errMsg'</span>  =&gt; <span class="string">'Please login first'</span></span><br><span class="line">],</span><br><span class="line"><span class="string">'unknownUser'</span> =&gt; [</span><br><span class="line"><span class="string">'errCode'</span> =&gt; <span class="number">102003</span>,</span><br><span class="line"><span class="string">'errMsg'</span>  =&gt; <span class="string">'The user is not exist'</span></span><br><span class="line">],</span><br><span class="line">];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>注册两个异常类：</p><ul><li>NormalException # 错误信息封装为json</li><li>EmailException  # 发送邮件</li></ul><p><code>NormalException</code>:<br><code>php artisan make:exception NormalException</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Exceptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Common</span>\<span class="title">Status</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Exception</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Throwable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> $exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResponseException constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array           $message</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int             $code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> \Throwable|null $previous</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(array $message, int $code = <span class="number">0</span>, \Throwable $previous = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">isset</span>($message[<span class="string">'errMsg'</span>]) <span class="keyword">or</span> ! <span class="keyword">isset</span>($message[<span class="string">'errCode'</span>])) &#123;</span><br><span class="line"><span class="keyword">return</span> fail(Status::SystemError[<span class="string">'codeException'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">$this</span>-&gt;exception = $message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parent</span>::__construct(<span class="keyword">$this</span>-&gt;exception[<span class="string">'errMsg'</span>], <span class="keyword">$this</span>-&gt;exception[<span class="string">'errCode'</span>], $previous);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常响应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $request</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">($request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fail(<span class="keyword">$this</span>-&gt;exception);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>EmailException</code>:<br><code>php artisan make:exception EmailException</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Exceptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Common</span>\<span class="title">Status</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Exception</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Cache</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Mail</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Redis</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Throwable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> $exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResponseException constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array           $message</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int             $code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> \Throwable|null $previous</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(array $message, int $code = <span class="number">0</span>, \Throwable $previous = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">isset</span>($message[<span class="string">'errMsg'</span>]) <span class="keyword">or</span> ! <span class="keyword">isset</span>($message[<span class="string">'errCode'</span>])) &#123;</span><br><span class="line"><span class="keyword">return</span> fail(Status::SystemError[<span class="string">'codeException'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">$this</span>-&gt;exception = $message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parent</span>::__construct(<span class="keyword">$this</span>-&gt;exception[<span class="string">'errMsg'</span>], <span class="keyword">$this</span>-&gt;exception[<span class="string">'errCode'</span>], $previous);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常响应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $request</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">($request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fail(<span class="keyword">$this</span>-&gt;exception);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">report</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 相同错误码一定间隔内只发送一次</span></span><br><span class="line"><span class="keyword">if</span> (Cache::lock(<span class="keyword">$this</span>-&gt;getCode(), env(<span class="string">'EXCEPTION_MAIL_INTERVAL'</span>, <span class="number">3600</span>))-&gt;get()) &#123;</span><br><span class="line">$tos = explode(<span class="string">','</span>, env(<span class="string">'MAIL_TOS'</span>));</span><br><span class="line">$message = (<span class="keyword">new</span> \App\Mail\<span class="keyword">Exception</span>(</span><br><span class="line"><span class="keyword">$this</span>-&gt;getCode(),</span><br><span class="line"><span class="keyword">$this</span>-&gt;getMessage(),</span><br><span class="line"><span class="keyword">$this</span>-&gt;getTraceAsString()</span><br><span class="line">))-&gt;onConnection(<span class="string">'redis'</span>)-&gt;onQueue(<span class="string">'email'</span>);</span><br><span class="line">Mail::to($tos)-&gt;queue($message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Http/Exceptions/Handler.php</code> 中增加：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理未授权帐号</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">unauthenticated</span><span class="params">($request, AuthenticationException $exception)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fail(Status::Access[<span class="string">'unknownUser'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理参数校验失败</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">convertValidationExceptionToResponse</span><span class="params">(ValidationException $e, $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$detail = $e-&gt;validator-&gt;getMessageBag()-&gt;getMessages();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fail(Status::ClientError[<span class="string">'paramException'</span>], $detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加邮件模板"><a href="#增加邮件模板" class="headerlink" title="增加邮件模板"></a>增加邮件模板</h2><p><code>php artisan make:mail Exception --markdown=emails.exception</code></p><p>修改 <code>app/Mail/Exception.php</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Mail</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Bus</span>\<span class="title">Queueable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Mail</span>\<span class="title">Mailable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">SerializesModels</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Queue</span>\<span class="title">ShouldQueue</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> <span class="keyword">extends</span> <span class="title">Mailable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Queueable</span>, <span class="title">SerializesModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> $code;</span><br><span class="line"><span class="keyword">protected</span> $message;</span><br><span class="line"><span class="keyword">protected</span> $trace;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new message instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数不能是对象，否则不能设置队列发送</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $message</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $trace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($code, $message, $trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;code = $code;</span><br><span class="line"><span class="keyword">$this</span>-&gt;message = $message;</span><br><span class="line"><span class="keyword">$this</span>-&gt;trace = $trace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build the message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;markdown(<span class="string">'emails.exception'</span>)</span><br><span class="line">-&gt;with([</span><br><span class="line"><span class="string">'errCode'</span> =&gt; <span class="keyword">$this</span>-&gt;code,</span><br><span class="line"><span class="string">'errMsg'</span>  =&gt; <span class="keyword">$this</span>-&gt;message,</span><br><span class="line"><span class="string">'trace'</span>   =&gt; <span class="keyword">$this</span>-&gt;trace,</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>resources/views/emails/exception.blade.php</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@component(&apos;mail::message&apos;)</span><br><span class="line"># xxxx-报警邮件</span><br><span class="line"></span><br><span class="line">错误码：&#123;&#123; $errCode &#125;&#125;</span><br><span class="line">错误信息：&#123;&#123; $errMsg &#125;&#125;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">&#123;&#123; $trace &#125;&#125;</span><br><span class="line"></span><br><span class="line">Thanks,&lt;br&gt;</span><br><span class="line">&#123;&#123; config(&apos;app.name&apos;) &#125;&#125;</span><br><span class="line">@endcomponent</span><br></pre></td></tr></table></figure><h2 id="修改-env"><a href="#修改-env" class="headerlink" title="修改.env"></a>修改.env</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CACHE_DRIVER=redis</span><br><span class="line">QUEUE_DRIVER=redis</span><br><span class="line"></span><br><span class="line">MAIL_FROM_ADDRESS=</span><br><span class="line">MAIL_FROM_NAME=</span><br><span class="line">MAIL_TOS=</span><br><span class="line">EXCEPTION_MAIL_INTERVAL=3600</span><br></pre></td></tr></table></figure><h2 id="自定义权限验证"><a href="#自定义权限验证" class="headerlink" title="自定义权限验证"></a>自定义权限验证</h2><p>见：<a href="http://www.helongfei.com/2017/laravel%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/" rel="external nofollow noopener noreferrer" target="_blank">laravel自定义用户权限校验</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;配置-PHPSTORM&quot;&gt;&lt;a href=&quot;#配置-PHPSTOR
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序语言" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
      <category term="框架" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>WEB 攻击手段</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E5%AE%89%E5%85%A8/Web%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5/"/>
    <id>http://yoursite.com/2-开发技能/安全/Web攻击手段/</id>
    <published>2017-12-09T07:09:00.000Z</published>
    <updated>2017-12-09T08:01:12.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h1><p><strong>定义:</strong><br>在 web 网站上执行非法输入的 html 或 js。</p><p><strong>攻击:</strong></p><ol><li>在输入框中输入 js 代码。</li><li>在输入框中输入 html 代码。</li></ol><p><strong>危害:</strong></p><ol><li>获取用户资料（信息、cooike）</li><li>嵌入非法数据等（图片）</li></ol><p><strong>防范:</strong><br>过滤用户输入字符；转义标签（js，html）。</p><blockquote><p>php类库：<a href="http://htmlpurifier.org/" rel="external nofollow noopener noreferrer" target="_blank">htmlpurifier</a></p></blockquote><h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><p><strong>定义：</strong><br>在 web 网站上执行非法注入的 SQL</p><p><strong>攻击：</strong><br>url 上增加 sql</p><p><strong>危害：</strong></p><ol><li>获取数据库数据</li><li>篡改数据库数据</li></ol><p><strong>防范：</strong></p><ol><li>过滤用户输入字符</li><li>使用 PDO 执行 SQL</li></ol><h1 id="OS-命令攻击"><a href="#OS-命令攻击" class="headerlink" title="OS 命令攻击"></a>OS 命令攻击</h1><p><strong>定义：</strong><br>在 Web 上执行非法输入的 OS 命令</p><p><strong>攻击：</strong><br>输入框中输入 OS 命令</p><p><strong>危害：</strong><br>获取服务器信息（<code>/etc/passwd</code>）</p><p><strong>防范：</strong><br>过滤用户输入字符</p><h1 id="跨站请求伪造-CSRF"><a href="#跨站请求伪造-CSRF" class="headerlink" title="跨站请求伪造(CSRF)"></a>跨站请求伪造(CSRF)</h1><p><strong>定义：</strong><br>攻击者盗用了你的身份，以你的名义发送恶意请求。</p><p><strong>攻击：</strong><br>1.受害用户登录受信任网站A，并在本地生成Cookie。<br>2.受害用户在不登出A的情况下，访问危险网站B。</p><p><strong>危害：</strong></p><ol><li>以你名义发送邮件，发消息（例：微博关注未知用户）</li><li>盗取你的账号</li></ol><p><strong>防范：</strong><br>服务端预先生成 token，存在 session 中；客户端（浏览器）在 form 表单中增加请求 token，服务端接受到请求后验证请求 token。（保证用户发起的请求是在本站，而不是在第三方网站）</p><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;跨站脚本攻击-XSS&quot;&gt;&lt;a href=&quot;#跨站脚本攻击-XSS&quot;
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="安全" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Http 协议</title>
    <link href="http://yoursite.com/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http-%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/1-基础知识/计算机网络/http-协议/</id>
    <published>2017-12-08T11:04:00.000Z</published>
    <updated>2018-01-01T08:24:57.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Http-历史版本"><a href="#Http-历史版本" class="headerlink" title="Http 历史版本"></a>Http 历史版本</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议。主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><h2 id="Http0-9"><a href="#Http0-9" class="headerlink" title="Http0.9"></a>Http0.9</h2><p>1991年发布，只有 GET，只能回应 html 格式的字符串。</p><p>请求示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure></p><p>响应示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Http1-0"><a href="#Http1-0" class="headerlink" title="Http1.0"></a>Http1.0</h2><p>1996年5月发布，记载于 <a href="https://www.ietf.org/rfc/rfc1945.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC1945</a>；可以传输任何类型的内容（文本、图像、视频、二进制文件等）</p><p>相对比<code>http0.9</code>增加了：</p><ol><li>POST、HEAD 等请求方法</li><li>状态码</li><li>MIME</li><li>首部字段</li><li>权限认证（Basic）</li><li>字符集</li><li>传输各类型内容</li></ol><p>详细内容请参考 <a href="https://www.ietf.org/rfc/rfc1945.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC1945</a></p><p>请求示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></p><p>响应示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><strong>缺点:</strong><br>每个TCP连接只能发送一个请求。</p><h1 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h1><p>1997年1月发布，最初版是 <a href="https://www.ietf.org/rfc/rfc2068.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC2068</a>；1999年6月发布的修订版 <a href="https://www.ietf.org/rfc/rfc2616.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC2616</a> 沿用至今。</p><p>对比<code>http1.0</code>最大的变化是：</p><ol><li>默认持久连接（<code>keep-alive</code>）</li><li>引入了 <code>pipelining</code>（同一个TCP连接发送多个请求），但是由于服务器是按照请求顺序进行响应，客户端无法确定最优请求顺序，所以未普及</li><li>分块传输编码(<code>chunked</code>)，针对大数据传输操作，把数据切分为若干数据块<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。">[1]</span></a></sup>进行传输（流模式）</li><li>增加了更多的请求方法：OPTIONS,PUT,DELETE,TRACE,CONNECT</li><li>增加了更多的状态码</li><li>可以范围取数据,可实现断点续传下载(<code>range</code>,<code>etag</code>)</li><li>可追踪数据请求链(<code>via</code>)</li><li>增加权限认证</li><li>增加了<code>host</code>首部，使得一台服务器可以支持虚拟主机</li></ol><p><strong>缺点：</strong></p><ol><li>浏览器对同一域名下的持久连接并发有限制，通常是6个</li><li>使用<code>pipelining</code>会造成 <code>Head of line blocking</code></li><li>每次通信都需要传送<code>header</code>，多次请求时大部分请求首部字段不变，会增加传输成本</li></ol><h2 id="URL-URI-URN"><a href="#URL-URI-URN" class="headerlink" title="URL / URI / URN"></a>URL / URI / URN</h2><p><strong>定义</strong><br>uniform resource identifier（统一资源标识符） URI<br>uniform resource locator （统一资源定位符）URL<br>uniform resource name（统一资源名称）URN</p><p><strong>区别</strong><br>URL、URN 是 URI 的子集</p><blockquote><p>URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，<strong>URN定义某事物的身份，而URL提供查找该事物的方法。</strong></p></blockquote><p><img src="/images/2017/11/11/uri.png" alt="URI"></p><h2 id="Http-报文"><a href="#Http-报文" class="headerlink" title="Http 报文"></a>Http 报文</h2><p><img src="/images/2017/12/05/报文结构.png" alt="报文结构"></p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p><img src="/images/2017/12/05/通用首部字段.png" alt="通用首部字段"></p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p><img src="/images/2017/12/05/请求首部字段.png" alt="请求首部字段"></p><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p><img src="/images/2017/12/05/响应首部字段1.png" alt="响应首部字段1"><br><img src="/images/2017/12/05/响应首部字段2.png" alt="响应首部字段2"></p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p><img src="/images/2017/12/05/实体首部字段.png" alt="实体首部字段"></p><h2 id="Http-状态码"><a href="#Http-状态码" class="headerlink" title="Http 状态码"></a>Http 状态码</h2><p><img src="/images/2017/12/05/状态码类别.png" alt="状态码类别"></p><h3 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h3><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td></tr><tr><td>101</td><td>Switching Protocols</td></tr></tbody></table><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>202</td><td>Accepted</td><td></td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td></td></tr><tr><td>204</td><td>No Content</td><td>响应报文中不含主体</td></tr><tr><td>205</td><td>Reset Content</td><td></td></tr><tr><td>206</td><td>Parial Content</td><td>范围请求；响应报文中含有content-range</td></tr></tbody></table><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td></td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久重定向，丢失搜索引擎权重</td></tr><tr><td>302</td><td>Found</td><td>临时重定向</td></tr><tr><td>303</td><td>See other</td><td>有另外的URL，应使用GET去访问另一个URL</td></tr><tr><td>304</td><td>Not Modified</td><td>没有满足客户端的条件请求的响应需要返回，不包含主体</td></tr><tr><td>305</td><td>Use Proxy</td><td></td></tr><tr><td>306</td><td>(Unuesed)</td><td></td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向，不会把POST改为GET</td></tr></tbody></table><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>请求报文存在语法错误</td></tr><tr><td>401</td><td>Unauthorized</td><td>HTTP认证未通过</td></tr><tr><td>402</td><td>Payment Required</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td>请求被拒绝</td></tr><tr><td>404</td><td>Not Found</td><td>未找到请求资源</td></tr><tr><td>405</td><td>Method NOt Allowed</td><td></td></tr><tr><td>406</td><td>Not Acceptable</td><td></td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td></td></tr><tr><td>408</td><td>Request Timeout</td><td></td></tr><tr><td>409</td><td>Conflict</td><td></td></tr><tr><td>410</td><td>Gone</td><td>请求资源被永久性删除</td></tr><tr><td>411</td><td>Length Required</td><td></td></tr><tr><td>412</td><td>Precondition Failed</td><td></td></tr><tr><td>413</td><td>Request Entity Too Large</td><td></td></tr><tr><td>414</td><td>Request-URI Too Long</td><td></td></tr><tr><td>415</td><td>Unsupported Media Type</td><td></td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td></td></tr><tr><td>417</td><td>Expectation Failed</td><td>-</td></tr></tbody></table><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务端在执行请求时发生错误</td></tr><tr><td>501</td><td>Not Implemented</td><td></td></tr><tr><td>502</td><td>Bad Gateway</td><td></td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务器超负载，暂时无法处理请求</td></tr><tr><td>504</td><td>Gateway Timeout</td><td></td></tr><tr><td>505</td><td>Http Version Not Unsupported</td><td>-</td></tr></tbody></table><h2 id="HTTP-追加协议"><a href="#HTTP-追加协议" class="headerlink" title="HTTP 追加协议"></a>HTTP 追加协议</h2><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>Google在2010年发布了 <a href="http://www.chromium.org/spdy" rel="external nofollow noopener noreferrer" target="_blank">SPDY协议</a>；希望在协议层面解决http的一些痛点：</p><ol><li>一条连接发送一条请求</li><li>请求只能从客户端发起</li><li>首部未经压缩</li></ol><p><img src="/images/2017/12/05/spdy的设计.png" alt="SPDY的设计"></p><p><strong>SPDY协议的主要功能有：</strong></p><ol><li>多路复用流（单一TCP连接）</li><li>请求优先级</li><li>压缩Http首部</li><li>支持服务端推送数据到客户端</li><li>服务器主动提示客户端所需资源（过期）</li></ol><h3 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h3><p>Websocket即web浏览器与web服务器之间全双工通信标准。2011年12月11日记载于 <a href="https://www.ietf.org/rfc/rfc6455.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC6455</a>；</p><p>为了实现Websocket通信，在HTTP连接建立之后，需要完成一次握手：</p><p><img src="/images/2017/12/05/websocket通信.png" alt="Websocket通信"></p><p><strong>Websocket的功能：</strong></p><ol><li>服务器推送</li><li>减少通信量（websocket首部信息很小）</li><li>js可调用 <a href="http://www.w3.org/TR/websockets" rel="external nofollow noopener noreferrer" target="_blank">Websocket API</a></li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>2000年5月公布，发布于 <a href="https://www.ietf.org/rfc/rfc2818.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC2818</a>；默认端口443。因为有加密解密，所以访问会比http慢（可接受），并且会消耗服务器cpu资源。</p><h2 id="Http的缺点"><a href="#Http的缺点" class="headerlink" title="Http的缺点"></a>Http的缺点</h2><ol><li>通信使用明文，可能被窃听</li><li>不验证通信方身份，可能被伪装</li><li>无法证明报文的完整性，可能被篡改</li></ol><h2 id="SSL-TLS-协议"><a href="#SSL-TLS-协议" class="headerlink" title="SSL/TLS 协议"></a>SSL/TLS 协议</h2><p>最初是网景设计了 SSL（1.0~3.0）；后来 ITEF 在 SSL3.0 基础上设计了 TLS1.0，目前 TLS 最新版为1.3。</p><p><strong>5次握手：</strong></p><p>第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。<br>第二步，服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。<br>第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。<br>第四步，服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。<br>第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</p><p>整体握手是明文传输。</p><p><strong>会话恢复：</strong></p><ol><li><p>session ID<br>每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p></li><li><p>session ticket<br>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p></li></ol><h2 id="Https的组成"><a href="#Https的组成" class="headerlink" title="Https的组成"></a>Https的组成</h2><blockquote><p>Http + 加密 + 认证 + 完整性保护 = Https</p></blockquote><p>Http直接和TCP通信，Https先和SSL/TLS通信，再由SSL/TLS和TCP通信。<br><img src="/images/2017/12/05/httpvshttps.png" alt="HttpVsHttps"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>采用「对称加密」<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="加密和解密使用同一个密钥；消耗资源少且快">[2]</span></a></sup>和「非对称加密」<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="使用公钥进行加密（发送方），使用私钥进行解密（使用方）；消耗资源多且慢">[3]</span></a></sup>混合加密方式；交换密钥使用「非对称加密」，通信使用「对称加密」。</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>采用数字认证机构与其相关机关颁发的「公开密钥证书」进行认证。</p><ol><li>网站提交公钥给数字认证机构，机构制作为「公开密钥证书」（非对称加密）</li><li>网站服务端把「公开密钥证书」发送给客户端，客户端利用浏览器内置的数字认证机构公钥进行验证（非对称加密）</li><li>验证通过后，客户端和服务端使用公钥进行加密通信（对称加密）</li></ol><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><p>在通信过程中，应用层会发送MAC（Message Authentication Code）报文摘要（MD5等算法）；MAC可以查知报文是否被篡改。</p><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p>2015年5月，发布于 <a href="https://www.ietf.org/rfc/rfc7540.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC7540</a>；基于<code>spdy3.0草案</code>；Http2 可以基于「明文」，也可以基于「TLS」进行通信。</p><p>关于后续版本：<br>HTTP2后取消了小版本，后续的版本会是HTTP3。</p><h2 id="HTTP2的特性"><a href="#HTTP2的特性" class="headerlink" title="HTTP2的特性"></a>HTTP2的特性</h2><p><strong>1. 二进制协议</strong><br><img src="/images/2017/12/08/http2.png" alt="http2"></p><ul><li>length 定义了整个frame（帧）的大小</li><li>type定义frame的类型（一共10种）</li><li>flags用bit位定义一些重要的参数</li><li>stream id用作流控制</li><li>frame payload就是request的正文。</li></ul><p><strong>2. 多路复用的流</strong></p><p><strong>帧</strong>：HTTP2 数据通信的最小单位；例如请求和响应等，消息由一个或多个帧组成。</p><p><strong>流</strong>：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。</p><p>HTTP2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流（并发）。流的多路复用意味着在同一连接中来自各个流的数据包会被混合在一起，Stream Identifier将连接上传输的每个帧都关联到一个“流”。</p><p><strong>3. 流的优先级和依赖性</strong><br>优先级：每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。<br>依赖性：借助于PRIORITY帧，客户端可以告知服务器当前的流依赖于其他哪个流。</p><p><strong>4. header压缩</strong><br>HTTP2 对消息头采用 <a href="https://www.ietf.org/rfc/rfc7541.txt" rel="external nofollow noopener noreferrer" target="_blank">HPACK</a>（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。</p><p>HTTP2 对这些首部采取了压缩策略：</p><ol><li>HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在HTTP2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ol><p><strong>5. 重置消息</strong><br>Http2 通过发送RST_STREAM帧可终止当前传输的消息并重新发送一个新的。</p><p><strong>6. 服务器推送</strong><br>这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。</p><p>服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否需要中断该推送的流。如果不需要的话，客户端可以通过发送一个RST_STREAM帧来中止。</p><p><strong>7. 流量控制</strong><br>类似TCP协议通过sliding window的算法来做流量控制，http2 使用 WINDOW_UPDATE frame 来做流量控制。每个stream都有流量控制，这保证了数据接收方可以只让自己需要的数据被传输。</p><p>只有数据帧会受到流量控制。</p><p><img src="/images/2017/12/08/flow-control.png" alt="Flow Control"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《图解 HTTP》</li><li><a href="https://ye11ow.gitbooks.io/http2-explained/content/part6.html" rel="external nofollow noopener noreferrer" target="_blank">Http2协议</a></li><li><a href="https://github.com/creeperyang/blog/issues/23" rel="external nofollow noopener noreferrer" target="_blank">HTTP2简介和基于HTTP2的Web优化</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" rel="external nofollow noopener noreferrer" target="_blank">图解SSL/TLS协议</a></li></ul><!--以下是脚注--><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">加密和解密使用同一个密钥；消耗资源少且快<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">使用公钥进行加密（发送方），使用私钥进行解密（使用方）；消耗资源多且慢<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Http-历史版本&quot;&gt;&lt;a href=&quot;#Http-历史版本&quot; c
      
    
    </summary>
    
      <category term="1-基础知识" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>常见错误</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2-开发技能/数据库/Mysql/常见错误/</id>
    <published>2017-11-18T10:36:00.000Z</published>
    <updated>2017-12-03T16:04:44.531Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ERROR-1205-HY000-Lock-wait-timeout-exceeded-try-restarting-transaction"><a href="#ERROR-1205-HY000-Lock-wait-timeout-exceeded-try-restarting-transaction" class="headerlink" title="ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction"></a>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</h1><p>原因：<br>select @@autocommit;<br>+————–+<br>| @@autocommit |<br>+————–+<br>| 0            |<br>+————–+<br>没有开启自动提交，导致update一直未commit。</p><p>解决：</p><ol><li>查看是否有慢查SQL</li><li>查看innodb的事务表INNODB_TRX是否有正在锁定的事务线程,有的话看看ID是否在show full processlist里面的sleep线程中，如果是，就证明这个sleep的线程事务一直没有commit或者rollback而是卡住了，我们需要手动kill掉</li><li>开启自动提交: set global autocommit=1;</li></ol><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;ERROR-1205-HY000-Lock-wait-timeou
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>常用函数</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2-开发技能/数据库/Mysql/常用函数/</id>
    <published>2017-11-17T17:32:00.000Z</published>
    <updated>2017-12-03T16:04:44.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="进制转换函数"><a href="#进制转换函数" class="headerlink" title="进制转换函数"></a>进制转换函数</h1><p><code>CONV(N,from_base,to_base)</code> N是要转换的数据，from_base是原进制，to_base是目标进制。</p><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><p><code>substring(column,pos,length)</code>截取字符串.pos开始的位置，length截取的长度<br><code>left(‘string’,length)</code>取左边length个字符<br><code>right(‘string’,length)</code>取右边length个字符</p><h1 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h1><p><code>field(column,’b’,’a’,’c’)</code>显式的排序，按照bac排序</p><h1 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h1><p><code>USING(id)</code> 等于 on(a.id=b.id) //join on条件的缩写</p><h1 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h1><ul><li><code>unix_timestamp(‘2013-04-01’)</code></li><li><code>from_unixtime(‘1364745600’)</code></li></ul><h1 id="ip转换函数"><a href="#ip转换函数" class="headerlink" title="ip转换函数"></a>ip转换函数</h1><ul><li><code>inet_aton(‘192.168.1.1’)</code></li><li><code>inet_ntoa(‘3232235777 ‘)</code></li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;进制转换函数&quot;&gt;&lt;a href=&quot;#进制转换函数&quot; class=&quot;
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>常用SQL</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%B8%B8%E7%94%A8Sql/"/>
    <id>http://yoursite.com/2-开发技能/数据库/Mysql/常用Sql/</id>
    <published>2017-11-17T17:20:00.000Z</published>
    <updated>2017-12-03T16:04:44.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h1><p>gist：<a href="https://gist.github.com/hlf513/035ae964db80e122c262" rel="external nofollow noopener noreferrer" target="_blank">multi_update.php</a></p><h1 id="在线动态抓取SQL"><a href="#在线动态抓取SQL" class="headerlink" title="在线动态抓取SQL"></a>在线动态抓取SQL</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -s 0 -l -w - dst port 3306|strings</span><br></pre></td></tr></table></figure><h1 id="随机一条"><a href="#随机一条" class="headerlink" title="随机一条"></a>随机一条</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.*</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`table`</span> <span class="keyword">AS</span> t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="keyword">RAND</span>() * (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> <span class="string">`table`</span>)) <span class="keyword">AS</span> <span class="keyword">id</span>) <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id &gt;= t2.id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.id <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="导出数据字典"><a href="#导出数据字典" class="headerlink" title="导出数据字典"></a>导出数据字典</h1><p>gist：<a href="https://gist.github.com/hlf513/3ccaf696d3cd335dcaca" rel="external nofollow noopener noreferrer" target="_blank">generator_mysql_dict.php</a></p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>SQL采用内连接（INNER JOIN）实现，更高效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cols <span class="keyword">from</span> <span class="keyword">tables</span> <span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">  <span class="keyword">select</span> pk <span class="keyword">from</span> <span class="keyword">tables</span></span><br><span class="line">    <span class="keyword">where</span> col1 = $col1 <span class="keyword">order</span> <span class="keyword">by</span> col2 <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span></span><br><span class="line">) <span class="keyword">using</span> (pk);</span><br></pre></td></tr></table></figure><h1 id="检查数据表大小"><a href="#检查数据表大小" class="headerlink" title="检查数据表大小"></a>检查数据表大小</h1><ol><li><p>进去指定 schema 数据库（存放了其他的数据库的信息）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></li><li><p>查询所有数据的大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(round(sum(DATA_LENGTH/1024/1024), 2), 'MB')</span><br><span class="line">-&gt; as data from TABLES;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| data |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 6674.48MB |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">16.81</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>查看指定数据库实例的大小，比如说数据库 forexpert</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(round(sum(DATA_LENGTH/1024/1024), 2), 'MB')</span><br><span class="line">-&gt; as data from TABLES where table_schema='forexpert';</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| data |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 6542.30MB |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">7.47</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>查看指定数据库的表的大小，比如说数据库 forexpert 中的 member 表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(round(sum(DATA_LENGTH/1024/1024),2),'MB') as data</span><br><span class="line">-&gt; from TABLES where table_schema='forexpert'</span><br><span class="line">-&gt; and table_name='member';</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| data |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 2.52MB |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">1.88</span> sec)</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用-OR-时-使用-union-all-替换"><a href="#使用-OR-时-使用-union-all-替换" class="headerlink" title="使用 OR 时,使用 union all 替换"></a>使用 OR 时,使用 union all 替换</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">union</span> all <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="导入导出数据"><a href="#导入导出数据" class="headerlink" title="导入导出数据"></a>导入导出数据</h1><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><ul><li><p>常规使用 values 导入<br>字段顺序必须一致</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> ~/dump.sql</span><br><span class="line">或</span><br><span class="line">mysql -u root -p database_name &lt; ~/dump.sql</span><br></pre></td></tr></table></figure></li><li><p>使用 load data infile<br>方式一：直接导入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#$1,数据文件的绝对地址</span></span><br><span class="line">username=<span class="string">'root'</span></span><br><span class="line">password=<span class="string">''</span></span><br><span class="line">host=<span class="string">'127.0.0.1'</span></span><br><span class="line">database=<span class="string">"thirdsite_grab"</span></span><br><span class="line">table=<span class="string">"resumes_contacts"</span></span><br><span class="line">field=<span class="string">"src,src_no,resume_updated_at,name,phone,tel,email,create_at,updated_at,is_deleted,status,icdc_id,error_msg,source,type"</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">mysql -u <span class="variable">$username</span> -p<span class="variable">$passwoed</span> -h <span class="variable">$host</span> <span class="variable">$database</span> -e <span class="string">"load data local infile '<span class="variable">$1</span>' replace into table <span class="variable">$table</span> (<span class="variable">$field</span>)"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span><span class="string">'不存在'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>方式二：不更新索引，加快导入速度</p><ol><li>执行 <code>FLUSH TABLES</code> 语句或命令 <code>mysqladmin flush-tables</code></li><li>使用<code>myisamchk –keys-used=0 -rq /path/to/db/tbl_name</code>。这将从表中取消所有索引的使用</li><li>用<code>LOAD DATA INFILE</code>把数据插入到表中</li><li>用<code>myisamchk -r -q /path/to/db/tbl_name</code>重新创建索引.<br>这将在写入磁盘前在内存中创建索引树，并且它更快，因为避免了大量磁盘搜索。结果索引树也被完美地平衡</li><li>执行<code>FLUSH TABLES</code>语句或<code>mysqladmin flush-tables</code>命令。</li></ol><p>更简洁的方式二：<br>使用这种方式，不需要执行<code>FLUSH TABLES</code>。</p><ol><li>使用<code>ALTER TABLE tbl_name DISABLE KEYS</code>代替<code>myisamchk –keys-used=0 -rq/path/to/db/tbl_name</code>，</li><li>使用<code>ALTER TABLE tbl_name ENABLE KEYS</code>代替<code>myisamchk -r -q/path/to/db/tbl_name</code>。</li></ol></li></ul><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><ol><li><p>导出 sql</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uxxx -pxxx -h127.0.0.1 database_name table_name -t --<span class="built_in">where</span>=<span class="string">"where条件"</span> &gt; dump.sql</span><br></pre></td></tr></table></figure></li><li><p>导出文本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">username=<span class="string">'root'</span></span><br><span class="line">password=<span class="string">''</span></span><br><span class="line">host=<span class="string">'127.0.0.1'</span></span><br><span class="line">database=<span class="string">"thirdsite_grab"</span></span><br><span class="line">table=<span class="string">"resumes_contacts"</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">save_path=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">save_path=/tmp/export.data</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$save_path</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'删除旧文件'</span></span><br><span class="line">`rm <span class="variable">$save_path</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'保存路径为'</span><span class="variable">$save_path</span></span><br><span class="line">mysql -u <span class="variable">$user</span> -p<span class="variable">$password</span> <span class="variable">$database</span> -h <span class="variable">$host</span> -Ne <span class="string">"set names UTF8;select <span class="variable">$field</span> from <span class="variable">$table</span>"</span> &gt; <span class="variable">$save_path</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="删除重复的数据"><a href="#删除重复的数据" class="headerlink" title="删除重复的数据"></a>删除重复的数据</h1><p>demo：表名；<br>id：自增 ID；<br>site：具有相同数据的列</p><h2 id="只有-crud-权限"><a href="#只有-crud-权限" class="headerlink" title="只有 crud 权限"></a>只有 crud 权限</h2><ul><li><p>删除 ID 大的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> a <span class="keyword">using</span> demo <span class="keyword">as</span> a, demo <span class="keyword">as</span> b <span class="keyword">where</span> (a.id &gt; b.id) <span class="keyword">and</span> (a.site = b.site);</span><br></pre></td></tr></table></figure></li><li><p>删除 ID 小的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> a <span class="keyword">using</span> demo <span class="keyword">as</span> a, demo <span class="keyword">as</span> b <span class="keyword">where</span> (a.id &lt; b.id) <span class="keyword">and</span> (a.site = b.site);</span><br></pre></td></tr></table></figure></li></ul><h2 id="有索引权限"><a href="#有索引权限" class="headerlink" title="有索引权限"></a>有索引权限</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//自动删除重复数据（id 大的删除）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">ignore</span> <span class="keyword">table</span> demo <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> ukey (site);</span><br><span class="line">//删除刚建立的索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo <span class="keyword">drop</span> <span class="keyword">index</span> ukey;</span><br></pre></td></tr></table></figure><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;批量更新&quot;&gt;&lt;a href=&quot;#批量更新&quot; class=&quot;head
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>运维指南</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E8%BF%90%E7%BB%B4%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2-开发技能/数据库/Mysql/运维指南/</id>
    <published>2017-11-17T16:37:00.000Z</published>
    <updated>2017-12-03T16:04:44.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="系统与软件"><a href="#系统与软件" class="headerlink" title="系统与软件"></a>系统与软件</h1><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul><li>一般选择RHEL、CentOS</li><li>拒绝使用32位系统，升级到64位</li><li>不追新，稳定、高性能压倒一切</li><li>版本一致，批量部署，管理方便</li><li>/tmp使用/dev/shm的tmpfs</li></ul><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><ul><li>IO调度：deadline，noop，反正不要cfq</li><li>VM管理：vm.swappiness=0</li></ul><h2 id="文件系统-xfs-zfs"><a href="#文件系统-xfs-zfs" class="headerlink" title="文件系统:xfs/zfs"></a>文件系统:xfs/zfs</h2><ul><li>全B+树，高效</li><li>分配组，提高并发度</li><li>延迟分配，减少IO</li><li>mount：nobarrier、data=ordered,writeback</li></ul><h2 id="Mysql使用内存盘（挂载）"><a href="#Mysql使用内存盘（挂载）" class="headerlink" title="Mysql使用内存盘（挂载）"></a>Mysql使用内存盘（挂载）</h2><p>将 MYSQL 目录迁移到 4G 的内存磁盘<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/ramdisk</span><br><span class="line">sudo mount -t tmpfs -o size=4000M tmpfs /mnt/ramdisk/</span><br><span class="line">mv /var/lib/mysql /mnt/ramdisk/mysql</span><br><span class="line">ln -s /tmp/ramdisk/mysql /var/lib/mysql</span><br><span class="line">chown mysql:mysql mysql</span><br></pre></td></tr></table></figure></p><h2 id="是否关闭swap？"><a href="#是否关闭swap？" class="headerlink" title="是否关闭swap？"></a>是否关闭swap？</h2><p>mysql 专用服务器则关闭 swap；否则保证innodb_buffer_pool_size足够大</p><h2 id="内存使用考量"><a href="#内存使用考量" class="headerlink" title="内存使用考量"></a>内存使用考量</h2><ul><li>理论上，内存越大，越多数据读取发生在内存，效率越高</li><li>Query cache的使用</li><li>如果前端请求重复度不高，或者应用层已经充分缓存重复请求，query cache不必设置很大，甚至可以不设置。</li><li>如果前端请求重复度较高，无应用层缓存，query cache是一个很好的偷懒选择</li><li>对于中等以下规模数据库应用，偷懒不是一个坏选择。</li><li>如果确认使用query cache，记得定时清理碎片，flush query cache.</li><li>要考虑到现实的硬件资源和瓶颈分布</li><li>学会理解热点数据，并将热点数据尽可能内存化</li><li>所谓热点数据，就是最多被访问的数据。</li><li>通常数据库访问是不平均的，少数数据被频繁读写，而更多数据鲜有读写。</li><li>学会制定不同的热点数据规则，并测算指标。</li><li>热点数据规模，理论上，热点数据越少越好，这样可以更好的满足业务的增长趋势。</li><li>响应满足度，对响应的满足率越高越好。</li><li>比如依据最后更新时间，总访问量，回访次数等指标定义热点数据，并测算不同定义模式下的热点数据规模</li></ul><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><p><strong>vm.swappiness</strong><br>rhel6及以下设置为0 ；rhel7以上设置为10（0 可能会被 oom kill 掉）</p><p><strong>/sys/block/sdX/queue/scheduler</strong></p><p>内核默认的 cfq 很烂，不要使用<br>普通的 sas 盘建议使用 deadline策略<br>ssd 使用 noop 或者 deadline（还可以设置 io scheduler ）</p><p><strong>文件系统</strong></p><p>首选xfs，其次ext4，zfs也很不错，但在linux下不是那么可靠(relserfs也不错，但作者被抓，没人维护，不建议使用)<br>高 io 下使用 xfs，不要使用 ext4（会有瓶颈）因为：ext4下%util 基本到了100%，再也上不去了；而 xfs 还有上升的空间</p><p><strong>文件系统数据结构</strong><br>xfs 目录内容 b+tree，文件分配b+tree<br>ext4 -&gt; htree（特殊 b 树）-&gt; extents/bitmap<br>ext3 -&gt; htree -&gt; bitmap</p><p><strong>查看现在文件系统的命令</strong><br>df -HT</p><h1 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h1><p><a href="http://imysql.com/my_cnf_generator" rel="external nofollow noopener noreferrer" target="_blank">老叶的 my.cnf 生成器</a></p><h2 id="myisam-参数"><a href="#myisam-参数" class="headerlink" title="myisam 参数"></a>myisam 参数</h2><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<br>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p><p>MyISAM的锁调度</p><p>MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM的调度行为。</p><p>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</p><p>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</p><p>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</p><h2 id="关注的参数"><a href="#关注的参数" class="headerlink" title="关注的参数"></a>关注的参数</h2><h3 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h3><ul><li><p>interactive_timeout/wait_timeout<br>断开活跃连接超时的时间/断开不活跃连接的超时时间<br>前者数值基本上继承与后者;建议两者设置一样.<br>1.有连接池，timeout 调大一些，或者默认值<br>2.无连接池，建议设置300以内（理论是越小越好，真正的值根据业务b）</p></li><li><p>open_files_limit<br>此选项不够时的错误：<br>can’t  open file : \test\…..(error:24)<br>sh&gt; perror 24 #查看错误24的含义<br>OS error code 24: too many open files<br>如何调整？</p><ol><li>调整此参数的限制</li><li>ulimit -n 修改内核级别的限制</li></ol></li><li><p>max_connections<br>连接数不够用，建议业务方进行优化，保证连接数可用，不是一味的调大连接数<br>有可能会导致系统雪崩/oom_killer<br>建议</p><ol><li>临时调高数量，让业务优化sql</li><li>调低 timeout 的值</li></ol></li><li><p>和 open_files_limit类似的问题<br>问题：<br><code>Can not connect to Mysql Server</code><br><code>1135: Can&#39;t create a new thread(errno 12);if you are not out of available memory, you can consult the manual for a possible OS-dependent bug</code><br> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.d/90-nproc.conf</span><br><span class="line">nproc 改为 65536</span><br><span class="line"> 或者</span><br><span class="line">vi /etc/bashrc</span><br><span class="line">ulimit -u 65536</span><br></pre></td></tr></table></figure></li><li><p>thread_pool<br>官方版本不支持此功能（线程池）；可以使用 percona,mariadb 分支版本<br><a href="http://imysql.com/2014/07/02/percona-thread-pool-benchmark-testing.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2014/07/02/percona-thread-pool-benchmark-testing.shtml</a><br>线程池作用：让线程分组去处理，而不是阻塞等待处理</p></li></ul><h3 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h3><p><img src="/images/2017/11/18/memory.png" alt="memory"></p><ul><li>tmp_table_size/max_heap_table_size<br>不要把 tmp_table_size 、max_heap_table_size（这个是会话级别） 设置过大，建议不高于100M</li></ul><h3 id="innodb参数"><a href="#innodb参数" class="headerlink" title="innodb参数"></a>innodb参数</h3><ul><li><p>innodb_buffer_pool<br>建议设置50-70%，缓存大量的脏数据，事务信息，锁信息等；保证不会 oom 的前提下，可以设置80%或更高；非专业人士，不建议设置过高。<br>设置太小的话：</p><ol><li>tps 很低，大量等待</li><li>可能会 table full</li><li>锁不够用</li></ol></li><li><p>innodb_data_file_path<br>默认只有10m，ibdata1初始化时，至少设置1G<br>参考： <a href="http://imysql.com/2010/06/01/mysql-faq-what-contains-with-ibdata1.html" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2010/06/01/mysql-faq-what-contains-with-ibdata1.html</a><br>Innodb 共享表空间文件 ibdata1 中存储了以下几部分信息：</p><ol><li>Data dictionary</li><li>Double write buffer</li><li>Insert buffer</li><li>Rollback segments</li><li>UNDO space</li></ol><p>因此在初始化ibdata1时，最好设置大一些，这样可以避免高并发下导致ibdata1急剧增大，大大影响性能</p></li><li><p>innodb_flush_log_at_trx_commit<br>0\1\2\<br>每秒\每事务\0和1的折中（刷新 log入磁盘）</p></li><li><p>transaction_isolation<br>事务隔离级别：默认是 RR（可重复读），建议使用 RR<br>不建议使用 RC，RC并发提高了，锁等待很严重，tpmc 并没提高多少</p></li><li><p>innodb_log_file_size &amp; innodb_log_buffer_size<br>若1分钟产生10m事务，则 log_buffer 设置64m；100m事务则设置512m；一般不建议超过512m；若发生 innodb_log_buffer_wait_free事件，则需要调整<br>不易设置过大，因为若 mysql 挂掉，重启时会读 log恢复；越大恢复越慢</p></li><li><p>innodb_file_per_table=1<br>为每个表分别创建 InnoDB FILE；防止ibdata1 文件过大</p></li><li><p>innodb_buffer_pool_size<br>将数据完全保存在innodb_buffer_pool_size（内存）中</p><ul><li>如何确定取值？<pre><code>mysql&gt; SHOW GLOBAL STATUS LIKE &apos;innodb_buffer_pool_pages_%&apos;;//Innodb_buffer_pool_pages_free = 0 则说明需要增加//innodb_additional_mem_pool_size = 1/200 of buffer_pool//innodb_max_dirty_pages_pct 80%</code></pre></li></ul></li><li><p>innodb_log_file_size<br>推荐innodb_log_file_size 设置为 0.25 * innodb_buffer_pool_size<br>如果用 1G 的 innodb_log_file_size ，假如服务器宕机，需要 10 分钟来恢复。</p></li><li><p>innodb_flush_log_at_trx_commit<br>这个选项和写磁盘操作密切相关：</p><pre><code>innodb_flush_log_at_trx_commit = 1 则每次修改写入磁盘innodb_flush_log_at_trx_commit = 0/2 每秒写入磁盘</code></pre><p>如果你的应用不涉及很高的安全性 (金融系统)，或者基础架构足够安全，或者 事务都很小，都可以用 0 或者 2 来降低磁盘操作。</p></li><li><p>innodb_flush_method=O_DIRECT<br>避免双写入缓冲</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>general_log<br>通常不打开，否则会使文件很大，会带来mysql 事务性能下降<br>因为： 记录全部 general log 时 tpmc 大约是不打开 log 时的73.28%，而记录全部 slow log 时的 tpmc 大约是不打开 log 时的59.53%<br><a href="http://imysql.com/2014/09/01/mysql-faq-impact-of-generallog.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2014/09/01/mysql-faq-impact-of-generallog.shtml</a></p></li><li><p>innodb_max_dirty_pages_pct</p></li><li><p>log_bin<br>一定要打开，数据丢失可找回；影响：性能下降46%，启用赋值或要求数据灾难时损失最小，必须开启该功能，这时考虑 log_bin与数据隔离或者使用 io 能力强设备，可提高响应，密集写很高的应用要启用 ssd 设备，来缓解该类压力<br>binlog 是顺序写；可用 raid0或1来专门存 binlog.<br>主从结构时，从的 bin_log 也打开</p></li><li><p>long_query_time<br>不要设置为0 （0的作用：每个 sql 记录和 general_log 的作用相当）；可以设置为0.01，0.1等其他值</p></li><li><p>sync_binlog<br>需要很高的数据一致性，设置为1（每个 sql 都要刷入 binlog）；不特别需要时，可设置为2，3，10等更高；不需要时设为0</p></li><li><p>log_slow_query<br>分析慢查询用</p></li><li><p>table_open_cache</p></li><li><p>key_buffer_size</p></li><li><p>query_cache_size</p></li><li><p>memlock</p></li></ul><h1 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h1><p><strong>如何预热？</strong><br>基于 innodb_buffer_pool 的备份和加载；因为数据只有在执行一次，才能加载到innodb_buffer_pool</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>性能差不多，关键是可靠性</li><li>上线前烤机测试非常重要</li><li>监控预警可有效预防故障</li><li>避免使用外部阵列</li><li>最好是2U机型，并且配备RAID卡(with BBU)</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>所有磁盘组建大阵列，不降低IOPS</li><li>默认阵列级别为：raid 1+0</li><li>结合业务特征设置主机名，唯一命名</li><li>合理利用hosts/dns，可用于应用授权管理</li><li>master和slave命名区分开</li><li>/tmp使用/dev/shm &amp; tmpfs</li><li>部署基本工具包：sysstat、oprofile等</li></ul><h2 id="BIOS-设置优化"><a href="#BIOS-设置优化" class="headerlink" title="BIOS 设置优化"></a>BIOS 设置优化</h2><ul><li>System Profile（系统配置）选择Performance Per Watt Optimized(DAPC)，发挥最大功耗性能，充分利用 cpu</li><li>Memory Frequency（内存频率）选择Maximum Performance（最佳性能）</li><li>C1E，允许在处理器处于闲置状态时启用或禁用处理器切换至最低性能状态，建议关闭 （默认启用）</li><li>C States（C状态），允许启用或禁用处理器在所有可用电源状态下运行，建议关闭（默 认启用）</li></ul><h2 id="IO-子系统优化"><a href="#IO-子系统优化" class="headerlink" title="IO 子系统优化"></a>IO 子系统优化</h2><ul><li>专业的阵列卡配备CACHE（大部分是1G，4G 很少）及BBU模块（给缓存提供后备电量），提高IOPS</li><li>cache 策略设置写策略为WB（wirte back），或者FORCE WB，禁用WT策略<br>WB: 让数据先写入 cache，再写回磁盘</li><li>阵列卡配置关闭预读，没必要预读，那点宝贵的CACHE用来做写缓存</li><li>阵列级别使用RAID 1+0，而不是RAID 5 (1+0的ios写性能比5高)</li><li>关闭物理磁盘cache策略（非阵列卡的 cache），防止断电时丢数据</li><li>使用高转速硬盘，不使用低转速盘<br>最低1w 转，最好是1.5w</li><li>使用SSD或者PCIe-SSD盘<br>ssd性能比 sata 硬盘提升几百倍<br>pcle-ssd 提升上万倍</li></ul><h1 id="监控、安全与备份"><a href="#监控、安全与备份" class="headerlink" title="监控、安全与备份"></a>监控、安全与备份</h1><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul><li>监控与数据分析是一切优化的基础。</li><li>没有运营数据监测就不要妄谈优化！</li><li>监控要注意不要产生太多额外的负载，不要因监控带来太多额外系统开销</li></ul><h3 id="监控软件"><a href="#监控软件" class="headerlink" title="监控软件"></a>监控软件</h3><p>nagios、zabbix、cacti</p><h3 id="监控体系"><a href="#监控体系" class="headerlink" title="监控体系"></a>监控体系</h3><h4 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h4><p>服务器资源监控</p><ul><li>Cpu, 内存，硬盘空间，i/o压力</li><li>设置阈值报警</li></ul><p>服务器流量监控</p><ul><li>外网流量，内网流量</li><li>设置阈值报警</li></ul><p>连接状态监控</p><ul><li>Show processlist 设置阈值，每分钟监测，超过阈值记录</li></ul><h4 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h4><p>慢查询监控</p><ul><li>慢查询日志</li><li>如果存在多台数据库服务器，应有汇总查阅机制。</li></ul><p>请求错误监控</p><ul><li>高频繁应用中，会出现偶发性数据库连接错误或执行错误，将错误信息记录到日志，查看每日的比例变化。</li><li>偶发性错误，如果数量极少，可以不用处理，但是需时常监控其趋势。</li><li>会存在恶意输入内容，输入边界限定缺乏导致执行出错，需基于此防止恶意入侵探测行为。</li></ul><p>微慢查询监控</p><ul><li>高并发环境里，超过0.01秒的查询请求都应该关注一下。</li></ul><p>频繁度监控</p><ul><li>写操作，基于binlog，定期分析。</li><li>读操作，在前端db封装代码中增加抽样日志，并输出执行时间。</li><li>分析请求频繁度是开发架构 进一步优化的基础</li><li>最好的优化就是减少请求次数！</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><ul><li>重点：先可用性而后才是性能</li><li>关闭公网，只留私网</li><li>密码足够长度、复杂度</li><li>开启iptables策略</li><li>只开放必要的授权许可</li><li>使用普通账号管理mysqld(结合sudo)</li><li>集成定期安全检查到监控系统中</li></ul><h3 id="性能与安全性考量"><a href="#性能与安全性考量" class="headerlink" title="性能与安全性考量"></a>性能与安全性考量</h3><p>数据提交方式</p><ul><li>innodb_flush_log_at_trx_commit = 1 每次自动提交，安全性高，i/o压力大</li><li>innodb_flush_log_at_trx_commit = 2 每秒自动提交，安全性略有影响，i/o承载强。</li></ul><p>日志同步</p><ul><li>Sync-binlog =1 每条自动更新，安全性高，i/o压力大</li><li>Sync-binlog = 0 根据缓存设置情况自动更新，存在丢失数据和同步延迟风险，i/o承载力强。</li><li>个人建议保存binlog日志文件，便于追溯 更新操作和系统恢复。</li><li>如对日志文件的i/o压力有担心，在内存宽裕的情况下，可考虑将binlog 写入到诸如 /dev/shm 这样的内存映射分区，并定时将旧有的binlog转移到物理硬盘。</li></ul><p>性能与安全本身存在相悖的情况，需要在业务诉求层面决定取舍</p><ul><li>学会区分什么场合侧重性能，什么场合侧重安全</li><li>学会将不同安全等级的数据库用不同策略管理</li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><ul><li>利用slave执行备份</li><li>定期全备+及时增备</li><li>不定期随机做恢复测试</li><li>二进制内容备份使用 –hex-blob</li><li>备份方式：mysqldump VS XtraBackup</li><li>如何快速备份/恢复？(并发？快照？)</li><li>如何执行在线热备<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction或Xtrabackup</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>Keepalived + LVS</li><li>Heartbeat + LVS</li><li>Master + Slave</li><li>多Master共享存储</li></ul><h2 id="故障转移处理"><a href="#故障转移处理" class="headerlink" title="故障转移处理"></a>故障转移处理</h2><p><strong>要点</strong></p><ul><li>程序与数据库的连接，基于虚地址而非真实ip，由负载均衡系统监控。</li><li>保持主从结构的简单化，否则很难做到故障点摘除。</li></ul><p><strong>思考方式</strong></p><ul><li>遍历对服务器集群的任何一台服务器，前端web，中间件，监控，缓存，db等等，假设该服务器出现故障，系统是否会出现异常？用户访问是否会出现异常。</li><li>目标：任意一台服务器崩溃，负载和数据操作均会很短时间内自动转移到其他服务器，不会影响业务的正常进行。不会造成恶性的数据丢失。（哪些是可以丢失的，哪些是不能丢失的）</li></ul><p><strong>常见故障</strong></p><ul><li>复制报错：主键冲突</li><li>硬件、系统崩溃：数据页损坏</li><li>误操作：数据误删除</li><li>硬件故障：阵列卡(掉线、IO性能下降)、CPU、内存</li></ul><h1 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h1><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>tpcc、sysbench<br>现在测试建议使用 tpcc，不使用 sysbench（因为有一定的局限性）</p><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>mysqlslap、前端加压</p><h1 id="存储-写入压力优化"><a href="#存储-写入压力优化" class="headerlink" title="存储/写入压力优化"></a>存储/写入压力优化</h1><ul><li>顺序读写性能远高于随机读写</li><li>将顺序写数据和随机读写数据分成不同的物理磁盘进行，有助于i/o压力的疏解<ul><li>数据库文件涉及索引等内容，写入是随即写</li><li>binlog文件是顺序写</li><li>淘宝数据库存储优化是这样处理的</li></ul></li><li>部分安全要求不高的写入操作可以用 /dev/shm 分区存储，简单变成内存写。</li><li>多块物理硬盘做raid10，可以提升写入能力</li><li>关键存储设备优化，善于比对不同存储介质的压力测试数据。<ul><li>例如fusion-io在新浪和淘宝都有较多使用。</li></ul></li><li>涉及必须存储较为庞大的数据量时<ul><li>压缩存储，可以通过增加cpu开销（压缩算法）减少i/o压力。前提是你确认cpu相对空闲而i/o压力很大。 新浪微博就是压缩存储的典范。</li><li>通过md5去重存储，案例是QQ的文件共享，以及dropbox这样的共享服务，如果你上传的是一个别人已有的文件，计算md5后，直接通过md5定位到原有文件，这样可以极大减少存储量。涉及文件共享，头像共享，相册等应用，通过这种方法可以减少超过70%的存储规模，对硬件资源的节省是相当巨大的。缺点是，删除文件需要甄别该md5是否有其他人使用。 去重存储，用户量越多，上传文件越多，效率越高！</li><li>文件尽量不要存储到数据库内。尽量使用独立的文件系统存储，该话题不展开。</li></ul></li></ul><h1 id="工具集合"><a href="#工具集合" class="headerlink" title="工具集合"></a>工具集合</h1><h2 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h2><ul><li>systemtap</li><li>sar</li><li>gdb</li><li>gcore</li><li>oprofile</li><li>pmp (Poor Man’s Profiler)</li><li>dstat</li></ul><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul><li>Xtrabackup<br>备份出来的数据，可以导入另外一个库，只要制定配置文件就行</li><li>ioprofile</li><li>pt-online-schema-change</li><li>pt-table-checksum</li><li>pt-query-digest + Box Anemometer/Query-Digest-UI – 分析 slow log<br>index_ratio 是 digest 的一个指标，意思是：总共扫描的记录数+最终返回的结果记录数</li><li>mysqldumpslow – 分析 slow log</li><li>pt-ioprofile – 查看哪个数据库读写频繁</li></ul><h1 id="开发人员行为"><a href="#开发人员行为" class="headerlink" title="开发人员行为"></a>开发人员行为</h1><ul><li>批量导入、导出数据须提前通知DBA，请求协助观察</li><li>推广活动或上线新功能须提前通知DBA，请求压力评估</li><li>不使用SUPER权限连接数据库</li><li>单表多次ALTER操作必须合并为一次操作</li><li>数据库DDL及重要SQL及早提交DBA评审</li><li>重要业务库须告知DBA重要等级、数据备份及时性要求</li><li>不在业务高峰期批量更新、查询数据库</li><li>提交线上DDL需求，所有SQL语句须有备注说明</li></ul><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><ul><li>启用log_queries_not_using_indexes</li><li>设置long_query_time为最小值</li><li>定期检查分析slow log</li><li>授权和生产环境一致</li><li>关闭Query Cache</li><li>设置较小InnoDB Buffer Pool、key buffer size</li><li>数据量不能太少，否则有些性能问题无法提前规避</li></ul><h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><ul><li>分配内存越多越好，可能导致OS Swap<br>专用服务器，禁用 swap; 考虑 numa 也禁</li><li>session级内存分配过大，导致OOM</li><li>索引越多越好，可能导致更多IO</li><li>Qcache设置过大，实际效果差(建议关闭)</li><li>认为MyISAM的只读效率远高于InnoDB(不一定)</li><li>过度优化，反而带来成本的上升<br>（改业务逻辑，改 sql，买昂贵的 io 设备，但实际上多加几级 cache 就可以解决）</li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;系统与软件&quot;&gt;&lt;a href=&quot;#系统与软件&quot; class=&quot;he
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2-开发技能/数据库/Mysql/性能优化/</id>
    <published>2017-11-17T14:20:00.000Z</published>
    <updated>2017-12-03T16:04:44.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h1><ul><li>第一步，完成数据库查询的优化，需要理解索引结构，才能学会判断影响结果集。而影响结果集对查询效率线性相关，掌握这一点，编写数据查询语句就很容易判断系统开销，了解业务压力趋势。</li><li>第二步，在SQL语句已经足够优化的基础上，学会对数据库整体状况的分析，能够对异常和负载的波动有正确的认识和解读；能够对系统资源的分配和瓶颈有正确的认识。学会通过监控和数据来进行系统的评估和优化方案设计，杜绝拍脑袋，学会抓大放小，把握要点的处理方法。</li><li>第三步，在彻底掌握数据库语句优化和运维优化的基础上，学会分布式架构设计，掌握复杂，大容量数据库系统的搭建方法。</li></ul><h1 id="优化SQL"><a href="#优化SQL" class="headerlink" title="优化SQL"></a>优化SQL</h1><h2 id="建立慢查询优化系统"><a href="#建立慢查询优化系统" class="headerlink" title="建立慢查询优化系统"></a>建立慢查询优化系统</h2><p>利用 <a href="https://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html" rel="external nofollow noopener noreferrer" target="_blank">pt-query-digest</a> 定期分析slow query log，并结合 <a href="https://github.com/box/Anemometer" rel="external nofollow noopener noreferrer" target="_blank">Box Anemometer</a> 构建slow query log分析及优化系统。</p><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>只选择自己需要的列，不要盲目的使用* ，因为不需要的列可能会导致内存 buffer pool 被这些“无效”数据把真正的热点数据给洗出去了（尤其有 text/blob 列时）</p><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><p>要把过滤性最大（不一定是数据量最小哦，而是只加了WHERE条件后过滤性最大的那个）的表选为驱动表。此外，如果JOIN之后有排序，排序字段一定要属于驱动表，才能利用驱动表上的索引完成排序。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>绝大多数情况下，排序的代价通常要来的更高，因此如果看到执行计划中有 Using filesort，优先创建排序索引吧。</p><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>详情见：<a href="http://dev.mysql.com/doc/refman/5.6/en/explain-output.html#explain-join-types" rel="external nofollow noopener noreferrer" target="_blank">mysql5.6 explain</a></p><p>结果解析：</p><table><thead><tr><th>字段名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>ALL</td><td>表示预计会进行全表扫描（full table scan）。通常全表扫描的代价是比较大的，建议创建适当的索引，通过索引检索避免全表扫描。此外，全索引扫描（full index scan）的代价有时候是比全表扫描还要高的，除非是基于InnoDB表的主键索引扫描。</td></tr><tr><td>Extra</td><td>Using temporary</td><td>表示需要创建临时表以满足需求，通常是因为GROUP BY的列没有索引，或者GROUP BY和ORDER BY的列不一样，也需要创建临时表，建议添加适当的索引。</td></tr><tr><td></td><td>Using filesort</td><td>表示无法利用索引完成排序，也有可能是因为多表连接时，排序字段不是驱动表中的字段，因此也没办法利用索引完成排序，建议添加适当的索引。</td></tr><tr><td></td><td>Using where</td><td>通常是因为全表扫描或全索引扫描时（type 列显示为 ALL 或 index），又加上了WHERE条件，建议添加适当的索引。</td></tr></tbody></table><h2 id="查询-优化影响结果集"><a href="#查询-优化影响结果集" class="headerlink" title="查询/优化影响结果集"></a>查询/优化影响结果集</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li>通过 Explain 分析 SQL，查看 rows 列内容</li><li>通过慢查询日志的Rows_examined: 后面的数字</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>核心：减少影响结果集数目</p><ul><li>基于影响结果集的理解去优化，不论从数据结构，代码，还是涉及产品策略上，都需要贯彻下去。</li><li>涉及 limit $start,$num的搜索，如果$start巨大，则影响结果集巨大，搜索效率会非常难过低，尽量用其他方式改写为 limit 0,$num； 确系无法改写的情况下，先从索引结构中获得 limit $start,$num 或limit $start,1 ；再用in操作或基于索引序的 limit 0,$num 二次搜索。</li><li>避免所有锁表的情况（比如 delete 操作无索引时）</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="实时排行榜"><a href="#实时排行榜" class="headerlink" title="实时排行榜"></a>实时排行榜</h4><p><strong>背景：</strong> 用户提交游戏积分，显示实时排名。</p><p><strong>原方案：</strong><br>设置积分区间，每个区间增加数据统计字段；每次都只 count 本区间的名次，再加上前面所有区间的总和。</p><ol><li>提交积分是插入记录，略，</li><li>select count(*) from jifen where gameid=$gameid and fenshu&gt;$fenshu</li></ol><p><strong>问题与挑战：</strong><br>即便索引是 gameid+fenshu 复合索引，涉及count操作，当分数较低时，影响结果集巨大，查询效率缓慢，高峰期会导致连接过多。</p><p><strong>优化思路：</strong><br>SQL 优化<br>减少影响结果集，又要取得实时数据，单纯从SQL上考虑，不太有方法。</p><p><strong>方案1：</strong><br>逻辑优化</p><ol><li>将游戏积分预定义分成数个积分断点，然后分成积分区间，原始状态，每个区间设置一个统计数字项，初始为0。</li><li>每次积分提交时，先确定该分数属于哪两个区间之间，这个操作非常简单，因为区间是预定义的，而且数量很少，只需遍历即可，找到最该分数符合的区间，该区间的统计数字项（独立字段，可用内存处理，异步回写数据库或文件）+1。 记录该区间上边界数字为$duandian。SQL:  select count(*) from jifen where gameid=$gameid and fenshu&gt;$fenshu and fenshu&lt;$duandian，如果处于第一区间，则无需$duandian，这样因为第一区间本身也是最好的成绩，影响结果集不会很多。 通过该SQL获得其在该区间的名次。获取前面区间的总数总和。（该数字是直接从上述提到的区间统计数字获取，不需要进行count操作）将区间内名次+前区间的统计数字和，获得总名次。</li></ol><p>该方法关键在于，积分区间需要合理定义，保证积分提交成绩能平均散落在不同区间。（如涉及较多其他条件，如日排行，总排行，以及其他独立用户去重等，请按照影响结果集思路自行发挥。）</p><p><strong>方案2：</strong><br>Redis方案<br>Zset 有序数组结构，分两个子结构，第一是多层树形的存储结构，第二是每个树形节点的计数器，这样类似于前面的分段方式，可以理解为多层分段方式，所以查询效率更高，缺点是更新效率有所增加。</p><h4 id="大数据量翻页"><a href="#大数据量翻页" class="headerlink" title="大数据量翻页"></a>大数据量翻页</h4><p><strong>背景</strong>：常见论坛帖子页 SQL: select * from post where tagid=$tagid order by lastpost limit $start, $end 翻页 。索引为 tagid+lastpost 复合索引</p><p><strong>挑战</strong>：超级热帖，几万回帖，用户频频翻到末页，limit 25770,30 一个操作下来，影响结果集巨大(25770+30)，查询缓慢。</p><p><strong>方案1：</strong><br>点击页码改为上下翻页；跳转页sql改为子查询或者内连接</p><ul><li><p>只涉及上下翻页情况<br>每次查询的时候将该页查询结果中最大的 $lastpost和最小的分别记录为 $minlastpost 和 $maxlastpost ，上翻页查询为 select <em> from post where tagid=$tagid and lastpost&lt;$minlastpost order by lastpost desc limit 30; 下翻页为 select </em> from post where tagid=$tagid and lastpost&gt;$maxlastpost order by lastpost limit 30; 使用这种方式，影响结果集只有30条，效率极大提升。</p></li><li><p>涉及跳转到任意页<br>互联网上常见的一个优化方案可以这样表述，select <em> from post where tagid=$tagid and lastpost&gt;=(select lastpost from post where tagid=$tagid order by lastpost limit $start,1) order by lastpost limit 30; 或者 select </em> from post where pid in (select pid from post where tagid=$tagid order by lastpost limit $start,30); (第2条S语法在新的mysql版本已经不支持，新版本mysql in的子语句不再支持limit条件，但可以分解为两条SQL实现，原理不变，不做赘述)</p></li></ul><p>以上思路在于，子查询的影响结果集仍然是$start +30，但是数据获取的过程（Sending data状态）发生在索引文件中，而不是数据表文件，这样所需要的系统开销就比前一种普通的查询低一个数量级，而主查询的影响结果集只有30条，几乎无开销。但是切记，这里仍然涉及了太多的影响结果集操作。</p><h2 id="常见杀手级SQL"><a href="#常见杀手级SQL" class="headerlink" title="常见杀手级SQL"></a>常见杀手级SQL</h2><ul><li><p>SELECT * vs SELECT col1, col2<br>减少磁盘 io 和网络 io</p></li><li><p>ORDER BY RAND()<br><a href="http://imysql.com/2014/07/04/mysql-optimization-case-rand-optimize.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2014/07/04/mysql-optimization-case-rand-optimize.shtml</a></p></li><li><p>LIMIT huge_num, offset<br><a href="http://imysql.com/2015/04/02/mysql-optimization-case-discuz-hot-post-very-old-paging-optimizing.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2015/04/02/mysql-optimization-case-discuz-hot-post-very-old-paging-optimizing.shtml</a></p></li><li><p>SELECT COUNT(*) on InnoDB table</p></li><li><p>WHERE func(key_col) = ? – 无法使用索引</p></li><li><p>WHERE key_part2 =? AND key_part3 =? – 无法使用索引</p></li><li><p>WHERE key_part1 &gt; ? AND key_part2 =? – 只能用到部分索引</p></li><li><p>SELECT … WHERE key_col + ? = ? – 无法使用索引</p></li></ul><h2 id="开启-分析慢查询"><a href="#开启-分析慢查询" class="headerlink" title="开启/分析慢查询"></a>开启/分析慢查询</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p><strong>检查是否开启</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slow%'</span>; //0为未开启</span><br></pre></td></tr></table></figure><p><strong>开启慢查询</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//my.cnf 添加</span><br><span class="line">[mysqld]</span><br><span class="line">log_slow_queries = 日志保存位置</span><br><span class="line">long_query_time=1 <span class="comment">#超过一秒的查询保存到日志</span></span><br><span class="line"><span class="built_in">log</span>-queries-not-using-indexes <span class="comment">#没有使用到索引的查询保存在日志</span></span><br><span class="line"><span class="built_in">log</span>-slow-admin-statements <span class="comment">#一些管理指令，也会被记录。比如OPTIMEZE TABLE, ALTER TABLE等等。</span></span><br></pre></td></tr></table></figure></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><p><strong>mysqldumpslow</strong></p><p>mysql自带,参数可–help查看</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -s：排序方式。c , t , l , r 表示记录次数、时间、查询时间的多少、返回的记录数排序；</span><br><span class="line"># ac , at , al , ar 表示相应的倒序；</span><br><span class="line"># -t：返回前面多少条的数据；</span><br><span class="line"># -g：包含什么，大小写不敏感的；</span><br></pre></td></tr></table></figure><p>使用案例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 /slowquery.log #slow记录最多的10个语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g "left join" /slowquery.log #按照时间排序前10中含有"left join"的</span><br></pre></td></tr></table></figure></li><li><p><strong>mysqlsla</strong></p><p>github地址: <a href="https://github.com/daniel-nichter/hackmysql.com/tree/master/mysqlsla" rel="external nofollow noopener noreferrer" target="_blank">点此进入</a></p><p>使用案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// mysqlsla会自动判断日志类型，为了方便可以建立一个配置文件“~/.mysqlsla”</span><br><span class="line">// 在文件里写上：top=100，这样会打印出前100条结果。</span><br><span class="line">mysqlsla /data/mysqldata/slow.log</span><br></pre></td></tr></table></figure><p>结果说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* queries total: 总查询次数</span><br><span class="line">* unique:去重后的sql数量</span><br><span class="line">* sorted by : 输出报表的内容排序最重大的慢sql统计信息, 包括平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数.</span><br><span class="line">* Count, sql的执行次数及占总的slow log数量的百分比.</span><br><span class="line">* Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</span><br><span class="line">* 95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</span><br><span class="line">* Lock Time, 等待锁的时间.</span><br><span class="line">* 95% of Lock , 95%的慢sql等待锁时间.</span><br><span class="line">* Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</span><br><span class="line">* Rows examined, 扫描的行数量.</span><br><span class="line">* Database, 属于哪个数据库</span><br><span class="line">* Users, 哪个用户,IP, 占到所有用户执行的sql百分比</span><br><span class="line">* Query abstract, 抽象后的sql语句</span><br><span class="line">* Query sample, sql语句</span><br></pre></td></tr></table></figure></li></ol><h2 id="优化索引"><a href="#优化索引" class="headerlink" title="优化索引"></a>优化索引</h2><ol><li><p>定期检查并删除重复的索引<br>用 pt-duplicate-key-checker 工具<br>比如 index idx1(a, b) 索引已经涵盖了 index idx2(a)，就可以删除 idx2 索引了。</p></li><li><p>索引量<br>基于索引的条件过滤，如果优化器意识到总共需要扫描的数据量超过 <strong>30%</strong> 时，就会直接改变执行计划为全表扫描，不再使用索引。</p></li><li><p>联合索引<br>WHERE中过滤条件的字段顺序和索引 <strong>无需一致</strong><br>排序、分组则就 <strong>必须一致</strong></p></li><li><p>合理利用覆盖索引，但字段尽量不超过5个</p></li><li><p>合理利用最左索引（前缀索引/部分索引）</p></li><li><p>及时删除冗余索引</p></li><li><p>索引字段条件不使用函数</p></li><li><p>内存表(HEAP 表)使用HASH索引时，不能使用范围检索或者ORDER BY等，只能使用=或者!=</p></li><li><p>两个独立索引，其中一个用于检索，一个用于排序 – 只能用到其中一个索引，5.6以上有ICP特性<br>优化器判断使用哪个索引</p></li><li><p>表关联字段类型要一样（也包括长度一样），否则会有类型隐式转换</p></li></ol><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>注意内存的使用优化：<a href="">系统与软件-&gt;内存使用考量</a></p><h2 id="查看-分析资源消耗"><a href="#查看-分析资源消耗" class="headerlink" title="查看/分析资源消耗"></a>查看/分析资源消耗</h2><p><strong>SHOW PROFILE 和 SHOW PROFILES</strong></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>作用域是会话级；</li><li>SHOW PROFILES显示最近发给服务器的多条语句，条数根据会话变量profiling_history_size定义，默认是15，最大值为100。设为0等价于关闭分析功能。</li><li><strong>默认是关闭</strong>；其是否启用是根据会话级的变量profiling</li><li>mysql5.7以后不建议使用SHOW PROFILE指令，或直接从INFORMATION_SCHEMA.PROFILING中查看，建议利用PERFORMANCE_SCHEMA中的几个视图查看。（因为会被废弃）</li></ol><h3 id="开启-1"><a href="#开启-1" class="headerlink" title="开启"></a>开启</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling=1;或 SET profiling=on;</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling=0;或 SET profiling=off;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE [<span class="keyword">type</span> [, <span class="keyword">type</span>] … ][<span class="keyword">FOR</span> <span class="keyword">QUERY</span> n][<span class="keyword">LIMIT</span> <span class="keyword">row_count</span> [<span class="keyword">OFFSET</span> <span class="keyword">offset</span>]]</span><br></pre></td></tr></table></figure><p>type是可选的，取值范围可以如下：</p><ul><li>ALL 显示所有性能信息</li><li>BLOCK IO 显示块IO操作的次数</li><li>CONTEXT SWITCHES 显示上下文切换次数，不管是主动还是被动</li><li>CPU 显示用户CPU时间、系统CPU时间</li><li>IPC 显示发送和接收的消息数量</li><li>MEMORY [暂未实现]</li><li>PAGE FAULTS 显示页错误数量</li><li>SOURCE 显示源码中的函数名称与位置</li><li>SWAPS 显示SWAP的次数</li></ul><p>SHOW PROFILE FOR QUERY n，这里的n就是对应SHOW PROFILES输出中的Query_ID。<br>如果没有指定FOR QUERY，那么输出最近一条语句的信息。</p><p><code>SHOW PROFILE ALL FOR QUERY 2</code> 的信息还可以通过<code>SELECT * FROM information_schema.profiling WHERE query_id = 2 ORDER BY seq;</code>获取。</p><p>参考：<br><a href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html" rel="external nofollow noopener noreferrer" target="_blank">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p><h2 id="查看执行状态"><a href="#查看执行状态" class="headerlink" title="查看执行状态"></a>查看执行状态</h2><h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">FULL</span>] <span class="keyword">PROCESSLIST</span></span><br></pre></td></tr></table></figure><p>SHOW PROCESSLIST显示哪些线程正在运行。您也可以使用mysqladmin processlist语句得到此信息。如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程（也就是，与您正在使用的MySQL账户相关的线程）。如果您不使用FULL关键词，则只显示每个查询的前100个字符。</p><h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.6/en/thread-commands.html" rel="external nofollow noopener noreferrer" target="_blank">https://dev.mysql.com/doc/refman/5.6/en/thread-commands.html</a></p><ul><li><p>Sleep<br>通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内</p><p>实例:因前端数据输出时（特别是输出到用户终端）未及时关闭数据库连接，导致因网络连接速度产生大量sleep连接，在网速出现异常时，数据库 too many connections挂死。</p><p>简单解读，数据查询和执行通常只需要不到0.01秒，而网络输出通常需要1秒左右甚至更长，原本数据连接在0.01秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在 结果未展现在用户桌面前，该数据库连接一直维持在sleep状态！</p></li><li><p>Waiting for net / reading from net / writing to net<br>偶尔出现无妨，如大量出现，迅速检查数据库到前端的网络连接状态和流量<br>Reading from net 表示server端正通过网络读取客户端发送过来的请求建议：减小客户端发送数据包大小，提高网络带宽/质量<br>Writing to net通过网络传输数据</p><p>案例: 因外挂程序，内网数据库大量读取，内网使用的百兆交换迅速爆满，导致大量连接阻塞在waiting for net，数据库连接过多崩溃</p></li><li><p>Locked<br>有更新操作锁定，通常使用innodb可以很好的减少locked状态的产生，但是切记，更新操作要正确使用索引，即便是低频次更新操作也不能疏忽。如上影响结果集范例所示。<br>在myisam的时代，locked是很多高并发应用的噩梦。所以mysql官方也开始倾向于推荐innodb。</p></li><li><p>Copy to tmp table<br>索引及现有结构无法涵盖查询条件，才会建立一个临时表来满足查询要求，产生巨大的恐怖的i/o压力。<br>很可怕的搜索语句会导致这样的情况，如果是数据分析，或者半夜的周期数据清理任务，偶尔出现，可以允许。频繁出现务必优化之。<br>执行ALTER TABLE修改表结构时建议：放在凌晨执行或者采用类似pt-osc工具<br>通常与连表查询有关，建议逐渐习惯不使用连表查询。</p><p>实战范例：某社区数据库阻塞，求救，经查，其服务器存在多个数据库应用和网站，其中一个不常用的小网站数据库产生了一个恐怖的copy to tmp table 操作，导致整个硬盘i/o和cpu压力超载。Kill掉该操作一切恢复。</p></li><li><p>Copying to tmp table<br>拷贝数据到内存中的临时表，常见于GROUP BY操作时,建议：创建适当的索引</p></li><li><p>Copying to tmp table on disk<br>临时结果集太大，内存中放不下，需要将内存中的临时表拷贝到磁盘上，形成 <code>*sql.MYD</code>、<code>*sql.MYI</code>（在5.6及更高的版本，临时表可以改成InnoDB引擎了，可以参考选项default_tmp_storage_engine）建议：创建适当的索引，并且适当加大sort_buffer_size/tmp_table_size/max_heap_table_size</p></li><li><p>Creating sort index<br>当前的SELECT中需要用到临时表在进行ORDER BY排序，建议：创建适当的索引</p></li><li><p>Sending data<br>并不是发送数据，别被这个名字所欺骗，这是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，<br>偶尔出现该状态连接无碍。回到上面影响结果集的问题，一般而言，如果sending data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化。<br>前文提到影响结果集对SQL查询效率线性相关，主要就是针对这个状态的系统开销。<br>如果出现大量相似的SQL语句出现在show proesslist列表中，并且都处于sending data状态，优化查询索引，记住用影响结果集的思路去思考。<br>从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见备注：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net</p><p>建议：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量</p></li><li><p>Creating tmp table<br>创建基于内存或磁盘的临时表，当从内存转成磁盘的临时表时，状态会变成：Copying to tmp table on disk<br>建议：创建适当的索引，或者少用UNION、视图(VIEW)、子查询(SUBQUERY)之类的，确实需要用到临时表的时候，可以在session级临时适当调大 tmp_table_size/max_heap_table_size 的值</p></li><li><p>Storing result to query cache<br>出现这种状态，如果频繁出现，使用set profiling分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query cache碎片较多<br>使用flush query cache 可即时清理，也可以做成定时任务<br>Query cache参数可适当酌情设置。</p></li><li><p>Freeing items<br>理论上这玩意不会出现很多。偶尔出现无碍<br>如果大量出现，内存，硬盘可能已经出现问题。比如硬盘满或损坏。<br>i/o压力过大时，也可能出现Free items执行时间较长的情况。</p></li><li><p>Sorting for …<br>和Sending data类似，结果集过大，排序条件没有索引化，需要在内存里排序，甚至需要创建临时结构排序。</p></li><li><p>Sorting result<br>正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序建议：创建适当的索引</p></li><li><p>statistics<br>进行数据统计以便解析执行计划，如果状态比较经常出现，有可能是磁盘IO性能很差建议：查看当前io性能状态，例如iowait</p></li><li><p>Waiting for global read lock<br>FLUSH TABLES WITH READ LOCK整等待全局读锁<br>建议：不要对线上业务数据库加上全局读锁，通常是备份引起，可以放在业务低谷期间执行或者放在slave服务器上执行备份</p></li><li><p>Waiting for tables,Waiting for table flush<br>FLUSH TABLES, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, OPTIMIZE TABLE等需要刷新表结构并重新打开<br>建议：不要对线上业务数据库执行这些操作，可以放在业务低谷期间执行</p></li><li><p>Waiting for lock_type lock<br>等待各种类型的锁：</p><ul><li>Waiting for event metadata lock</li><li>Waiting for global read lock</li><li>Waiting for schema metadata lock</li><li>Waiting for stored function metadata lock</li><li>Waiting for stored procedure metadata lock</li><li>Waiting for table level lock</li><li>Waiting for table metadata lock</li><li>Waiting for trigger metadata lock</li></ul><p>建议：比较常见的是上面提到的global read lock以及table metadata lock，建议不要对线上业务数据库执行这些操作，可以放在业务低谷期间执行。如果是table level lock，通常是因为还在使用MyISAM引擎表，赶紧转投InnoDB引擎吧，别再老顽固了</p></li></ul><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>官方文档:<a href="http://dev.mysql.com/doc/refman/5.6/en/general-thread-states.html" rel="external nofollow noopener noreferrer" target="_blank">http://dev.mysql.com/doc/refman/5.6/en/general-thread-states.html</a></p><ul><li><p>After create<br>当线程创建表（包括临时表）</p></li><li><p>Analyzing<br>线程正在分析MYISAM的key分布</p></li><li><p>checking permissions<br>线程正在检查执行语句的权限</p></li><li><p>Checking table<br>线程正在执行表check操作</p></li><li><p>Cleaning up<br>线程已经处理完一个命令然后开始准备释放内存和reset状态变量</p></li><li><p>Closing tables<br>线程把改变的表数据flush到磁盘然后关闭使用的表。这个操作应该是很快的，如果这个状态长时间出现，要留意检查磁盘的状态。</p></li><li><p>Converting HEAP to MyISAM<br>把一个内存中的临时表转换到磁盘上的MYISAM表</p></li><li><p>Copy to tmp table<br>线程执行alter table语句。这个状态出现在新的表结构已经创建但数据还在拷贝到新表之前。</p></li><li><p>Copying to group table<br>如果一个语句的group by和order by 条件不同，数据通过group by来排序然后拷贝到临时表</p></li><li><p>Copying to tmp table<br>拷贝到内存中的临时表</p></li><li><p>Copying to tmp table on disk<br>如果临时表过大，服务器要把内存中的临时表拷贝到磁盘。</p></li><li><p>Creating index<br>对一个MYISAM 执行ALTER TABLE … ENABLE KEYS</p></li><li><p>Creating sort index<br>线程通过执行一个临时表来执行select语句</p></li><li><p>Creating table<br>线程正在创建表（包括临时表）</p></li><li><p>Creating tmp table<br>创建临时表（在内存或者磁盘）上，如果表一开始在内存中到后面太大，临时表就会转换到磁盘上，而且状态也会变成Copying to tmp table on disk</p></li><li><p>deleting from main table<br>服务器正在执行一个多表delete语句的第一部分，也就是从第一张表删除数据，并且保留行以及偏移量数据以用来删除其他表中的数据。</p></li><li><p>deleting from reference tables<br>服务器正在执行一个多表delete语句的二部分</p></li><li><p>discard_or_import_tablespace<br>线程正在执行ALTER TABLE … DISCARD TABLESPACE 或者ALTER TABLE … IMPORT TABLESPACE 语句.</p></li><li><p>end<br>这个状态出现在ALTER TABLE, CREATE VIEW, DELETE, INSERT, SELECT, UPDATE语句结束之后，但在清理以前。</p></li><li><p>executing<br>线程开始执行一个语句</p></li><li><p>Execution of init_command<br>线程在init_command系统变量中执行语句</p></li><li><p>freeing items<br>线程已经执行命令。一些释放</p></li><li><p>Flushing tables<br>这个线程执行了FLUSH TABLES，而且等待所有的线程关闭表</p></li><li><p>FULLTEXT initialization<br>服务器准备执行文本搜索</p></li><li><p>Killed<br>发送了kill 语句给这个查询。这个语句在下次检查kill标志的时候，这个语句就应该放弃掉</p></li><li><p>Locked<br>查询被其他的查询锁住了</p></li><li><p>logging slow query<br>线程正在把慢sql写到慢查询log文件中</p></li><li><p>login<br>直到线程授权成功以前都是这个状态</p></li><li><p>manage keys<br>服务器正在管理表的索引</p></li><li><p>Opening tables, Opening table<br>线程正在打开表。这个操作是很快的，除非有其他原因阻止了打开操作，例如ALTER TABLE   LOCK TABLE</p></li><li><p>optimizing<br>服务器正在进行一个查询的初始阶段优化</p></li><li><p>preparing<br>正在进行查询优化</p></li><li><p>Purging old relay logs<br>线程删除不需要的relay log文件</p></li><li><p>query end<br>这个状态出现在处理完以后但在冻结item之前</p></li><li><p>Reading from net<br>服务器从网络读取包</p></li><li><p>Removing duplicates<br>查询使用了select distinct。mysq在发送数据到客户端之前需要一个额外的过程来删除重复的行</p></li><li><p>removing tmp table<br>在执行了select语句以后，线程正在删除内部的临时表</p></li><li><p>rename<br>线程正在重命名表</p></li><li><p>rename result table<br>线程正在执行一个alter table语句，而且已经创建了新表，对新表重命名来替换原始表。</p></li><li><p>Reopen tables<br>线程获取了一个表的锁。由于它已经得知它依赖的表结构已经发生了变化。线程需要释放锁、关闭表、然后尝试重新打开他。</p></li><li><p>Repair by sorting<br>修复代码通过排序来创建索引。</p></li><li><p>Repair done<br>线程完成了对一个myisam表的多线程修复。</p></li><li><p>Repair with keycache<br>修复代码正在通过key的缓存创建key。</p></li><li><p>Rolling back<br>线程正在回滚事物。</p></li><li><p>Saving state<br>myisam的analysis和repair操作中，线程会把表的一些信息例如表的行数、AUTO_INCREMENT的计数器以及key的分布都保存到.MYI文件的头部</p></li><li><p>Searching rows for update<br>语句执行的第一个阶段，找到所有满足条件的行记录</p></li><li><p>Sending data<br>线程在读取和处理SELECT语句，发送数据到客户端。由于语句需要大量的磁盘访问，这个状态会在语句的整个生命周期中占据最长的一个状态。</p></li><li><p>setup<br>线程开始进行ALTER TABLE 语句</p></li><li><p>Sorting for group<br>线程正在为group by 执行排序</p></li><li><p>Sorting for order<br>线程正在为order by 执行排序</p></li><li><p>Sorting index<br>在myisam表的优化操作中，进行索引页的排序以便获得更好的访问性能。</p></li><li><p>Sorting result<br>对结果进行排序</p></li><li><p>Statistics<br>服务器正在计算统计数据从而来生成一个执行计划。如果一个线程保留这个状态很长的时间，意味着服务器在执行其他的磁盘相关的工作。</p></li><li><p>System lock<br>线程正在请求和获取一个内部和外部锁。如果有这个状态</p></li><li><p>Table lock<br>System Lock后的另一个线程状态。线程已经获取了一个外部锁，然后接下来要去获取一个内部表锁。</p></li><li><p>update<br>线程已经准备好去更新</p></li><li><p>Updating<br>现在正在找或者正在更新行</p></li><li><p>updating main table<br>服务器正在执行一个多表update语句，正在更新第一张表，保存行和偏移量以用来更新其他表。</p></li><li><p>updating reference tables<br>服务器正在执行一个多表update语句的第二部分，正在从其他表更新行</p></li><li><p>User lock<br>请求或者等待获取一个锁</p></li><li><p>User sleep<br>线程sleep</p></li><li><p>Waiting for release of readlock<br>等待一个全局的读锁</p></li><li><p>Waiting for tables, Waiting for table<br>线程获得提示依赖的表结构发生了改变，线程需要重新打开表来获取新的结构。但是，重新打开表是需要等待其他的线程关闭表。</p></li><li><p>Waiting on cond<br>线程正在等条件变成true</p></li><li><p>Waiting to get readlock<br>线程用FLUSH TABLES WITH READ LOCK语句，所以要获得一个全局的读锁，这个状态表示正在等这个锁。</p></li><li><p>Writing to net<br>服务器把包写到网络</p></li></ul><h2 id="查看mysql状态"><a href="#查看mysql状态" class="headerlink" title="查看mysql状态"></a>查看mysql状态</h2><h3 id="show-status-与-show-global-status-区别"><a href="#show-status-与-show-global-status-区别" class="headerlink" title="show status 与 show global status 区别"></a>show status 与 show global status 区别</h3><p>status：当前连接的状态（当前会话/连接）<br>global status：mysql 启动后到目前的状态（全局会话）</p><h3 id="show-status-详解"><a href="#show-status-详解" class="headerlink" title="show status 详解"></a>show status 详解</h3><p>官方文档：<a href="http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html" rel="external nofollow noopener noreferrer" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html</a></p><table><thead><tr><th>状态名</th><th>作用域</th><th>详细解释</th></tr></thead><tbody><tr><td>Aborted_clients</td><td>Global</td><td>由于客户端没有正确关闭连接导致客户端终止而中断的连接数</td></tr><tr><td>Aborted_connects</td><td>Global</td><td>试图连接到MySQL服务器而失败的连接数</td></tr><tr><td>Binlog_cache_disk_use</td><td>Global</td><td>使用临时二进制日志缓存但超过binlog_cache_size值并使用临时文件来保存事务中的语句的事务数量</td></tr><tr><td>Binlog_cache_use</td><td>Global</td><td>使用临时二进制日志缓存的事务数量</td></tr><tr><td>Bytes_received</td><td>Both</td><td>从所有客户端接收到的字节数。</td></tr><tr><td>Bytes_sent</td><td>Both</td><td>发送给所有客户端的字节数。</td></tr><tr><td>com*</td><td></td><td>各种数据库操作的数量</td></tr><tr><td>Compression</td><td>Session</td><td>客户端与服务器之间只否启用压缩协议</td></tr><tr><td>Connections</td><td>Global</td><td>试图连接到(不管是否成功)MySQL服务器的连接数</td></tr><tr><td>Created_tmp_disk_tables</td><td>Both</td><td>服务器执行语句时在硬盘上自动创建的临时表的数量</td></tr><tr><td>Created_tmp_files</td><td>Global</td><td>mysqld已经创建的临时文件的数量</td></tr><tr><td>Created_tmp_tables</td><td>Both</td><td>服务器执行语句时自动创建的内存中的临时表的数量。如果Created_tmp_disk_tables较大，你可能要增加tmp_table_size值使临时表基于内存而不基于硬盘</td></tr><tr><td>Delayed_errors</td><td>Global</td><td>用INSERT DELAYED写的出现错误的行数(可能为duplicate key)。</td></tr><tr><td>Delayed_insert_threads</td><td>Global</td><td>使用的INSERT DELAYED处理器线程数。</td></tr><tr><td>Delayed_writes</td><td>Global</td><td>写入的INSERT DELAYED行数</td></tr><tr><td>Flush_commands</td><td>Global</td><td>执行的FLUSH语句数。</td></tr><tr><td>Handler_commit</td><td>Both</td><td>内部提交语句数</td></tr><tr><td>Handler_delete</td><td>Both</td><td>行从表中删除的次数。</td></tr><tr><td>Handler_discover</td><td>Both</td><td>MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。</td></tr><tr><td>Handler_prepare</td><td>Both</td><td>A counter for the prepare phase of two-phase commit operations.</td></tr><tr><td>Handler_read_first</td><td>Both</td><td>索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引。</td></tr><tr><td>Handler_read_key</td><td>Both</td><td>根据键读一行的请求数。如果较高，说明查询和表的索引正确。</td></tr><tr><td>Handler_read_next</td><td>Both</td><td>按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</td></tr><tr><td>Handler_read_prev</td><td>Both</td><td>按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</td></tr><tr><td>Handler_read_rnd</td><td>Both</td><td>根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。</td></tr><tr><td>Handler_read_rnd_next</td><td>Both</td><td>在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</td></tr><tr><td>Handler_rollback</td><td>Both</td><td>内部ROLLBACK语句的数量。</td></tr><tr><td>Handler_savepoint</td><td>Both</td><td>在一个存储引擎放置一个保存点的请求数量。</td></tr><tr><td>Handler_savepoint_rollback</td><td>Both</td><td>在一个存储引擎的要求回滚到一个保存点数目。</td></tr><tr><td>Handler_update</td><td>Both</td><td>在表内更新一行的请求数。</td></tr><tr><td>Handler_write</td><td>Both</td><td>在表内插入一行的请求数。</td></tr><tr><td>Innodb_buffer_pool_pages_data</td><td>Global</td><td>包含数据的页数(脏或干净)。</td></tr><tr><td>Innodb_buffer_pool_pages_dirty</td><td>Global</td><td>当前的脏页数。</td></tr><tr><td>Innodb_buffer_pool_pages_flushed</td><td>Global</td><td>要求清空的缓冲池页数</td></tr><tr><td>Innodb_buffer_pool_pages_free</td><td>Global</td><td>空页数。</td></tr><tr><td>Innodb_buffer_pool_pages_latched</td><td>Global</td><td>在InnoDB缓冲池中锁定的页数。这是当前正读或写或由于其它原因不能清空或删除的页数。</td></tr><tr><td>Innodb_buffer_pool_pages_misc</td><td>Global</td><td>忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。该值还可以计算为Innodb_buffer_pool_pages_total - Innodb_buffer_pool_pages_free - Innodb_buffer_pool_pages_data。</td></tr><tr><td>Innodb_buffer_pool_pages_total</td><td>Global</td><td>缓冲池总大小（页数）。</td></tr><tr><td>Innodb_buffer_pool_read_ahead_rnd</td><td>Global</td><td>InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。</td></tr><tr><td>Innodb_buffer_pool_read_ahead_seq</td><td>Global</td><td>InnoDB初始化的顺序read-aheads数。当InnoDB执行顺序全表扫描时发生。</td></tr><tr><td>Innodb_buffer_pool_read_requests</td><td>Global</td><td>InnoDB已经完成的逻辑读请求数。</td></tr><tr><td>Innodb_buffer_pool_reads</td><td>Global</td><td>不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。</td></tr><tr><td>Innodb_buffer_pool_wait_free</td><td>Global</td><td>一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。</td></tr><tr><td>Innodb_buffer_pool_write_requests</td><td>Global</td><td>向InnoDB缓冲池的写数量。</td></tr><tr><td>Innodb_data_fsyncs</td><td>Global</td><td>fsync()操作数。</td></tr><tr><td>Innodb_data_pending_fsyncs</td><td>Global</td><td>当前挂起的fsync()操作数。</td></tr><tr><td>Innodb_data_pending_reads</td><td>Global</td><td>当前挂起的读数。</td></tr><tr><td>Innodb_data_pending_writes</td><td>Global</td><td>当前挂起的写数。</td></tr><tr><td>Innodb_data_read</td><td>Global</td><td>至此已经读取的数据数量（字节）。</td></tr><tr><td>Innodb_data_reads</td><td>Global</td><td>数据读总数量。</td></tr><tr><td>Innodb_data_writes</td><td>Global</td><td>数据写总数量。</td></tr><tr><td>Innodb_data_written</td><td>Global</td><td>至此已经写入的数据量（字节）。</td></tr><tr><td>Innodb_dblwr_pages_written</td><td>Global</td><td>已经执行的双写操作数量</td></tr><tr><td>Innodb_dblwr_writes</td><td>Global</td><td>双写操作已经写好的页数</td></tr><tr><td>Innodb_log_waits</td><td>Global</td><td>我们必须等待的时间，因为日志缓冲区太小，我们在继续前必须先等待对它清空</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Innodb_log_write_requests</td><td>Global</td><td>日志写请求数。</td></tr><tr><td>Innodb_log_writes</td><td>Global</td><td>向日志文件的物理写数量。</td></tr><tr><td>Innodb_os_log_fsyncs</td><td>Global</td><td>向日志文件完成的fsync()写数量。</td></tr><tr><td>Innodb_os_log_pending_fsyncs</td><td>Global</td><td>挂起的日志文件fsync()操作数量。</td></tr><tr><td>Innodb_os_log_pending_writes</td><td>Global</td><td>挂起的日志文件写操作</td></tr><tr><td>Innodb_os_log_written</td><td>Global</td><td>写入日志文件的字节数。</td></tr><tr><td>Innodb_page_size</td><td>Global</td><td>编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。</td></tr><tr><td>Innodb_pages_created</td><td>Global</td><td>创建的页数。</td></tr><tr><td>Innodb_pages_read</td><td>Global</td><td>读取的页数。</td></tr><tr><td>Innodb_pages_written</td><td>Global</td><td>写入的页数。</td></tr><tr><td>Innodb_row_lock_current_waits</td><td>Global</td><td>当前等待的待锁定的行数。</td></tr><tr><td>Innodb_row_lock_time</td><td>Global</td><td>行锁定花费的总时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_time_avg</td><td>Global</td><td>行锁定的平均时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_time_max</td><td>Global</td><td>行锁定的最长时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_waits</td><td>Global</td><td>一行锁定必须等待的时间数。</td></tr><tr><td>Innodb_rows_deleted</td><td>Global</td><td>从InnoDB表删除的行数。</td></tr><tr><td>Innodb_rows_inserted</td><td>Global</td><td>插入到InnoDB表的行数。</td></tr><tr><td>Innodb_rows_read</td><td>Global</td><td>从InnoDB表读取的行数。</td></tr><tr><td>Innodb_rows_updated</td><td>Global</td><td>InnoDB表内更新的行数。</td></tr><tr><td>Key_blocks_not_flushed</td><td>Global</td><td>键缓存内已经更改但还没有清空到硬盘上的键的数据块数量。</td></tr><tr><td>Key_blocks_unused</td><td>Global</td><td>键缓存内未使用的块数量。你可以使用该值来确定使用了多少键缓存</td></tr><tr><td>Key_blocks_used</td><td>Global</td><td>键缓存内使用的块数量。该值为高水平线标记，说明已经同时最多使用了多少块。</td></tr><tr><td>Key_read_requests</td><td>Global</td><td>从缓存读键的数据块的请求数。</td></tr><tr><td>Key_reads</td><td>Global</td><td>从硬盘读取键的数据块的次数。如果Key_reads较大，则Key_buffer_size值可能太小。可以用Key_reads/Key_read_requests计算缓存损失率。</td></tr><tr><td>Key_write_requests</td><td>Global</td><td>将键的数据块写入缓存的请求数。</td></tr><tr><td>Key_writes</td><td>Global</td><td>向硬盘写入将键的数据块的物理写操作的次数。</td></tr><tr><td>Last_query_cost</td><td>Session</td><td>用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。默认值是0。Last_query_cost具有会话范围。</td></tr><tr><td>Max_used_connections</td><td>Global</td><td>服务器启动后已经同时使用的连接的最大数量。</td></tr><tr><td>ndb*</td><td></td><td>ndb集群相关</td></tr><tr><td>Not_flushed_delayed_rows</td><td>Global</td><td>等待写入INSERT DELAY队列的行数。</td></tr><tr><td>Open_files</td><td>Global</td><td>打开的文件的数目。</td></tr><tr><td>Open_streams</td><td>Global</td><td>打开的流的数量(主要用于记录)。</td></tr><tr><td>Open_table_definitions</td><td>Global</td><td>缓存的.frm文件数量</td></tr><tr><td>Open_tables</td><td>Both</td><td>当前打开的表的数量。</td></tr><tr><td>Opened_files</td><td>Global</td><td>文件打开的数量。不包括诸如套接字或管道其他类型的文件。 也不包括存储引擎用来做自己的内部功能的文件。</td></tr><tr><td>Opened_table_definitions</td><td>Both</td><td>已经缓存的.frm文件数量</td></tr><tr><td>Opened_tables</td><td>Both</td><td>已经打开的表的数量。如果Opened_tables较大，table_cache 值可能太小。</td></tr><tr><td>Prepared_stmt_count</td><td>Global</td><td>当前的预处理语句的数量。(最大数为系统变量: max_prepared_stmt_count)</td></tr><tr><td>Qcache_free_blocks</td><td>Global</td><td>查询缓存内自由内存块的数量。</td></tr><tr><td>Qcache_free_memory</td><td>Global</td><td>用于查询缓存的自由内存的数量。</td></tr><tr><td>Qcache_hits</td><td>Global</td><td>查询缓存被访问的次数。</td></tr><tr><td>Qcache_inserts</td><td>Global</td><td>加入到缓存的查询数量。</td></tr><tr><td>Qcache_lowmem_prunes</td><td>Global</td><td>由于内存较少从缓存删除的查询数量。</td></tr><tr><td>Qcache_not_cached</td><td>Global</td><td>非缓存查询数(不可缓存，或由于query_cache_type设定值未缓存)。</td></tr><tr><td>Qcache_queries_in_cache</td><td>Global</td><td>登记到缓存内的查询的数量。</td></tr><tr><td>Qcache_total_blocks</td><td>Global</td><td>查询缓存内的总块数。</td></tr><tr><td>Queries</td><td>Both</td><td>服务器执行的请求个数，包含存储过程中的请求。</td></tr><tr><td>Questions</td><td>Both</td><td>已经发送给服务器的查询的个数。</td></tr><tr><td>Rpl_status</td><td>Global</td><td>失败安全复制状态(还未使用)。</td></tr><tr><td>Select_full_join</td><td>Both</td><td>没有使用索引的联接的数量。如果该值不为0,你应仔细检查表的索引</td></tr><tr><td>Select_full_range_join</td><td>Both</td><td>在引用的表中使用范围搜索的联接的数量。</td></tr><tr><td>Select_range</td><td>Both</td><td>在第一个表中使用范围的联接的数量。一般情况不是关键问题，即使该值相当大。</td></tr><tr><td>Select_range_check</td><td>Both</td><td>在每一行数据后对键值进行检查的不带键值的联接的数量。如果不为0，你应仔细检查表的索引。</td></tr><tr><td>Select_scan</td><td>Both</td><td>对第一个表进行完全扫描的联接的数量。</td></tr><tr><td>Slave_heartbeat_period</td><td>Global</td><td>复制的心跳间隔</td></tr><tr><td>Slave_open_temp_tables</td><td>Global</td><td>从服务器打开的临时表数量</td></tr><tr><td>Slave_received_heartbeats</td><td>Global</td><td>从服务器心跳数</td></tr><tr><td>Slave_retried_transactions</td><td>Global</td><td>本次启动以来从服务器复制线程重试次数</td></tr><tr><td>Slave_running</td><td>Global</td><td>如果该服务器是连接到主服务器的从服务器，则该值为ON。</td></tr><tr><td>Slow_launch_threads</td><td>Both</td><td>创建时间超过slow_launch_time秒的线程数。</td></tr><tr><td>Slow_queries</td><td>Both</td><td>查询时间超过long_query_time秒的查询的个数。</td></tr><tr><td>Sort_merge_passes</td><td>Both</td><td>排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort_buffer_size系统变量的值。</td></tr><tr><td>Sort_range</td><td>Both</td><td>在范围内执行的排序的数量。</td></tr><tr><td>Sort_rows</td><td>Both</td><td>已经排序的行数。</td></tr><tr><td>Sort_scan</td><td>Both</td><td>通过扫描表完成的排序的数量。</td></tr><tr><td>ssl＊</td><td></td><td>ssl连接相关</td></tr><tr><td>Table_locks_immediate</td><td>Global</td><td>立即获得的表的锁的次数。</td></tr><tr><td>Table_locks_waited</td><td>Global</td><td>不能立即获得的表的锁的次数。如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。</td></tr><tr><td>Threads_cached</td><td>Global</td><td>线程缓存内的线程的数量。</td></tr><tr><td>Threads_connected</td><td>Global</td><td>当前打开的连接的数量。</td></tr><tr><td>Threads_created</td><td>Global</td><td>创建用来处理连接的线程数。如果Threads_created较大，你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections。</td></tr><tr><td>Threads_running</td><td>Global</td><td>激活的（非睡眠状态）线程数。</td></tr><tr><td>Uptime</td><td>Global</td><td>服务器已经运行的时间（以秒为单位）。</td></tr><tr><td>Uptime_since_flush_status</td><td>Global</td><td>最近一次使用FLUSH STATUS的时间（以秒为单位）。</td></tr></tbody></table><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;优化步骤&quot;&gt;&lt;a href=&quot;#优化步骤&quot; class=&quot;head
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>分析问题</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2-开发技能/数据库/Mysql/分析问题/</id>
    <published>2017-11-17T02:15:00.000Z</published>
    <updated>2017-12-03T16:04:44.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><ul><li>要学会怎样分析问题，而不是单纯拍脑袋优化</li><li>慢查询只是最基础的东西，要学会优化0.01秒的查询请求。</li><li>当发生连接阻塞时，不同状态的阻塞有不同的原因，要找到原因，如果不对症下药，就会南辕北辙<ul><li>范例：如果本身系统内存已经超载，已经使用到了swap，而还在考虑加大缓存来优化查询，那就是自寻死路了。</li></ul></li><li>影响结果集是非常重要的中间数据和优化指标，学会理解这一概念，理论上影响结果集与查询效率呈现非常紧密的线性相关。</li><li>监测与跟踪要经常做，而不是出问题才做<ul><li>读取频繁度抽样监测<ul><li>全监测不要搞，i/o吓死人。</li><li>按照一个抽样比例抽样即可。</li><li>针对抽样中发现的问题，可以按照特定SQL在特定时间内监测一段全查询记录，但仍要考虑i/o影响。</li></ul></li><li>写入频繁度监测<ul><li>基于binlog解开即可，可定时或不定时分析。</li></ul></li><li>微慢查询抽样监测<ul><li>高并发情况下，查询请求时间超过0.01秒甚至0.005秒的，建议酌情抽样记录。</li></ul></li><li>连接数预警监测<ul><li>连接数超过特定阈值的情况下，虽然数据库没有崩溃，建议记录相关连接状态。</li></ul></li></ul></li><li>学会通过数据和监控发现问题，分析问题，而后解决问题顺理成章。特别是要学会在日常监控中发现隐患，而不是问题爆发了才去处理和解决。</li></ul><h1 id="常见关注的重点"><a href="#常见关注的重点" class="headerlink" title="常见关注的重点"></a>常见关注的重点</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><ul><li><p>是否锁定，及锁定时间<br>如存在锁定，则该慢查询通常是因锁定因素导致，本身无需优化，需解决锁定问题。</p></li><li><p>影响结果集<br>如影响结果集较大，显然是索引项命中存在问题，需要认真对待。</p></li></ul><h2 id="Explain-操作"><a href="#Explain-操作" class="headerlink" title="Explain 操作"></a>Explain 操作</h2><ul><li><p>索引项使用<br>不建议用using index做强制索引，如未如预期使用索引，建议重新斟酌表结构和索引设置。</p></li><li><p>影响结果集<br>这里显示的数字不一定准确，结合之前提到对数据索引的理解来看，还记得嘛？就把索引当作有序序列来理解，反思SQL。</p></li></ul><h2 id="Set-profiling-show-profiles-for-query操作"><a href="#Set-profiling-show-profiles-for-query操作" class="headerlink" title="Set profiling , show profiles for query操作"></a>Set profiling , show profiles for query操作</h2><ul><li>执行开销<ul><li>注意，有问题的SQL如果重复执行，可能在缓存里，这时要注意避免缓存影响。通过这里可以看到。</li><li>执行时间超过0.005秒的频繁操作SQL建议都分析一下。</li><li>深入理解数据库执行的过程和开销的分布</li></ul></li></ul><h2 id="Show-processlist-执行状态监控"><a href="#Show-processlist-执行状态监控" class="headerlink" title="Show processlist 执行状态监控"></a>Show processlist 执行状态监控</h2><p>这是在数据库负载波动时经常进行的一项操作<br>具体参见：<a href="/技术之路/数据库/Mysql/优化/#执行状态">查看执行状态</a></p><h1 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h1><h2 id="确认问题"><a href="#确认问题" class="headerlink" title="确认问题"></a>确认问题</h2><p><strong>详细了解问题状况</strong></p><ul><li>Too many connections 是常见表象，有很多种原因。</li><li>索引损坏的情况在innodb情况下很少出现。</li><li>如出现其他情况应追溯日志和错误信息。</li></ul><h2 id="确认瓶颈"><a href="#确认瓶颈" class="headerlink" title="确认瓶颈"></a>确认瓶颈</h2><p><strong>常见的瓶颈</strong></p><ul><li><p>cpu 非常高–索引问题 or 并发太高（通常是索引问题）<br>并发问题：thread_pool 限制连接数（其他分支都支持线程池）</p></li><li><p>内存 swap高 – 内存分配不足（过多会 oom）<br>适量调整内存，不要太大也不要太小，50%-70%比较保守，80%太偏激，尽量覆盖全部热点数据<br>mysql 专用服务器，关闭 swap</p></li><li><p>iowait 太高 – 内存不足 or io 设备性能太低 or 索引不当 or 频繁读取 select  or 频繁排序/分组</p></li></ul><h3 id="了解基本运营状况"><a href="#了解基本运营状况" class="headerlink" title="了解基本运营状况"></a>了解基本运营状况</h3><ul><li>当前每秒读请求</li><li>当前每秒写请求</li><li>当前在线用户</li><li>当前数据容量</li></ul><h3 id="了解基本负载情况"><a href="#了解基本负载情况" class="headerlink" title="了解基本负载情况"></a>了解基本负载情况</h3><p>学会使用这些指令</p><ul><li>Top –系统状态，哪个服务/进程消耗的 cpu 、内存</li><li>Vmstat – 查看 cpu、io、内存负载</li><li>dstat – 和 vmstat 类似，结果更友好</li><li>sar – systat 工具包的一个命令；关注（sar  -u / -d / -r）cpu/io/内存</li><li>iotop – 查看哪个进程 io 消耗最高</li><li>oprofile – 神器，一般用不上，用法自己查</li><li>strace – 跟踪进程执行时的系统调用和所接收的信号</li><li>uptime</li><li>iostat</li><li>df</li></ul><p>Cpu负载构成</p><ul><li>特别关注i/o压力( wa%)</li><li>多核负载分配</li></ul><p>内存占用</p><ul><li>Swap分区是否被侵占，若Swap分区被侵占，物理内存是否较多空闲</li></ul><p>磁盘状态</p><ul><li>硬盘满和inode节点满的情况要迅速定位和迅速处理</li></ul><h3 id="查看-mysql-的状态"><a href="#查看-mysql-的状态" class="headerlink" title="查看 mysql 的状态"></a>查看 mysql 的状态</h3><p><strong>当前连接数</strong></p><ul><li>Netstat –an|grep 3306|wc –l</li><li>Show processlist</li></ul><p><strong>当前连接分布 show processlist</strong></p><ul><li>前端应用请求数据库不要使用root帐号！<ul><li>Root帐号比其他普通帐号多一个连接数许可。</li><li>前端使用普通帐号，在too many connections的时候root帐号仍可以登录数据库查询 show processlist!</li><li>记住，前端应用程序不要设置一个不叫root的root帐号来糊弄！非root账户是骨子里的，而不是名义上的。</li></ul></li><li>状态分布<ul><li>不同状态代表不同的问题，有不同的优化目标。</li></ul></li><li>雷同SQL的分布<ul><li>是否较多雷同SQL出现在同一状态</li></ul></li></ul><p><strong>当前是否有较多慢查询日志</strong></p><ul><li>是否锁定</li><li>影响结果集</li></ul><p><strong>常用命令</strong></p><ul><li><p>slow log<br>优先频次高，其次耗时久</p></li><li><p>show global status</p><ol><li>查看连接数（活跃、不活跃），设置 interactive_timeout、wait_timeout 的 timecount值，减少不活跃连接</li><li>TPS、QPS、DML_Active<ul><li>tps=(handler_commit_d+handler_rollback_d)/uptime_d</li><li>qps=(questions_d2 - questions_d1)/uptime_d</li><li>dml_active=(com_select_d+com_insert_d+com_update_d+com_delete_d)/uptime_d</li></ul></li><li>各种 buffer、cache 的利用率、命中率<ul><li>innodb_buffer_pool_wait_free&gt;0 说明 innodb_buffer 不够用,有 wait、wait_free 发生，都要关注下</li><li>innodb_row_lock_current_waits 当前行锁的个数</li><li>slow_queries 慢查询的次数</li><li>table_locks_immediate 表锁的次数</li><li>table_locks_waited 表锁等待的次数</li></ul></li></ol></li><li><p>show processlist</p></li><li><p>show engine innodb status<br>主要看锁，事务，等待</p></li><li><p>pt-ioprofile<br>可以查看哪个表在频繁的读写</p></li></ul><h3 id="频繁度分析"><a href="#频繁度分析" class="headerlink" title="频繁度分析"></a>频繁度分析</h3><ul><li>写频繁度<ul><li>如果i/o压力高，优先分析写入频繁度</li><li>Mysqlbinlog 输出最新binlog文件，编写脚本拆分</li><li>最多写入的数据表是哪个</li><li>最多写入的数据SQL是什么</li><li>是否存在基于同一主键的数据内容高频重复写入？<ul><li>涉及架构优化部分，参见架构优化-缓存异步更新</li></ul></li></ul></li><li>读取频繁度<ul><li>如果cpu资源较高，而i/o压力不高，优先分析读取频繁度</li><li>程序中在封装的db类增加抽样日志即可，抽样比例酌情考虑，以不显著影响系统负载压力为底线。</li><li>最多读取的数据表是哪个</li><li>最多读取的数据SQL是什么<ul><li>该SQL进行explain 和set profiling判定</li><li>注意判定时需要避免query cache影响<ul><li>比如，在这个SQL末尾增加一个条件子句 and 1=1 就可以避免从query cache中获取数据，而得到真实的执行状态分析。</li></ul></li></ul></li><li>是否存在同一个查询短期内频繁出现的情况<ul><li>涉及前端缓存优化</li></ul></li></ul></li></ul><h2 id="制定方案"><a href="#制定方案" class="headerlink" title="制定方案"></a>制定方案</h2><p>抓大放小，解决显著问题</p><ul><li>不苛求解决所有优化问题，但是应以保证线上服务稳定可靠为目标。</li><li>解决与评估要同时进行，新的策略或解决方案务必经过评估后上线。</li></ul><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>确认优化方案的覆盖范围，不要为了解决1%的问题而忽略了99%的问题，并且不能带来新的问题（索引滥用，太多索引，导致 dml 效率降低）而且最好再测试环境验证通过后再上线</p><h2 id="实施方案"><a href="#实施方案" class="headerlink" title="实施方案"></a>实施方案</h2><h2 id="回顾反馈"><a href="#回顾反馈" class="headerlink" title="回顾反馈"></a>回顾反馈</h2><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="服务器出现too-many-connections-阻塞"><a href="#服务器出现too-many-connections-阻塞" class="headerlink" title="服务器出现too many connections 阻塞"></a>服务器出现too many connections 阻塞</h2><p>入手点：</p><ul><li>查看服务器状态，cpu占用，内存占用，硬盘占用，硬盘i/o压力</li><li>查看网络流量状态，mysql与应用服务器的输入输出状况</li><li>通过Show processlist查看当前运行清单</li><li>注意事项，日常应用程序连接数据库不要使用root账户，保证故障时可以通过root 进入数据库查看 show processlist。</li></ul><p>状态分析：</p><ul><li>参见如上执行状态清单，根据连接状态的分布去确定原因。</li></ul><p>紧急恢复</p><ul><li>在确定故障原因后，应通过kill掉阻塞进程的方式 立即恢复数据库。</li></ul><p>善后处理：以下针对常见问题简单解读</p><ul><li>Sleep 连接过多导致，应用端及时释放连接，排查关联因素。</li><li>Locked连接过多，如源于myisam表级锁，更innodb引擎;如源于更新操作使用了不恰当的索引或未使用索引，改写更新操作SQL或建立恰当索引。</li><li>Sending data连接过多，用影响结果集的思路优化SQL查询，优化表索引结构。</li><li>Free items连接过多，i/o压力过大 或硬盘故障</li><li>Waiting for net , writing to net 连接过多， mysql与应用服务器连接阻塞。</li><li>其他仍参见如上执行状态清单所示分析。</li><li>如涉及不十分严格安全要求的数据内容，可用定期脚本跟踪请求进程，并kill掉僵死进程。如数据安全要求较严格，则不能如此进行。</li></ul><h2 id="数据库负载过高，响应缓慢"><a href="#数据库负载过高，响应缓慢" class="headerlink" title="数据库负载过高，响应缓慢"></a>数据库负载过高，响应缓慢</h2><p><strong>入手点：</strong></p><ul><li>查看cpu状态，服务器负载构成</li></ul><p><strong>可能问题1：i/o占用过高</strong></p><ul><li>步骤1： 检查内存是否占用swap分区，排除因内存不足导致的i/o开销。</li><li>步骤2：通过iostat 指令分析i/o是否集中于数据库硬盘，是否是写入度较高。</li><li>步骤3：如果压力来自于写，使用mysqlbinlog 解开最新的binlog文件。</li><li>步骤4：编写日志分析脚本或grep指令，分析每秒写入频度和写入内容。<ul><li>写入频度不高，则说明i/o压力另有原因或数据库配置不合理。</li></ul></li><li>步骤5：编写日志分析脚本或grep 指令，分析写入的数据表构成，和写入的目标构成。</li><li>步骤6：编写日志分析脚本，分析是否存在同一主键的重复写入。 比如出现大量 update post set views=views+1 where tagid=的操作，假设在一段时间内出现了2万次，而其中不同的tagid有1万次，那么就是有50%的请求是重复update请求，有可以通过异步更新合并的空间。</li></ul><p>提示一下，以上所提及的日志分析脚本编写，正常情况下不应超过1个小时，而对系统负载分析所提供的数据支持价值是巨大的，对性能优化方案的选择是非常有意义的，如果您认为这项工作是繁冗而且复杂的工作，那么一定是在分析思路和目标把握上出现了偏差。</p><p><strong>可能问题2：i/o占用不高，CPU 占用过高</strong></p><ul><li>步骤1：查看慢查询日志</li><li>步骤2：不断刷新查看Show processlist清单，并把握可能频繁出现的处于Sending data状态的SQL。</li><li>步骤3：记录前端执行SQL<ul><li>于前端应用程序执行查询的封装对象内，设置随机采样，记录前端执行的SQL，保证有一定的样本规模，并且不会带来前端i/o负载的激增。</li><li>基于采样率和记录频率，获得每秒读请求次数数据指标。</li><li>编写日志分析脚本，分析采样的SQL构成，所操作的数据表，所操作的主键。</li><li>对频繁重复读取的SQL(完全一致的SQL)进行判定，是否数据存在频繁变动，是否需要实时展现最新数据，如有可能，缓存化，并预估缓存命中率。</li><li>对频繁读取但不重复的(SQL结构一致，但条件中的数据不一致)SQL进行判定，是否索引足够优化，影响结果集与输出结果是否足够接近。</li></ul></li><li>步骤4：将导致慢查询的SQL或频繁出现于show processlist状态的SQL，或采样记录的频繁度SQL进行分析，按照影响结果集的思路和索引理解来优化。</li><li>步骤5：对如上难以界定问题的SQL进行 set profiling 分析。</li><li>步骤6：优化后分析继续采样跟踪分析。并跟踪比对结果。</li></ul><p><strong>善后处理</strong></p><ul><li>日常跟踪脚本，不断记录一些状态信息。保证每个时间节点都能回溯。</li><li>确保随时能了解服务器的请求频次，读写请求的分布。</li><li>记录一些未造成致命影响的隐患点，可暂不解决，但需要记录。</li><li>如确系服务器请求频次过高，可基于负载分布决定硬件扩容方案，比如i/o压力过高可考虑固态硬盘；内存占用swap可考虑增加内容容量等。用尽可能少的投入实现最好的负载支撑能力，而不是简单的买更多服务器。</li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;head
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title> 架构与表设计</title>
    <link href="http://yoursite.com/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2-开发技能/数据库/Mysql/架构与表设计/</id>
    <published>2017-11-16T15:35:00.000Z</published>
    <updated>2017-12-03T16:04:44.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ol><li><strong>默认使用innodb 引擎</strong>，基本抛弃 myisam（只读也不一定比 innodb 快）</li><li><strong>text/blob 垂直拆分后，转成 myisam 表</strong>，innodb 存 blob 会产生大量的磁盘碎片</li></ol><p>各存储引擎区别：<a href="/技术之路/数据库/Mysql/基础知识/#数据引擎">存储引擎</a></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><strong>默认使用utf-8</strong></p><p>注意字符集问题，server=&gt;database(trigger、stored procedure、event scheduler)=&gt;table=&gt;column<br>不要同时指定字符集（character set）和校验集（collect set），避免出现和默认对应关系不一致</p><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol><li>越小越好</li><li>字段都NOT NULL<ul><li>默认都加上NOT NULL约束，必须为NULL用0表示</li><li>在对该字段进行COUNT(*)统计时，统计结果更准确（值为NULL的不会被COUNT统计进去）</li></ul></li></ol><h3 id="存储技巧"><a href="#存储技巧" class="headerlink" title="存储技巧"></a>存储技巧</h3><ol><li><p><strong>可使用枚举类型</strong><br>ENUM的内部存储机制是采用TINYINT或SMALLINT（并非CHAR/VARCHAR），性能一点都不差</p></li><li><p><strong>存储ipv4地址</strong><br>用INT UNSIGNED存储IPV4地址，用INET_ATON()、INET_NTOA()进行转换</p></li><li><p><strong>存储日期时间</strong><br><strong>一个常识性误导：建议用TIMESTAMP取代DATETIME。</strong><br>从5.6开始，建议优先选择DATETIME存储日期时间。因为它的可用范围比TIMESTAMP更大，物理存储上仅比TIMESTAMP多1个字节，整体性能上的损失并不大。</p></li><li><p><strong>InnoDB表行记录物理长度不超过8KB</strong><br><strong>InnoDB的data page默认是16KB的情况下。</strong><br>当实际存储长度超过8KB（尤其有TEXT/BLOB列）且读写频繁的话, 则最好把这些列拆分到子表中，不要和主表放在一起存储。如果不太频繁，可以考虑继续保留在主表中<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率">[1]</span></a></sup>。</p></li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol><li>显式指定自增 int/bigint unsigned not null 作为主键(有主键 TPS 提升9%，不要使用 uuid，性能差)</li><li>选择适当的索引顺序，选择性高条件靠前</li><li>基数（ Cardinality ）很低（30%以下）的字段不创建索引（MySQL还不支持 bitmap 索引）</li><li>常用排序（ORDER BY）、分组（GROUP BY）、取唯一（DISTINCT）字段上创建索引</li><li>单表索引数量不超过5个</li><li>不使用外键</li><li>超过20个长度的字符串列（不需要排序），创建前缀索引而非整列索引<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="例如：`ALTER TABLE t1 ADD INDEX(user(20))`前缀索引的长度可以基于对该字段的统计得出，一般略大于平均长度一点就可以了。">[6]</span></a></sup><ul><li>优点:有效提高索引利用率</li><li>缺点:对这个列排序时用不到前缀索引</li></ul></li></ol><h2 id="高级特性使用"><a href="#高级特性使用" class="headerlink" title="高级特性使用"></a>高级特性使用</h2><ol><li><p><strong>是否使用分区表？</strong><br>在可以提升性能或者运维便利性的场景下，还是建议使用分区表。例如：日志系统，按时间纬度进行分区，方便删除历史数据</p></li><li><p><strong>是否使用存储过程、触发器？</strong><br>单机可用，分布式舍弃。（存储器场景：不变的业务逻辑）</p></li><li><p><strong>是否使用视图？</strong><br>MySQL因为没有物化视图，因此视图尽量少用（不用）</p></li></ol><h1 id="缓存与数据库结合"><a href="#缓存与数据库结合" class="headerlink" title="缓存与数据库结合"></a>缓存与数据库结合</h1><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以减少数据库读取请求<br>缺点：增加代码复杂度、增加维护难度</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul><li>评估进入缓存的数据规模，以及命中率优化<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实景分析： 前端请求先连接缓存，缓存未命中连接数据库，进行查询，未命中状态比单纯连接数据库查询多了一次连接和查询的操作；如果缓存命中率很低，则这个额外的操作非但不能提高查询效率，反而为系统带来了额外的负载和复杂性，得不偿失。">[2]</span></a></sup><ul><li>不是所有数据都适合被缓存，也并不是进入了缓存就意味着效率提升</li><li>命中率是第一要评估的数据；<strong>核心在于如何判断哪些属于热点数据</strong></li></ul></li><li>善于利用内存，请注意数据存储的格式及压缩算法。</li></ul><h3 id="如何确定热点数据"><a href="#如何确定热点数据" class="headerlink" title="如何确定热点数据"></a>如何确定热点数据</h3><p>见<a href="#热点数据分表">下文</a></p><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：减少数据库写入<code>i/o</code>压力<br>缺点：数据不能第一时间持久化，有丢失风险</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h3><p>缓存实时更新，数据库异步更新（使用队列,请注意使用<code>increment</code>来维持队列序号）</p><ul><li>不要通过<code>get-&gt;处理数据-&gt;set-&gt;更新数据</code>的方式维护队列<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例:`$var=Memcache_get($memcon,”var”);$var++;memcache_set($memcon,”var”,$var);`这样一个脚本，使用apache ab去跑，100个并发，跑10000次，然后输出缓存存取的数据，很遗憾，并不是1000，而是5000多，6000多这样的数字，中间的数字全在 get & set的过程中丢掉了。原因：读写间隔中其他并发写入，导致数据丢失。">[3]</span></a></sup>。 使用<code>increment</code>存储队列编号，用标记+编号作为<code>key</code>存储队列内容<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例2:用memcache_increment来做这个操作，同样跑测试会得到完整的10000，一条数据不会丢。">[4]</span></a></sup>。</li><li>后台基于缓存队列读取更新数据并更新数据库<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：某论坛热门贴，前端不断有views=views+1数据更新请求。缓存实时更新该状态后台任务对数据库做异步更新时，假设执行周期是5分钟，那么五分钟可能会接收到这样的请求多达数十次乃至数百次，合并更新后只执行一次update即可。类似操作还包括游戏打怪，生命和经验的变化；个人主页访问次数的变化等。">[5]</span></a></sup><ul><li>基于队列读取后可以合并更新</li><li><strong>更新合并率</strong>是重要指标</li></ul></li></ul><h3 id="异步更新风险"><a href="#异步更新风险" class="headerlink" title="异步更新风险"></a>异步更新风险</h3><ul><li><strong>前后端同时写，可能导致覆盖风险。</strong><ul><li>使用后端异步更新，前端应用程序不要写数据库，否则可能造成写入冲突。</li><li>一种兼容的解决方案是，前端和后端不要写相同的字段<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：用户在线上时，后台异步更新用户状态。管理员后台屏蔽用户是直接更新数据库。结果管理员屏蔽某用户操作完成后，因该用户在线有操作，后台异步更新程序再次基于缓存更新用户状态，用户状态被复活，屏蔽失效。">[7]</span></a></sup>。</li></ul></li><li><strong>缓存数据丢失或服务崩溃可能导致数据丢失风险。</strong><ul><li>如缓存中间出现故障，则缓存队列数据不会回写到数据库，而用户会认为已经完成，此时会带来比较明显的用户体验问题。</li><li>一个不彻底的解决方案是，确保高安全性，高重要性数据实时数据更新，而低安全性数据通过缓存异步回写方式完成。此外，使用相对数值操作而不是绝对数值操作更安全<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例：支付信息，道具的购买与获得，一旦丢失会对用户造成极大的伤害。而经验值，访问数字，如果只丢失了很少时间的内容，用户还是可以容忍的。">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例：如果使用 `Views=Views+…`的操作，一旦出现数据格式错误，从binlog中反推是可以进行数据还原，但是如果使用Views=特定值的操作，一旦缓存中数据有错误，则直接被赋予了一个错误数据，无法回溯！">[9]</span></a></sup>。</li></ul></li><li><strong>异步更新如出现队列阻塞可能导致数据丢失风险。</strong><ul><li>异步更新通常是使用缓存队列后，在后台由cron或其他守护进程写入数据库。</li><li>如果队列生成的速度&gt;后台更新写入数据库的速度，就会产生阻塞，导致数据越累计越多，数据库响应迟缓，而缓存队列无法迅速执行，导致溢出或者过期失效。</li><li>解决办法：使用 MQ 队列产品而不使用 memcache 来进行缓存异步更新</li></ul></li></ul><h1 id="反范式设计（冗余）"><a href="#反范式设计（冗余）" class="headerlink" title="反范式设计（冗余）"></a>反范式设计（冗余）</h1><ul><li>适度冗余可以减少查询请求</li><li>适度冗余可以解决分表带来的索引查询问题</li><li>适度冗余可以解决统计类负载较高的查询问题</li><li>适度冗余可以减少 io 请求频次，提高 io 支撑能力(cpu 换 io)</li></ul><h2 id="反范式设计的概念"><a href="#反范式设计的概念" class="headerlink" title="反范式设计的概念"></a>反范式设计的概念</h2><ul><li>无外键，无连表查询，强调索引,去关联化</li><li>不考虑触发器及其他内部的存储过程</li><li>便于分布式设计，允许适度冗余，为了容量扩展允许适度开销。</li><li>基于业务自由优化，基于i/o 或查询设计，无须遵循范式结构设计。</li></ul><h2 id="冗余结构设计所面临的典型场景"><a href="#冗余结构设计所面临的典型场景" class="headerlink" title="冗余结构设计所面临的典型场景"></a>冗余结构设计所面临的典型场景</h2><ul><li>原有展现程序涉及多个表的查询，希望精简查询程序</li><li>数据表拆分往往基于主键，而原有数据表往往存在非基于主键的关键查询，无法在分表结构中完成。</li><li>存在较多数据统计需求（count, sum等），效率低下。</li></ul><h2 id="冗余造成的问题"><a href="#冗余造成的问题" class="headerlink" title="冗余造成的问题"></a>冗余造成的问题</h2><p>一致性问题–业务层校验</p><h2 id="冗余设计方案"><a href="#冗余设计方案" class="headerlink" title="冗余设计方案"></a>冗余设计方案</h2><h3 id="基于展现的冗余设计"><a href="#基于展现的冗余设计" class="headerlink" title="基于展现的冗余设计"></a>基于展现的冗余设计</h3><p>冗余特征：字段简单，更改度不高<br>为了简化展现程序，在一些数据表中往往存在冗余字段<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：论坛板块的发帖量，回帖量，每日新增数据等。网站每日新增用户数等。参见Discuz论坛系统数据结构，有较多相关结构。参见前文分段积分结构，是典型用于统计的冗余结构。后台可以通过源数据表更新该数字。Redis的Zset类型可以理解为存在一种冗余统计结构。">[13]</span></a></sup></p><h3 id="基于查询的冗余设计"><a href="#基于查询的冗余设计" class="headerlink" title="基于查询的冗余设计"></a>基于查询的冗余设计</h3><ul><li>涉及分表操作后，一些常见的索引查询可能需要跨表，带来不必要的麻烦。确认查询请求远大于写入请求时，应设置便于查询项的冗余表。</li><li>冗余表要点<ul><li>数据一致性，简单说：同增，同删，同更新。</li><li>可以做全冗余，或者只做主键关联的冗余，比如通过用户名查询uid，再基于uid查询源表。</li></ul></li></ul><p>实战示例<sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例1: 用户分表将用户库分成若干数据表;基于用户名的查询和基于uid的查询都是高并发请求。用户分表基于uid分成数据表，同时基于用户名做对应冗余表。如果允许多方式登陆，可以有如下设计方法：`uid,passwd,用户信息等等，主数据表，基于uid分表``ukey,ukeytype,uid 基于ukey分表，便于用户登陆的查询。分解成如下两个SQL:``select uid from ulist_key_13 where ukey=’$username’ and ukeytype=‘login’;``select * from ulist_uid_23 where uid=$uid and passwd=’$passwd’;``ukeytype定义用户的登陆依据，比如用户名，手机号，邮件地址，网站昵称等。 Ukey+ukeytype 必须唯一``此种方式需要登陆密码统一，对于第三方connect接入模式，可以通过引申额外字段完成`">[10]</span></a></sup><sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例2：用户游戏积分排名表结构 uid,gameid,score 参见前文实时积分排行。表内容巨大，需要拆表。需求1：基于游戏id查询积分排行需求2：基于用户id查询游戏积分记录解决方案：建立完全相同的两套表结构，其一以uid为拆表主键，其二以gameid为拆表主键，用户提交积分时，向两个数据结构同时提交。">[11]</span></a></sup><sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例3：全冗余查询结构主信息表仅包括 主键及备注memo字段（text类型），只支持主键查询，可以基于主键拆表。所以需要展现和存储的内容均在memo字段重体现。对每一个查询条件，建立查询冗余表，以查询条件字段为主键，以主信息表主键id 为内容。日常查询只基于查询冗余表，然后通过in的方式从主信息表获得内容。优点是结构扩展非常方便，只需要扩展新的查询信息表即可，核心思路是，只有查询才需要独立的索引结构，展现无需独立字段。缺点是只适合于相对固定的查询架构，对于更加灵活的组合查询束手无策。">[12]</span></a></sup></p><h3 id="基于统计的冗余结构"><a href="#基于统计的冗余结构" class="headerlink" title="基于统计的冗余结构"></a>基于统计的冗余结构</h3><ul><li>为了减少会涉及大规模影响结果集的表数据操作，比如count，sum操作。应将一些统计类数据通过冗余数据结构保存。</li><li>冗余数据结构可能以字段方式存在，也可能以独立数据表结构存在，但是都应能通过源数据表恢复。</li></ul><p>实战示例<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：论坛板块的发帖量，回帖量，每日新增数据等。网站每日新增用户数等。参见Discuz论坛系统数据结构，有较多相关结构。参见前文分段积分结构，是典型用于统计的冗余结构。后台可以通过源数据表更新该数字。Redis的Zset类型可以理解为存在一种冗余统计结构。">[13]</span></a></sup></p><h3 id="基于-io-压力优化的冗余"><a href="#基于-io-压力优化的冗余" class="headerlink" title="基于 io 压力优化的冗余"></a>基于 io 压力优化的冗余</h3><p><strong>现象：</strong></p><p>单次请求多次写入的情况</p><ul><li>请求频次较高，io 压力较大</li><li>存在高频读取请求，数据可靠性要求高</li></ul><p><strong>可用方案:</strong></p><ul><li>数据压缩存储</li><li>写入缓存队列</li><li>通过冗余结构，合并为一次写入<sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="游戏组队，5个武将。（建立临时的武将表，定时更新到主表）">[14]</span></a></sup><sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实时统计">[15]</span></a></sup></li></ul><h3 id="历史数据表"><a href="#历史数据表" class="headerlink" title="历史数据表"></a>历史数据表</h3><p>历史数据表对应于热点数据表，将需求较少又不能丢弃的数据存入，仅在少数情况下被访问。</p><h1 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h1><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul><li>读写分离对负载的减轻远远不如分库分表来的直接。</li><li>写压力会传递给从表，只读从库一样有写压力，一样会产生读写锁！</li><li>一主多从结构下，主库是单点隐患，很难解决（如主库当机，从库可以响应读写，但是无法自动担当主库的分发功能）</li><li>主从延迟也是重大问题。一旦有较大写入问题，如表结构更新，主从会产生巨大延迟。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>部署简单</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul><li>io 压力无法分布，性价比不高（主是多线程写，从是单线程写；分担读压力，不能分担写压力）</li><li>同步延时避免不了</li><li>一主多从，主库单点，很难自动故障转移（一从转主，其他从不能自动关联到这个新主）</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一主一从</p><ul><li>在线热备</li><li>异地分布<ul><li>写分布，读统一。</li><li>仍然困难重重，受限于网络环境问题巨多！</li></ul></li><li>自动障碍转移<ul><li>主崩溃，从自动接管</li></ul></li><li>个人建议，负载均衡主要使用分库方案，主从主要用于热备和障碍转移。</li></ul><h2 id="潜在优化点"><a href="#潜在优化点" class="headerlink" title="潜在优化点"></a>潜在优化点</h2><p>为了减少写压力，有些人建议主不建索引提升i/o性能，从建立索引满足查询要求。个人认为这样维护较为麻烦。而且从本身会继承主的i/o压力，因此优化价值有限。该思路特此分享，不做推荐(caoz观点)。</p><h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><ul><li>设计分布式之前，先优化单机：</li><li>单机读 qps 几千很容易</li><li>单机写 qps 几千很容易</li><li>数据量最少在3000万以上（具体业务具体分析）</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="防止单点隐患"><a href="#防止单点隐患" class="headerlink" title="防止单点隐患"></a>防止单点隐患</h3><p><strong>lvs nginx（轮询，自动切换）</strong></p><ul><li>所谓单点隐患，就是某台设备出现故障，会导致整体系统的不可用，这个设备就是单点隐患。</li><li>理解连带效应，所谓连带效应，就是一种问题会引发另一种故障，举例而言，memcache+mysql是一种常见缓存组合，在前端压力很大时，如果memcache崩溃，理论上数据会通过mysql读取，不存在系统不可用情况，但是mysql无法对抗如此大的压力冲击，会因此连带崩溃。因A系统问题导致B系统崩溃的连带问题，在运维过程中会频繁出现。<sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例： 在mysql连接不及时释放的应用环境里，当网络环境异常（同机房友邻服务器遭受拒绝服务攻击，出口阻塞），网络延迟加剧，空连接数急剧增加，导致数据库连接过多崩溃。">[16]</span></a></sup><sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：前端代码 通常我们封装 mysql_connect和memcache_connect，二者的顺序不同，会产生不同的连带效应。如果mysql_connect在前，那么一旦memcache连接阻塞，会连带mysql空连接过多崩溃。">[17]</span></a></sup><ul><li>连带效应是常见的系统崩溃，日常分析崩溃原因的时候需要认真考虑连带效应的影响，头疼医头，脚疼医脚是不行的。</li></ul></li></ul><h3 id="方便系统扩容"><a href="#方便系统扩容" class="headerlink" title="方便系统扩容"></a>方便系统扩容</h3><ul><li>数据容量增加后，要考虑能够将数据分布到不同的服务器上。</li><li>请求压力增加时，要考虑将请求压力分布到不同服务器上。</li><li>扩容设计时需要考虑防止单点隐患。</li></ul><h3 id="安全可控，成本可控"><a href="#安全可控，成本可控" class="headerlink" title="安全可控，成本可控"></a>安全可控，成本可控</h3><ul><li>数据安全，业务安全</li><li>人力资源成本 &gt; 带宽流量成本 &gt; 硬件成本<ul><li>成本与流量的关系曲线应低于线性增长（流量为横轴，成本为纵轴）。</li><li>规模优势</li></ul></li></ul><h2 id="分库-amp-分表"><a href="#分库-amp-分表" class="headerlink" title="分库&amp;分表"></a>分库&amp;分表</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>负载分担较好</li><li>不存在同步延迟</li><li>拆分方法灵活</li></ul><h3 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h3><ul><li>需要有备份和自动故障转移的方案</li><li>需要应用端配合，无法完全满足关联查询的需求</li></ul><h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><ul><li>以分库、分表为负载和数据支撑方案</li><li>以主从结构为热备和故障转移方案</li><li>使用中间件作为分布式数据库的前端（amoeba，要去关联化）</li><li>数据一致性问题解决<ul><li>前端校验</li><li>后端 cron 定时跑数据</li></ul></li></ul><h3 id="基本认识-1"><a href="#基本认识-1" class="headerlink" title="基本认识"></a>基本认识</h3><ul><li>用分库&amp;拆表是解决数据库容量问题的唯一途径。</li><li>分库&amp;拆表也是解决性能压力的最优选择。</li><li>分库 – 不同的数据表放到不同的数据库服务器中（也可能是虚拟服务器）</li><li>拆表 – 一张数据表拆成多张数据表，可能位于同一台服务器，也可能位于多台服务器（含虚拟服务器）。</li></ul><h3 id="去关联化原则"><a href="#去关联化原则" class="headerlink" title="去关联化原则"></a>去关联化原则</h3><ul><li>摘除数据表之间的关联，是分库的基础工作。</li><li>摘除关联的目的是，当数据表分布到不同服务器时，查询请求容易分发和处理。</li><li>学会理解反范式数据结构设计，所谓反范式，第一要点是不用外键，不允许Join操作，不允许任何需要跨越两个表的查询请求。第二要点是适度冗余减少查询请求<sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="比如说，信息表，fromuid, touid, message字段外，还需要一个fromuname字段记录用户名，这样查询者通过touid查询后，能够立即得到发信人的用户名，而无需进行另一个数据表的查询。">[18]</span></a></sup></li><li>去关联化处理会带来额外的考虑，比如说，某一个数据表内容的修改，对另一个数据表的影响。这一点需要在程序或其他途径去考虑。</li></ul><h3 id="分库方案"><a href="#分库方案" class="headerlink" title="分库方案"></a>分库方案</h3><h4 id="安全性拆分"><a href="#安全性拆分" class="headerlink" title="安全性拆分"></a>安全性拆分</h4><p>运维优化，易于管理</p><ul><li>将高安全性数据与低安全性数据分库，这样的好处第一是便于维护，第二是高安全性数据的数据库参数配置可以以安全优先，而低安全性数据的参数配置以性能优先。参见运维优化相关部分。</li><li>安全性开启参数：sync_binlog，innodb_flush_log_at_trx_commit = 2(丢失最后1s 数据);开启后性能下降10~100倍</li></ul><h4 id="基于业务逻辑拆分"><a href="#基于业务逻辑拆分" class="headerlink" title="基于业务逻辑拆分"></a>基于业务逻辑拆分</h4><p>易于管理，对应用端友好，负载不能均分</p><ul><li>根据数据表的内容构成，业务逻辑拆分，便于日常维护和前端调用。</li><li>基于业务逻辑拆分，可以减少前端应用请求发送到不同数据库服务器的频次，从而减少链接开销。</li><li>基于业务逻辑拆分，可保留部分数据关联，前端web工程师可在限度范围内执行关联查询。</li></ul><h4 id="基于负载压力拆分"><a href="#基于负载压力拆分" class="headerlink" title="基于负载压力拆分"></a>基于负载压力拆分</h4><p>负载相对可以均摊；管理不方便</p><ul><li>基于负载压力对数据结构拆分，便于直接将负载分担给不同的服务器。</li><li>基于负载压力拆分，可能拆分后的数据库包含不同业务类型的数据表，日常维护会有一定的烦恼。</li></ul><h4 id="混合拆分组合"><a href="#混合拆分组合" class="headerlink" title="混合拆分组合"></a>混合拆分组合</h4><ul><li>基于安全与业务拆分为数据库实例，但是可以使用不同端口放在同一个服务器上。</li><li>基于负载可以拆分为更多数据库实例分布在不同数据库上</li></ul><p>例如:</p><ul><li>基于安全拆分出A数据库实例，</li><li>基于业务拆分出B,C数据库实例，</li><li>C数据库存在较高负载，基于负载拆分为C1,C2,C3,C4等 实例。</li><li>数据库服务器完全可以做到 A+B+C1为一台，C2,C3,C4各单独一台。</li></ul><h3 id="分表方案"><a href="#分表方案" class="headerlink" title="分表方案"></a>分表方案</h3><p>数据量过大或者访问压力过大的数据表需要切分</p><h4 id="纵向分表（常见为忙闲分表）"><a href="#纵向分表（常见为忙闲分表）" class="headerlink" title="纵向分表（常见为忙闲分表）"></a>纵向分表（常见为忙闲分表）</h4><ul><li>单数据表字段过多，可将频繁更新的整数数据与非频繁更新的字符串数据切分<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例: user表 ，个人简介，地址，QQ号，联系方式，头像 这些字段为字符串类型，更新请求少； 最后登录时间，在线时常，访问次数，信件数这些字段为整数型字段，更新频繁，可以将后面这些更新频繁的字段独立拆出一张数据表，表内容变少，索引结构变少，读写请求变快。">[19]</span></a></sup></li><li>过于频繁的，使用 nosql（memcached，redis 等）</li></ul><h4 id="横向切表"><a href="#横向切表" class="headerlink" title="横向切表"></a>横向切表</h4><ul><li>等分切表，如哈希切表或其他基于对某数字取余的切表。等分切表的优点是负载均分；缺点是当容量继续增加时无法方便的扩容，需要重新进行数据的切分或转表。而且一些关键主键不易处理。（只能基于差存条件进行拆分，否则没法查询）</li><li>递增切表，比如每1kw用户开一个新表，优点是可以适应数据的自增趋势；缺点是往往新数据负载高（最新的表），压力分配不平均。</li><li>日期切表，适用于日志记录式数据，优缺点等同于递增切表。</li><li>个人倾向于递增切表，具体根据应用场景决定。</li></ul><h4 id="热点数据分表"><a href="#热点数据分表" class="headerlink" title="热点数据分表"></a>热点数据分表</h4><p>将数据量较大的数据表中将读写频繁的数据抽取出来，形成热点数据表。通常一个庞大数据表经常被读写的内容往往具有一定的集中性，如果这些集中数据单独处理，就会极大减少整体系统的负载。</p><p><strong>热点数据表与旧有数据关系:</strong></p><ul><li>可以是一张冗余表，即该表数据丢失不会妨碍使用，因源数据仍存在于旧有结构中。优点是安全性高，维护方便，缺点是写压力不能分担，仍需要同步写回原系统。</li><li>可以是非冗余表，即热点数据的内容原有结构不再保存，优点是读写效率全部优化；缺点是当热点数据发生变化时，维护量较大。</li><li>具体方案选择需要根据读写比例决定，在读频率远高于写频率情况下，优先考虑冗余表方案。</li></ul><p><strong>数据存储：</strong><br>热点数据表可以用单独的优化的硬件存储，比如昂贵的闪存卡或大内存系统。</p><p><strong>热点数据表的重要指标:</strong></p><ul><li>热点数据的定义需要根据业务模式自行制定策略，常见策略为，按照最新的操作时间；按照内容丰富度等等。</li><li>数据规模，比如从1000万条数据，抽取出100万条热点数据。</li><li>热点命中率，比如查询10次，多少次命中在热点数据内。</li><li>理论上，数据规模越小，热点命中率越高，说明效果越好。需要根据业务自行评估。</li></ul><p><strong>热点数据表的动态维护:</strong></p><ul><li>加载热点数据方案选择<ul><li>定时从旧有数据结构中按照新的策略获取</li><li>在从旧有数据结构读取时动态加载到热点数据</li></ul></li><li>剔除热点数据方案选择<ul><li>基于特定策略，定时将热点数据中访问频次较少的数据剔除</li><li>如热点数据是冗余表，则直接删除即可，如不是冗余表，需要回写给旧有数据结构。</li></ul></li></ul><p>通常，热点数据往往是基于缓存或者key-value方案冗余存储，所以这里提到的热点数据表，其实更多是理解思路，用到的场合可能并不多。（适合组合条件场景，数据规模中等，像淘宝的数据量就需要第三方搜索引擎）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://imysql.com/2014/09/28/mysql-optimization-case-blob-stored-in-innodb-optimization.shtml" rel="external nofollow noopener noreferrer" target="_blank">[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率</a></li><li>《Mysql 性能优化教程-曹政》</li></ul><!--以下是脚注--><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实景分析： 前端请求先连接缓存，缓存未命中连接数据库，进行查询，未命中状态比单纯连接数据库查询多了一次连接和查询的操作；如果缓存命中率很低，则这个额外的操作非但不能提高查询效率，反而为系统带来了额外的负载和复杂性，得不偿失。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例:<br><code>$var=Memcache_get($memcon,”var”);$var++;memcache_set($memcon,”var”,$var);</code><br>这样一个脚本，使用apache ab去跑，100个并发，跑10000次，然后输出缓存存取的数据，很遗憾，并不是1000，而是5000多，6000多这样的数字，中间的数字全在 get &amp; set的过程中丢掉了。原因：读写间隔中其他并发写入，导致数据丢失。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例2:<br>用memcache_increment来做这个操作，同样跑测试会得到完整的10000，一条数据不会丢。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>某论坛热门贴，前端不断有views=views+1数据更新请求。<br>缓存实时更新该状态<br>后台任务对数据库做异步更新时，假设执行周期是5分钟，那么五分钟可能会接收到这样的请求多达数十次乃至数百次，合并更新后只执行一次update即可。<br>类似操作还包括游戏打怪，生命和经验的变化；个人主页访问次数的变化等。<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">例如：<code>ALTER TABLE t1 ADD INDEX(user(20))</code><br>前缀索引的长度可以基于对该字段的统计得出，一般略大于平均长度一点就可以了。<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>用户在线上时，后台异步更新用户状态。管理员后台屏蔽用户是直接更新数据库。结果管理员屏蔽某用户操作完成后，因该用户在线有操作，后台异步更新程序再次基于缓存更新用户状态，用户状态被复活，屏蔽失效。<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例：支付信息，道具的购买与获得，一旦丢失会对用户造成极大的伤害。而经验值，访问数字，如果只丢失了很少时间的内容，用户还是可以容忍的。<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例：如果使用 <code>Views=Views+…</code>的操作，一旦出现数据格式错误，从binlog中反推是可以进行数据还原，但是如果使用Views=特定值的操作，一旦缓存中数据有错误，则直接被赋予了一个错误数据，无法回溯！<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例1: 用户分表<br>将用户库分成若干数据表;基于用户名的查询和基于uid的查询都是高并发请求。<br>用户分表基于uid分成数据表，同时基于用户名做对应冗余表。<br>如果允许多方式登陆，可以有如下设计方法：<br><code>uid,passwd,用户信息等等，主数据表，基于uid分表</code><br><code>ukey,ukeytype,uid 基于ukey分表，便于用户登陆的查询。分解成如下两个SQL:</code><br><code>select uid from ulist_key_13 where ukey=’$username’ and ukeytype=‘login’;</code><br><code>select <em> from ulist_uid_23 where uid=$uid and passwd=’$passwd’;</em></code><br><code>ukeytype定义用户的登陆依据，比如用户名，手机号，邮件地址，网站昵称等。 Ukey+ukeytype 必须唯一</code><br><code>此种方式需要登陆密码统一，对于第三方connect接入模式，可以通过引申额外字段完成</code><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例2：用户游戏积分排名<br>表结构 uid,gameid,score 参见前文实时积分排行。表内容巨大，需要拆表。<br>需求1：基于游戏id查询积分排行<br>需求2：基于用户id查询游戏积分记录<br>解决方案：建立完全相同的两套表结构，其一以uid为拆表主键，其二以gameid为拆表主键，用户提交积分时，向两个数据结构同时提交。<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例3：全冗余查询结构<br>主信息表仅包括 主键及备注memo字段（text类型），只支持主键查询，可以基于主键拆表。所以需要展现和存储的内容均在memo字段重体现。<br>对每一个查询条件，建立查询冗余表，以查询条件字段为主键，以主信息表主键id 为内容。<br>日常查询只基于查询冗余表，然后通过in的方式从主信息表获得内容。<br>优点是结构扩展非常方便，只需要扩展新的查询信息表即可，核心思路是，只有查询才需要独立的索引结构，展现无需独立字段。<br>缺点是只适合于相对固定的查询架构，对于更加灵活的组合查询束手无策。<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">举例，信息表 message，存在字段 fromuid,touid,msg,sendtime 四个字段，其中 touid+sendtime是复合索引。存在查询为 select  from message where touid=$uid order by sendtime desc limit 0,30;<br>展示程序需要显示发送者姓名，此时通常会在message表中增加字段fromusername，甚至有的会增加fromusersex，从而无需连表查询直接输出信息的发送者姓名和性别。这就是一种简单的，为了避免连表查询而使用的冗余字段设计。<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>论坛板块的发帖量，回帖量，每日新增数据等。<br>网站每日新增用户数等。<br>参见Discuz论坛系统数据结构，有较多相关结构。<br>参见前文分段积分结构，是典型用于统计的冗余结构。<br>后台可以通过源数据表更新该数字。<br>Redis的Zset类型可以理解为存在一种冗余统计结构。<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">游戏组队，5个武将。（建立临时的武将表，定时更新到主表）<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实时统计<a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例： 在mysql连接不及时释放的应用环境里，当网络环境异常（同机房友邻服务器遭受拒绝服务攻击，出口阻塞），网络延迟加剧，空连接数急剧增加，导致数据库连接过多崩溃。<a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：前端代码 通常我们封装 mysql_connect和memcache_connect，二者的顺序不同，会产生不同的连带效应。如果mysql_connect在前，那么一旦memcache连接阻塞，会连带mysql空连接过多崩溃。<a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">比如说，信息表，fromuid, touid, message字段外，还需要一个fromuname字段记录用户名，这样查询者通过touid查询后，能够立即得到发信人的用户名，而无需进行另一个数据表的查询。<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例: user表 ，个人简介，地址，QQ号，联系方式，头像 这些字段为字符串类型，更新请求少； 最后登录时间，在线时常，访问次数，信件数这些字段为整数型字段，更新频繁，可以将后面这些更新频繁的字段独立拆出一张数据表，表内容变少，索引结构变少，读写请求变快。<a href="#fnref:19" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;数据表设计&quot;&gt;&lt;a href=&quot;#数据表设计&quot; class=&quot;he
      
    
    </summary>
    
      <category term="2-开发技能" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/2-%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
</feed>
