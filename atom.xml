<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贺龙飞的知识库</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-09T08:01:12.936Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>贺龙飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WEB 攻击手段</title>
    <link href="http://yoursite.com/%E5%AE%89%E5%85%A8/Web%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5/"/>
    <id>http://yoursite.com/安全/Web攻击手段/</id>
    <published>2017-12-09T07:09:00.000Z</published>
    <updated>2017-12-09T08:01:12.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h1><p><strong>定义:</strong><br>在 web 网站上执行非法输入的 html 或 js。</p><p><strong>攻击:</strong></p><ol><li>在输入框中输入 js 代码。</li><li>在输入框中输入 html 代码。</li></ol><p><strong>危害:</strong></p><ol><li>获取用户资料（信息、cooike）</li><li>嵌入非法数据等（图片）</li></ol><p><strong>防范:</strong><br>过滤用户输入字符；转义标签（js，html）。</p><blockquote><p>php类库：<a href="http://htmlpurifier.org/" rel="external nofollow noopener noreferrer" target="_blank">htmlpurifier</a></p></blockquote><h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><p><strong>定义：</strong><br>在 web 网站上执行非法注入的 SQL</p><p><strong>攻击：</strong><br>url 上增加 sql</p><p><strong>危害：</strong></p><ol><li>获取数据库数据</li><li>篡改数据库数据</li></ol><p><strong>防范：</strong></p><ol><li>过滤用户输入字符</li><li>使用 PDO 执行 SQL</li></ol><h1 id="OS-命令攻击"><a href="#OS-命令攻击" class="headerlink" title="OS 命令攻击"></a>OS 命令攻击</h1><p><strong>定义：</strong><br>在 Web 上执行非法输入的 OS 命令</p><p><strong>攻击：</strong><br>输入框中输入 OS 命令</p><p><strong>危害：</strong><br>获取服务器信息（<code>/etc/passwd</code>）</p><p><strong>防范：</strong><br>过滤用户输入字符</p><h1 id="跨站请求伪造-CSRF"><a href="#跨站请求伪造-CSRF" class="headerlink" title="跨站请求伪造(CSRF)"></a>跨站请求伪造(CSRF)</h1><p><strong>定义：</strong><br>攻击者盗用了你的身份，以你的名义发送恶意请求。</p><p><strong>攻击：</strong><br>1.受害用户登录受信任网站A，并在本地生成Cookie。<br>2.受害用户在不登出A的情况下，访问危险网站B。</p><p><strong>危害：</strong></p><ol><li>以你名义发送邮件，发消息（例：微博关注未知用户）</li><li>盗取你的账号</li></ol><p><strong>防范：</strong><br>服务端预先生成 token，存在 session 中；客户端（浏览器）在 form 表单中增加请求 token，服务端接受到请求后验证请求 token。（保证用户发起的请求是在本站，而不是在第三方网站）</p><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;跨站脚本攻击-XSS&quot;&gt;&lt;a href=&quot;#跨站脚本攻击-XSS&quot;
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Http 协议</title>
    <link href="http://yoursite.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http-%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/计算机网络/http-协议/</id>
    <published>2017-12-08T11:04:00.000Z</published>
    <updated>2017-12-08T18:43:01.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Http-历史版本"><a href="#Http-历史版本" class="headerlink" title="Http 历史版本"></a>Http 历史版本</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议。主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><h2 id="Http0-9"><a href="#Http0-9" class="headerlink" title="Http0.9"></a>Http0.9</h2><p>1991年发布，只有 GET，只能回应 html 格式的字符串。</p><p>请求示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure></p><p>响应示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Http1-0"><a href="#Http1-0" class="headerlink" title="Http1.0"></a>Http1.0</h2><p>1996年5月发布，记载于 <a href="https://www.ietf.org/rfc/rfc1945.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC1945</a>；可以传输任何类型的内容（文本、图像、视频、二进制文件等）</p><p>相对比<code>http0.9</code>增加了：</p><ol><li>POST、HEAD 等请求方法</li><li>状态码</li><li>MIME</li><li>首部字段</li><li>权限认证（Basic）</li><li>字符集</li><li>传输各类型内容</li></ol><p>详细内容请参考 <a href="https://www.ietf.org/rfc/rfc1945.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC1945</a></p><p>请求示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></p><p>响应示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><strong>缺点:</strong><br>每个TCP连接只能发送一个请求。</p><h1 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h1><p>1997年1月发布，最初版是 <a href="https://www.ietf.org/rfc/rfc2068.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC2068</a>；1999年6月发布的修订版 <a href="https://www.ietf.org/rfc/rfc2616.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC2616</a> 沿用至今。</p><p>对比<code>http1.0</code>最大的变化是：</p><ol><li>默认持久连接（<code>keep-alive</code>）</li><li>引入了 <code>pipelining</code>（同一个TCP连接发送多个请求），但是由于服务器是按照请求顺序进行响应，客户端无法确定最优请求顺序，所以未普及</li><li>分块传输编码(<code>chunked</code>)，针对大数据传输操作，把数据切分为若干数据块<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。">[1]</span></a></sup>进行传输（流模式）</li><li>增加了更多的请求方法：OPTIONS,PUT,DELETE,TRACE,CONNECT</li><li>增加了更多的状态码</li><li>可以范围取数据,可实现断点续传下载(<code>range</code>,<code>etag</code>)</li><li>可追踪数据请求链(<code>via</code>)</li><li>增加权限认证</li><li>增加了<code>host</code>首部，使得一台服务器可以支持虚拟主机</li></ol><p><strong>缺点：</strong></p><ol><li>浏览器对同一域名下的持久连接并发有限制，通常是6个</li><li>使用<code>pipelining</code>会造成 <code>Head of line blocking</code></li><li>每次通信都需要传送<code>header</code>，多次请求时大部分请求首部字段不变，会增加传输成本</li></ol><h2 id="URL-URI-URN"><a href="#URL-URI-URN" class="headerlink" title="URL / URI / URN"></a>URL / URI / URN</h2><p><strong>定义</strong><br>uniform resource identifier（统一资源标识符） URI<br>uniform resource locator （统一资源定位符）URL<br>uniform resource name（统一资源名称）URN</p><p><strong>区别</strong><br>URL、URN 是 URI 的子集</p><blockquote><p>URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，<strong>URN定义某事物的身份，而URL提供查找该事物的方法。</strong></p></blockquote><p><img src="/images/2017/11/11/uri.png" alt="URI"></p><h2 id="Http-报文"><a href="#Http-报文" class="headerlink" title="Http 报文"></a>Http 报文</h2><p><img src="/images/2017/12/05/报文结构.png" alt="报文结构"></p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p><img src="/images/2017/12/05/通用首部字段.png" alt="通用首部字段"></p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p><img src="/images/2017/12/05/请求首部字段.png" alt="请求首部字段"></p><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p><img src="/images/2017/12/05/响应首部字段1.png" alt="响应首部字段1"><br><img src="/images/2017/12/05/响应首部字段2.png" alt="响应首部字段2"></p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p><img src="/images/2017/12/05/实体首部字段.png" alt="实体首部字段"></p><h2 id="Http-状态码"><a href="#Http-状态码" class="headerlink" title="Http 状态码"></a>Http 状态码</h2><p><img src="/images/2017/12/05/状态码类别.png" alt="状态码类别"></p><h3 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h3><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td></tr><tr><td>101</td><td>Switching Protocols</td></tr></tbody></table><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>202</td><td>Accepted</td><td></td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td></td></tr><tr><td>204</td><td>No Content</td><td>响应报文中不含主体</td></tr><tr><td>205</td><td>Reset Content</td><td></td></tr><tr><td>206</td><td>Parial Content</td><td>范围请求；响应报文中含有content-range</td></tr></tbody></table><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td></td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久重定向，丢失搜索引擎权重</td></tr><tr><td>302</td><td>Found</td><td>临时重定向</td></tr><tr><td>303</td><td>See other</td><td>有另外的URL，应使用GET去访问另一个URL</td></tr><tr><td>304</td><td>Not Modified</td><td>没有满足客户端的条件请求的响应需要返回，不包含主体</td></tr><tr><td>305</td><td>Use Proxy</td><td></td></tr><tr><td>306</td><td>(Unuesed)</td><td></td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向，不会把POST改为GET</td></tr></tbody></table><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>请求报文存在语法错误</td></tr><tr><td>401</td><td>Unauthorized</td><td>HTTP认证未通过</td></tr><tr><td>402</td><td>Payment Required</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td>请求被拒绝</td></tr><tr><td>404</td><td>Not Found</td><td>未找到请求资源</td></tr><tr><td>405</td><td>Method NOt Allowed</td><td></td></tr><tr><td>406</td><td>Not Acceptable</td><td></td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td></td></tr><tr><td>408</td><td>Request Timeout</td><td></td></tr><tr><td>409</td><td>Conflict</td><td></td></tr><tr><td>410</td><td>Gone</td><td>请求资源被永久性删除</td></tr><tr><td>411</td><td>Length Required</td><td></td></tr><tr><td>412</td><td>Precondition Failed</td><td></td></tr><tr><td>413</td><td>Request Entity Too Large</td><td></td></tr><tr><td>414</td><td>Request-URI Too Long</td><td></td></tr><tr><td>415</td><td>Unsupported Media Type</td><td></td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td></td></tr><tr><td>417</td><td>Expectation Failed</td><td>-</td></tr></tbody></table><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务端在执行请求时发生错误</td></tr><tr><td>501</td><td>Not Implemented</td><td></td></tr><tr><td>502</td><td>Bad Gateway</td><td></td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务器超负载，暂时无法处理请求</td></tr><tr><td>504</td><td>Gateway Timeout</td><td></td></tr><tr><td>505</td><td>Http Version Not Unsupported</td><td>-</td></tr></tbody></table><h2 id="HTTP-追加协议"><a href="#HTTP-追加协议" class="headerlink" title="HTTP 追加协议"></a>HTTP 追加协议</h2><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>Google在2010年发布了 <a href="http://www.chromium.org/spdy" rel="external nofollow noopener noreferrer" target="_blank">SPDY协议</a>；希望在协议层面解决http的一些痛点：</p><ol><li>一条连接发送一条请求</li><li>请求只能从客户端发起</li><li>首部未经压缩</li></ol><p><img src="/images/2017/12/05/spdy的设计.png" alt="SPDY的设计"></p><p><strong>SPDY协议的主要功能有：</strong></p><ol><li>多路复用流（单一TCP连接）</li><li>请求优先级</li><li>压缩Http首部</li><li>支持服务端推送数据到客户端</li><li>服务器主动提示客户端所需资源（过期）</li></ol><h3 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h3><p>Websocket即web浏览器与web服务器之间全双工通信标准。2011年12月11日记载于 <a href="https://www.ietf.org/rfc/rfc6455.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC6455</a>；</p><p>为了实现Websocket通信，在HTTP连接建立之后，需要完成一次握手：</p><p><img src="/images/2017/12/05/websocket通信.png" alt="Websocket通信"></p><p><strong>Websocket的功能：</strong></p><ol><li>服务器推送</li><li>减少通信量（websocket首部信息很小）</li><li>js可调用 <a href="http://www.w3.org/TR/websockets" rel="external nofollow noopener noreferrer" target="_blank">Websocket API</a></li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>2000年5月公布，发布于 <a href="https://www.ietf.org/rfc/rfc2818.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC2818</a>；默认端口443。因为有加密解密，所以访问会比http慢（可接受），并且会消耗服务器cpu资源。</p><h2 id="Http的缺点"><a href="#Http的缺点" class="headerlink" title="Http的缺点"></a>Http的缺点</h2><ol><li>通信使用明文，可能被窃听</li><li>不验证通信方身份，可能被伪装</li><li>无法证明报文的完整性，可能被篡改</li></ol><h2 id="SSL-TLS-协议"><a href="#SSL-TLS-协议" class="headerlink" title="SSL/TLS 协议"></a>SSL/TLS 协议</h2><p>最初是网景设计了 SSL（1.0~3.0）；后来 ITEF 在 SSL3.0 基础上设计了 TLS1.0，目前 TLS 最新版为1.3。</p><p><strong>5次握手：</strong></p><p>第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。<br>第二步，服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。<br>第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。<br>第四步，服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。<br>第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</p><p>整体握手是明文传输。</p><p><strong>会话恢复：</strong></p><ol><li><p>session ID<br>每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p></li><li><p>session ticket<br>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p></li></ol><h2 id="Https的组成"><a href="#Https的组成" class="headerlink" title="Https的组成"></a>Https的组成</h2><blockquote><p>Http + 加密 + 认证 + 完整性保护 = Https</p></blockquote><p>Http直接和TCP通信，Https先和SSL/TLS通信，再由SSL/TLS和TCP通信。<br><img src="/images/2017/12/05/httpvshttps.png" alt="HttpVsHttps"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>采用「对称加密」<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="加密和解密使用同一个密钥；消耗资源少且快">[2]</span></a></sup>和「非对称加密」<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="使用公钥进行加密（发送方），使用私钥进行解密（使用方）；消耗资源多且慢">[3]</span></a></sup>混合加密方式；交换密钥使用「非对称加密」，通信使用「对称加密」。</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>采用数字认证机构与其相关机关颁发的「公开密钥证书」进行认证。</p><ol><li>网站提交公钥给数字认证机构，机构制作为「公开密钥证书」（非对称加密）</li><li>网站服务端把「公开密钥证书」发送给客户端，客户端利用浏览器内置的数字认证机构公钥进行验证（非对称加密）</li><li>验证通过后，客户端和服务端使用公钥进行加密通信（对称加密）</li></ol><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><p>在通信过程中，应用层会发送MAC（Message Authentication Code）报文摘要（MD5等算法）；MAC可以查知报文是否被篡改。</p><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p>2015年5月，发布于 <a href="https://www.ietf.org/rfc/rfc7540.txt" rel="external nofollow noopener noreferrer" target="_blank">RFC7540</a>；基于<code>spdy3.0草案</code>；Http2 可以基于「明文」，也可以基于「TLS」进行通信。</p><p>关于后续版本：<br>HTTP2后取消了小版本，后续的版本会是HTTP3。</p><h2 id="HTTP2的特性"><a href="#HTTP2的特性" class="headerlink" title="HTTP2的特性"></a>HTTP2的特性</h2><p><strong>1. 二进制协议</strong><br><img src="/images/2017/12/08/http2.png" alt="http2"></p><ul><li>length 定义了整个frame（帧）的大小</li><li>type定义frame的类型（一共10种）</li><li>flags用bit位定义一些重要的参数</li><li>stream id用作流控制</li><li>frame payload就是request的正文。</li></ul><p><strong>2. 多路复用的流</strong></p><p><strong>帧</strong>：HTTP2 数据通信的最小单位；例如请求和响应等，消息由一个或多个帧组成。</p><p><strong>流</strong>：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。</p><p>HTTP2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流（并发）。流的多路复用意味着在同一连接中来自各个流的数据包会被混合在一起，Stream Identifier将连接上传输的每个帧都关联到一个“流”。</p><p><strong>3. 流的优先级和依赖性</strong><br>优先级：每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。<br>依赖性：借助于PRIORITY帧，客户端可以告知服务器当前的流依赖于其他哪个流。</p><p><strong>4. header压缩</strong><br>HTTP2 对消息头采用 <a href="https://www.ietf.org/rfc/rfc7541.txt" rel="external nofollow noopener noreferrer" target="_blank">HPACK</a>（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。</p><p>HTTP2 对这些首部采取了压缩策略：</p><ol><li>HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在HTTP2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ol><p><strong>5. 重置消息</strong><br>Http2 通过发送RST_STREAM帧可终止当前传输的消息并重新发送一个新的。</p><p><strong>6. 服务器推送</strong><br>这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。</p><p>服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否需要中断该推送的流。如果不需要的话，客户端可以通过发送一个RST_STREAM帧来中止。</p><p><strong>7. 流量控制</strong><br>类似TCP协议通过sliding window的算法来做流量控制，http2 使用 WINDOW_UPDATE frame 来做流量控制。每个stream都有流量控制，这保证了数据接收方可以只让自己需要的数据被传输。</p><p>只有数据帧会受到流量控制。</p><p><img src="/images/2017/12/08/flow-control.png" alt="Flow Control"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《图解 HTTP》</li><li><a href="https://ye11ow.gitbooks.io/http2-explained/content/part6.html" rel="external nofollow noopener noreferrer" target="_blank">Http2协议</a></li><li><a href="https://github.com/creeperyang/blog/issues/23" rel="external nofollow noopener noreferrer" target="_blank">HTTP2简介和基于HTTP2的Web优化</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" rel="external nofollow noopener noreferrer" target="_blank">图解SSL/TLS协议</a></li></ul><!--以下是脚注--><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">加密和解密使用同一个密钥；消耗资源少且快<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">使用公钥进行加密（发送方），使用私钥进行解密（使用方）；消耗资源多且慢<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Http-历史版本&quot;&gt;&lt;a href=&quot;#Http-历史版本&quot; c
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>常见错误</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/数据库/Mysql/常见错误/</id>
    <published>2017-11-18T10:36:00.000Z</published>
    <updated>2017-12-03T16:04:44.531Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ERROR-1205-HY000-Lock-wait-timeout-exceeded-try-restarting-transaction"><a href="#ERROR-1205-HY000-Lock-wait-timeout-exceeded-try-restarting-transaction" class="headerlink" title="ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction"></a>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</h1><p>原因：<br>select @@autocommit;<br>+————–+<br>| @@autocommit |<br>+————–+<br>| 0            |<br>+————–+<br>没有开启自动提交，导致update一直未commit。</p><p>解决：</p><ol><li>查看是否有慢查SQL</li><li>查看innodb的事务表INNODB_TRX是否有正在锁定的事务线程,有的话看看ID是否在show full processlist里面的sleep线程中，如果是，就证明这个sleep的线程事务一直没有commit或者rollback而是卡住了，我们需要手动kill掉</li><li>开启自动提交: set global autocommit=1;</li></ol><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;ERROR-1205-HY000-Lock-wait-timeou
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>常用函数</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/数据库/Mysql/常用函数/</id>
    <published>2017-11-17T17:32:00.000Z</published>
    <updated>2017-12-03T16:04:44.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="进制转换函数"><a href="#进制转换函数" class="headerlink" title="进制转换函数"></a>进制转换函数</h1><p><code>CONV(N,from_base,to_base)</code> N是要转换的数据，from_base是原进制，to_base是目标进制。</p><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><p><code>substring(column,pos,length)</code>截取字符串.pos开始的位置，length截取的长度<br><code>left(‘string’,length)</code>取左边length个字符<br><code>right(‘string’,length)</code>取右边length个字符</p><h1 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h1><p><code>field(column,’b’,’a’,’c’)</code>显式的排序，按照bac排序</p><h1 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h1><p><code>USING(id)</code> 等于 on(a.id=b.id) //join on条件的缩写</p><h1 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h1><ul><li><code>unix_timestamp(‘2013-04-01’)</code></li><li><code>from_unixtime(‘1364745600’)</code></li></ul><h1 id="ip转换函数"><a href="#ip转换函数" class="headerlink" title="ip转换函数"></a>ip转换函数</h1><ul><li><code>inet_aton(‘192.168.1.1’)</code></li><li><code>inet_ntoa(‘3232235777 ‘)</code></li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;进制转换函数&quot;&gt;&lt;a href=&quot;#进制转换函数&quot; class=&quot;
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>常用SQL</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%B8%B8%E7%94%A8Sql/"/>
    <id>http://yoursite.com/数据库/Mysql/常用Sql/</id>
    <published>2017-11-17T17:20:00.000Z</published>
    <updated>2017-12-03T16:04:44.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h1><p>gist：<a href="https://gist.github.com/hlf513/035ae964db80e122c262" rel="external nofollow noopener noreferrer" target="_blank">multi_update.php</a></p><h1 id="在线动态抓取SQL"><a href="#在线动态抓取SQL" class="headerlink" title="在线动态抓取SQL"></a>在线动态抓取SQL</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -s 0 -l -w - dst port 3306|strings</span><br></pre></td></tr></table></figure><h1 id="随机一条"><a href="#随机一条" class="headerlink" title="随机一条"></a>随机一条</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.*</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`table`</span> <span class="keyword">AS</span> t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="keyword">RAND</span>() * (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> <span class="string">`table`</span>)) <span class="keyword">AS</span> <span class="keyword">id</span>) <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id &gt;= t2.id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.id <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="导出数据字典"><a href="#导出数据字典" class="headerlink" title="导出数据字典"></a>导出数据字典</h1><p>gist：<a href="https://gist.github.com/hlf513/3ccaf696d3cd335dcaca" rel="external nofollow noopener noreferrer" target="_blank">generator_mysql_dict.php</a></p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>SQL采用内连接（INNER JOIN）实现，更高效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cols <span class="keyword">from</span> <span class="keyword">tables</span> <span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">  <span class="keyword">select</span> pk <span class="keyword">from</span> <span class="keyword">tables</span></span><br><span class="line">    <span class="keyword">where</span> col1 = $col1 <span class="keyword">order</span> <span class="keyword">by</span> col2 <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span></span><br><span class="line">) <span class="keyword">using</span> (pk);</span><br></pre></td></tr></table></figure><h1 id="检查数据表大小"><a href="#检查数据表大小" class="headerlink" title="检查数据表大小"></a>检查数据表大小</h1><ol><li><p>进去指定 schema 数据库（存放了其他的数据库的信息）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></li><li><p>查询所有数据的大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(round(sum(DATA_LENGTH/1024/1024), 2), 'MB')</span><br><span class="line">-&gt; as data from TABLES;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| data |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 6674.48MB |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">16.81</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>查看指定数据库实例的大小，比如说数据库 forexpert</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(round(sum(DATA_LENGTH/1024/1024), 2), 'MB')</span><br><span class="line">-&gt; as data from TABLES where table_schema='forexpert';</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| data |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| 6542.30MB |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">7.47</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>查看指定数据库的表的大小，比如说数据库 forexpert 中的 member 表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat(round(sum(DATA_LENGTH/1024/1024),2),'MB') as data</span><br><span class="line">-&gt; from TABLES where table_schema='forexpert'</span><br><span class="line">-&gt; and table_name='member';</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| data |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 2.52MB |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">1.88</span> sec)</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用-OR-时-使用-union-all-替换"><a href="#使用-OR-时-使用-union-all-替换" class="headerlink" title="使用 OR 时,使用 union all 替换"></a>使用 OR 时,使用 union all 替换</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">union</span> all <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="导入导出数据"><a href="#导入导出数据" class="headerlink" title="导入导出数据"></a>导入导出数据</h1><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><ul><li><p>常规使用 values 导入<br>字段顺序必须一致</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> ~/dump.sql</span><br><span class="line">或</span><br><span class="line">mysql -u root -p database_name &lt; ~/dump.sql</span><br></pre></td></tr></table></figure></li><li><p>使用 load data infile<br>方式一：直接导入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#$1,数据文件的绝对地址</span></span><br><span class="line">username=<span class="string">'root'</span></span><br><span class="line">password=<span class="string">''</span></span><br><span class="line">host=<span class="string">'127.0.0.1'</span></span><br><span class="line">database=<span class="string">"thirdsite_grab"</span></span><br><span class="line">table=<span class="string">"resumes_contacts"</span></span><br><span class="line">field=<span class="string">"src,src_no,resume_updated_at,name,phone,tel,email,create_at,updated_at,is_deleted,status,icdc_id,error_msg,source,type"</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">mysql -u <span class="variable">$username</span> -p<span class="variable">$passwoed</span> -h <span class="variable">$host</span> <span class="variable">$database</span> -e <span class="string">"load data local infile '<span class="variable">$1</span>' replace into table <span class="variable">$table</span> (<span class="variable">$field</span>)"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span><span class="string">'不存在'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>方式二：不更新索引，加快导入速度</p><ol><li>执行 <code>FLUSH TABLES</code> 语句或命令 <code>mysqladmin flush-tables</code></li><li>使用<code>myisamchk –keys-used=0 -rq /path/to/db/tbl_name</code>。这将从表中取消所有索引的使用</li><li>用<code>LOAD DATA INFILE</code>把数据插入到表中</li><li>用<code>myisamchk -r -q /path/to/db/tbl_name</code>重新创建索引.<br>这将在写入磁盘前在内存中创建索引树，并且它更快，因为避免了大量磁盘搜索。结果索引树也被完美地平衡</li><li>执行<code>FLUSH TABLES</code>语句或<code>mysqladmin flush-tables</code>命令。</li></ol><p>更简洁的方式二：<br>使用这种方式，不需要执行<code>FLUSH TABLES</code>。</p><ol><li>使用<code>ALTER TABLE tbl_name DISABLE KEYS</code>代替<code>myisamchk –keys-used=0 -rq/path/to/db/tbl_name</code>，</li><li>使用<code>ALTER TABLE tbl_name ENABLE KEYS</code>代替<code>myisamchk -r -q/path/to/db/tbl_name</code>。</li></ol></li></ul><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><ol><li><p>导出 sql</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uxxx -pxxx -h127.0.0.1 database_name table_name -t --<span class="built_in">where</span>=<span class="string">"where条件"</span> &gt; dump.sql</span><br></pre></td></tr></table></figure></li><li><p>导出文本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">username=<span class="string">'root'</span></span><br><span class="line">password=<span class="string">''</span></span><br><span class="line">host=<span class="string">'127.0.0.1'</span></span><br><span class="line">database=<span class="string">"thirdsite_grab"</span></span><br><span class="line">table=<span class="string">"resumes_contacts"</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">save_path=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">save_path=/tmp/export.data</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$save_path</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'删除旧文件'</span></span><br><span class="line">`rm <span class="variable">$save_path</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'保存路径为'</span><span class="variable">$save_path</span></span><br><span class="line">mysql -u <span class="variable">$user</span> -p<span class="variable">$password</span> <span class="variable">$database</span> -h <span class="variable">$host</span> -Ne <span class="string">"set names UTF8;select <span class="variable">$field</span> from <span class="variable">$table</span>"</span> &gt; <span class="variable">$save_path</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="删除重复的数据"><a href="#删除重复的数据" class="headerlink" title="删除重复的数据"></a>删除重复的数据</h1><p>demo：表名；<br>id：自增 ID；<br>site：具有相同数据的列</p><h2 id="只有-crud-权限"><a href="#只有-crud-权限" class="headerlink" title="只有 crud 权限"></a>只有 crud 权限</h2><ul><li><p>删除 ID 大的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> a <span class="keyword">using</span> demo <span class="keyword">as</span> a, demo <span class="keyword">as</span> b <span class="keyword">where</span> (a.id &gt; b.id) <span class="keyword">and</span> (a.site = b.site);</span><br></pre></td></tr></table></figure></li><li><p>删除 ID 小的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> a <span class="keyword">using</span> demo <span class="keyword">as</span> a, demo <span class="keyword">as</span> b <span class="keyword">where</span> (a.id &lt; b.id) <span class="keyword">and</span> (a.site = b.site);</span><br></pre></td></tr></table></figure></li></ul><h2 id="有索引权限"><a href="#有索引权限" class="headerlink" title="有索引权限"></a>有索引权限</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//自动删除重复数据（id 大的删除）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">ignore</span> <span class="keyword">table</span> demo <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> ukey (site);</span><br><span class="line">//删除刚建立的索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo <span class="keyword">drop</span> <span class="keyword">index</span> ukey;</span><br></pre></td></tr></table></figure><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;批量更新&quot;&gt;&lt;a href=&quot;#批量更新&quot; class=&quot;head
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>运维指南</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E8%BF%90%E7%BB%B4%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/数据库/Mysql/运维指南/</id>
    <published>2017-11-17T16:37:00.000Z</published>
    <updated>2017-12-03T16:04:44.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="系统与软件"><a href="#系统与软件" class="headerlink" title="系统与软件"></a>系统与软件</h1><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul><li>一般选择RHEL、CentOS</li><li>拒绝使用32位系统，升级到64位</li><li>不追新，稳定、高性能压倒一切</li><li>版本一致，批量部署，管理方便</li><li>/tmp使用/dev/shm的tmpfs</li></ul><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><ul><li>IO调度：deadline，noop，反正不要cfq</li><li>VM管理：vm.swappiness=0</li></ul><h2 id="文件系统-xfs-zfs"><a href="#文件系统-xfs-zfs" class="headerlink" title="文件系统:xfs/zfs"></a>文件系统:xfs/zfs</h2><ul><li>全B+树，高效</li><li>分配组，提高并发度</li><li>延迟分配，减少IO</li><li>mount：nobarrier、data=ordered,writeback</li></ul><h2 id="Mysql使用内存盘（挂载）"><a href="#Mysql使用内存盘（挂载）" class="headerlink" title="Mysql使用内存盘（挂载）"></a>Mysql使用内存盘（挂载）</h2><p>将 MYSQL 目录迁移到 4G 的内存磁盘<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/ramdisk</span><br><span class="line">sudo mount -t tmpfs -o size=4000M tmpfs /mnt/ramdisk/</span><br><span class="line">mv /var/lib/mysql /mnt/ramdisk/mysql</span><br><span class="line">ln -s /tmp/ramdisk/mysql /var/lib/mysql</span><br><span class="line">chown mysql:mysql mysql</span><br></pre></td></tr></table></figure></p><h2 id="是否关闭swap？"><a href="#是否关闭swap？" class="headerlink" title="是否关闭swap？"></a>是否关闭swap？</h2><p>mysql 专用服务器则关闭 swap；否则保证innodb_buffer_pool_size足够大</p><h2 id="内存使用考量"><a href="#内存使用考量" class="headerlink" title="内存使用考量"></a>内存使用考量</h2><ul><li>理论上，内存越大，越多数据读取发生在内存，效率越高</li><li>Query cache的使用</li><li>如果前端请求重复度不高，或者应用层已经充分缓存重复请求，query cache不必设置很大，甚至可以不设置。</li><li>如果前端请求重复度较高，无应用层缓存，query cache是一个很好的偷懒选择</li><li>对于中等以下规模数据库应用，偷懒不是一个坏选择。</li><li>如果确认使用query cache，记得定时清理碎片，flush query cache.</li><li>要考虑到现实的硬件资源和瓶颈分布</li><li>学会理解热点数据，并将热点数据尽可能内存化</li><li>所谓热点数据，就是最多被访问的数据。</li><li>通常数据库访问是不平均的，少数数据被频繁读写，而更多数据鲜有读写。</li><li>学会制定不同的热点数据规则，并测算指标。</li><li>热点数据规模，理论上，热点数据越少越好，这样可以更好的满足业务的增长趋势。</li><li>响应满足度，对响应的满足率越高越好。</li><li>比如依据最后更新时间，总访问量，回访次数等指标定义热点数据，并测算不同定义模式下的热点数据规模</li></ul><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><p><strong>vm.swappiness</strong><br>rhel6及以下设置为0 ；rhel7以上设置为10（0 可能会被 oom kill 掉）</p><p><strong>/sys/block/sdX/queue/scheduler</strong></p><p>内核默认的 cfq 很烂，不要使用<br>普通的 sas 盘建议使用 deadline策略<br>ssd 使用 noop 或者 deadline（还可以设置 io scheduler ）</p><p><strong>文件系统</strong></p><p>首选xfs，其次ext4，zfs也很不错，但在linux下不是那么可靠(relserfs也不错，但作者被抓，没人维护，不建议使用)<br>高 io 下使用 xfs，不要使用 ext4（会有瓶颈）因为：ext4下%util 基本到了100%，再也上不去了；而 xfs 还有上升的空间</p><p><strong>文件系统数据结构</strong><br>xfs 目录内容 b+tree，文件分配b+tree<br>ext4 -&gt; htree（特殊 b 树）-&gt; extents/bitmap<br>ext3 -&gt; htree -&gt; bitmap</p><p><strong>查看现在文件系统的命令</strong><br>df -HT</p><h1 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h1><p><a href="http://imysql.com/my_cnf_generator" rel="external nofollow noopener noreferrer" target="_blank">老叶的 my.cnf 生成器</a></p><h2 id="myisam-参数"><a href="#myisam-参数" class="headerlink" title="myisam 参数"></a>myisam 参数</h2><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<br>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p><p>MyISAM的锁调度</p><p>MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM的调度行为。</p><p>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</p><p>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</p><p>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</p><h2 id="关注的参数"><a href="#关注的参数" class="headerlink" title="关注的参数"></a>关注的参数</h2><h3 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h3><ul><li><p>interactive_timeout/wait_timeout<br>断开活跃连接超时的时间/断开不活跃连接的超时时间<br>前者数值基本上继承与后者;建议两者设置一样.<br>1.有连接池，timeout 调大一些，或者默认值<br>2.无连接池，建议设置300以内（理论是越小越好，真正的值根据业务b）</p></li><li><p>open_files_limit<br>此选项不够时的错误：<br>can’t  open file : \test\…..(error:24)<br>sh&gt; perror 24 #查看错误24的含义<br>OS error code 24: too many open files<br>如何调整？</p><ol><li>调整此参数的限制</li><li>ulimit -n 修改内核级别的限制</li></ol></li><li><p>max_connections<br>连接数不够用，建议业务方进行优化，保证连接数可用，不是一味的调大连接数<br>有可能会导致系统雪崩/oom_killer<br>建议</p><ol><li>临时调高数量，让业务优化sql</li><li>调低 timeout 的值</li></ol></li><li><p>和 open_files_limit类似的问题<br>问题：<br><code>Can not connect to Mysql Server</code><br><code>1135: Can&#39;t create a new thread(errno 12);if you are not out of available memory, you can consult the manual for a possible OS-dependent bug</code><br> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.d/90-nproc.conf</span><br><span class="line">nproc 改为 65536</span><br><span class="line"> 或者</span><br><span class="line">vi /etc/bashrc</span><br><span class="line">ulimit -u 65536</span><br></pre></td></tr></table></figure></li><li><p>thread_pool<br>官方版本不支持此功能（线程池）；可以使用 percona,mariadb 分支版本<br><a href="http://imysql.com/2014/07/02/percona-thread-pool-benchmark-testing.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2014/07/02/percona-thread-pool-benchmark-testing.shtml</a><br>线程池作用：让线程分组去处理，而不是阻塞等待处理</p></li></ul><h3 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h3><p><img src="/images/2017/11/18/memory.png" alt="memory"></p><ul><li>tmp_table_size/max_heap_table_size<br>不要把 tmp_table_size 、max_heap_table_size（这个是会话级别） 设置过大，建议不高于100M</li></ul><h3 id="innodb参数"><a href="#innodb参数" class="headerlink" title="innodb参数"></a>innodb参数</h3><ul><li><p>innodb_buffer_pool<br>建议设置50-70%，缓存大量的脏数据，事务信息，锁信息等；保证不会 oom 的前提下，可以设置80%或更高；非专业人士，不建议设置过高。<br>设置太小的话：</p><ol><li>tps 很低，大量等待</li><li>可能会 table full</li><li>锁不够用</li></ol></li><li><p>innodb_data_file_path<br>默认只有10m，ibdata1初始化时，至少设置1G<br>参考： <a href="http://imysql.com/2010/06/01/mysql-faq-what-contains-with-ibdata1.html" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2010/06/01/mysql-faq-what-contains-with-ibdata1.html</a><br>Innodb 共享表空间文件 ibdata1 中存储了以下几部分信息：</p><ol><li>Data dictionary</li><li>Double write buffer</li><li>Insert buffer</li><li>Rollback segments</li><li>UNDO space</li></ol><p>因此在初始化ibdata1时，最好设置大一些，这样可以避免高并发下导致ibdata1急剧增大，大大影响性能</p></li><li><p>innodb_flush_log_at_trx_commit<br>0\1\2\<br>每秒\每事务\0和1的折中（刷新 log入磁盘）</p></li><li><p>transaction_isolation<br>事务隔离级别：默认是 RR（可重复读），建议使用 RR<br>不建议使用 RC，RC并发提高了，锁等待很严重，tpmc 并没提高多少</p></li><li><p>innodb_log_file_size &amp; innodb_log_buffer_size<br>若1分钟产生10m事务，则 log_buffer 设置64m；100m事务则设置512m；一般不建议超过512m；若发生 innodb_log_buffer_wait_free事件，则需要调整<br>不易设置过大，因为若 mysql 挂掉，重启时会读 log恢复；越大恢复越慢</p></li><li><p>innodb_file_per_table=1<br>为每个表分别创建 InnoDB FILE；防止ibdata1 文件过大</p></li><li><p>innodb_buffer_pool_size<br>将数据完全保存在innodb_buffer_pool_size（内存）中</p><ul><li>如何确定取值？<pre><code>mysql&gt; SHOW GLOBAL STATUS LIKE &apos;innodb_buffer_pool_pages_%&apos;;//Innodb_buffer_pool_pages_free = 0 则说明需要增加//innodb_additional_mem_pool_size = 1/200 of buffer_pool//innodb_max_dirty_pages_pct 80%</code></pre></li></ul></li><li><p>innodb_log_file_size<br>推荐innodb_log_file_size 设置为 0.25 * innodb_buffer_pool_size<br>如果用 1G 的 innodb_log_file_size ，假如服务器宕机，需要 10 分钟来恢复。</p></li><li><p>innodb_flush_log_at_trx_commit<br>这个选项和写磁盘操作密切相关：</p><pre><code>innodb_flush_log_at_trx_commit = 1 则每次修改写入磁盘innodb_flush_log_at_trx_commit = 0/2 每秒写入磁盘</code></pre><p>如果你的应用不涉及很高的安全性 (金融系统)，或者基础架构足够安全，或者 事务都很小，都可以用 0 或者 2 来降低磁盘操作。</p></li><li><p>innodb_flush_method=O_DIRECT<br>避免双写入缓冲</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>general_log<br>通常不打开，否则会使文件很大，会带来mysql 事务性能下降<br>因为： 记录全部 general log 时 tpmc 大约是不打开 log 时的73.28%，而记录全部 slow log 时的 tpmc 大约是不打开 log 时的59.53%<br><a href="http://imysql.com/2014/09/01/mysql-faq-impact-of-generallog.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2014/09/01/mysql-faq-impact-of-generallog.shtml</a></p></li><li><p>innodb_max_dirty_pages_pct</p></li><li><p>log_bin<br>一定要打开，数据丢失可找回；影响：性能下降46%，启用赋值或要求数据灾难时损失最小，必须开启该功能，这时考虑 log_bin与数据隔离或者使用 io 能力强设备，可提高响应，密集写很高的应用要启用 ssd 设备，来缓解该类压力<br>binlog 是顺序写；可用 raid0或1来专门存 binlog.<br>主从结构时，从的 bin_log 也打开</p></li><li><p>long_query_time<br>不要设置为0 （0的作用：每个 sql 记录和 general_log 的作用相当）；可以设置为0.01，0.1等其他值</p></li><li><p>sync_binlog<br>需要很高的数据一致性，设置为1（每个 sql 都要刷入 binlog）；不特别需要时，可设置为2，3，10等更高；不需要时设为0</p></li><li><p>log_slow_query<br>分析慢查询用</p></li><li><p>table_open_cache</p></li><li><p>key_buffer_size</p></li><li><p>query_cache_size</p></li><li><p>memlock</p></li></ul><h1 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h1><p><strong>如何预热？</strong><br>基于 innodb_buffer_pool 的备份和加载；因为数据只有在执行一次，才能加载到innodb_buffer_pool</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>性能差不多，关键是可靠性</li><li>上线前烤机测试非常重要</li><li>监控预警可有效预防故障</li><li>避免使用外部阵列</li><li>最好是2U机型，并且配备RAID卡(with BBU)</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>所有磁盘组建大阵列，不降低IOPS</li><li>默认阵列级别为：raid 1+0</li><li>结合业务特征设置主机名，唯一命名</li><li>合理利用hosts/dns，可用于应用授权管理</li><li>master和slave命名区分开</li><li>/tmp使用/dev/shm &amp; tmpfs</li><li>部署基本工具包：sysstat、oprofile等</li></ul><h2 id="BIOS-设置优化"><a href="#BIOS-设置优化" class="headerlink" title="BIOS 设置优化"></a>BIOS 设置优化</h2><ul><li>System Profile（系统配置）选择Performance Per Watt Optimized(DAPC)，发挥最大功耗性能，充分利用 cpu</li><li>Memory Frequency（内存频率）选择Maximum Performance（最佳性能）</li><li>C1E，允许在处理器处于闲置状态时启用或禁用处理器切换至最低性能状态，建议关闭 （默认启用）</li><li>C States（C状态），允许启用或禁用处理器在所有可用电源状态下运行，建议关闭（默 认启用）</li></ul><h2 id="IO-子系统优化"><a href="#IO-子系统优化" class="headerlink" title="IO 子系统优化"></a>IO 子系统优化</h2><ul><li>专业的阵列卡配备CACHE（大部分是1G，4G 很少）及BBU模块（给缓存提供后备电量），提高IOPS</li><li>cache 策略设置写策略为WB（wirte back），或者FORCE WB，禁用WT策略<br>WB: 让数据先写入 cache，再写回磁盘</li><li>阵列卡配置关闭预读，没必要预读，那点宝贵的CACHE用来做写缓存</li><li>阵列级别使用RAID 1+0，而不是RAID 5 (1+0的ios写性能比5高)</li><li>关闭物理磁盘cache策略（非阵列卡的 cache），防止断电时丢数据</li><li>使用高转速硬盘，不使用低转速盘<br>最低1w 转，最好是1.5w</li><li>使用SSD或者PCIe-SSD盘<br>ssd性能比 sata 硬盘提升几百倍<br>pcle-ssd 提升上万倍</li></ul><h1 id="监控、安全与备份"><a href="#监控、安全与备份" class="headerlink" title="监控、安全与备份"></a>监控、安全与备份</h1><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul><li>监控与数据分析是一切优化的基础。</li><li>没有运营数据监测就不要妄谈优化！</li><li>监控要注意不要产生太多额外的负载，不要因监控带来太多额外系统开销</li></ul><h3 id="监控软件"><a href="#监控软件" class="headerlink" title="监控软件"></a>监控软件</h3><p>nagios、zabbix、cacti</p><h3 id="监控体系"><a href="#监控体系" class="headerlink" title="监控体系"></a>监控体系</h3><h4 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h4><p>服务器资源监控</p><ul><li>Cpu, 内存，硬盘空间，i/o压力</li><li>设置阈值报警</li></ul><p>服务器流量监控</p><ul><li>外网流量，内网流量</li><li>设置阈值报警</li></ul><p>连接状态监控</p><ul><li>Show processlist 设置阈值，每分钟监测，超过阈值记录</li></ul><h4 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h4><p>慢查询监控</p><ul><li>慢查询日志</li><li>如果存在多台数据库服务器，应有汇总查阅机制。</li></ul><p>请求错误监控</p><ul><li>高频繁应用中，会出现偶发性数据库连接错误或执行错误，将错误信息记录到日志，查看每日的比例变化。</li><li>偶发性错误，如果数量极少，可以不用处理，但是需时常监控其趋势。</li><li>会存在恶意输入内容，输入边界限定缺乏导致执行出错，需基于此防止恶意入侵探测行为。</li></ul><p>微慢查询监控</p><ul><li>高并发环境里，超过0.01秒的查询请求都应该关注一下。</li></ul><p>频繁度监控</p><ul><li>写操作，基于binlog，定期分析。</li><li>读操作，在前端db封装代码中增加抽样日志，并输出执行时间。</li><li>分析请求频繁度是开发架构 进一步优化的基础</li><li>最好的优化就是减少请求次数！</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><ul><li>重点：先可用性而后才是性能</li><li>关闭公网，只留私网</li><li>密码足够长度、复杂度</li><li>开启iptables策略</li><li>只开放必要的授权许可</li><li>使用普通账号管理mysqld(结合sudo)</li><li>集成定期安全检查到监控系统中</li></ul><h3 id="性能与安全性考量"><a href="#性能与安全性考量" class="headerlink" title="性能与安全性考量"></a>性能与安全性考量</h3><p>数据提交方式</p><ul><li>innodb_flush_log_at_trx_commit = 1 每次自动提交，安全性高，i/o压力大</li><li>innodb_flush_log_at_trx_commit = 2 每秒自动提交，安全性略有影响，i/o承载强。</li></ul><p>日志同步</p><ul><li>Sync-binlog =1 每条自动更新，安全性高，i/o压力大</li><li>Sync-binlog = 0 根据缓存设置情况自动更新，存在丢失数据和同步延迟风险，i/o承载力强。</li><li>个人建议保存binlog日志文件，便于追溯 更新操作和系统恢复。</li><li>如对日志文件的i/o压力有担心，在内存宽裕的情况下，可考虑将binlog 写入到诸如 /dev/shm 这样的内存映射分区，并定时将旧有的binlog转移到物理硬盘。</li></ul><p>性能与安全本身存在相悖的情况，需要在业务诉求层面决定取舍</p><ul><li>学会区分什么场合侧重性能，什么场合侧重安全</li><li>学会将不同安全等级的数据库用不同策略管理</li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><ul><li>利用slave执行备份</li><li>定期全备+及时增备</li><li>不定期随机做恢复测试</li><li>二进制内容备份使用 –hex-blob</li><li>备份方式：mysqldump VS XtraBackup</li><li>如何快速备份/恢复？(并发？快照？)</li><li>如何执行在线热备<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction或Xtrabackup</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>Keepalived + LVS</li><li>Heartbeat + LVS</li><li>Master + Slave</li><li>多Master共享存储</li></ul><h2 id="故障转移处理"><a href="#故障转移处理" class="headerlink" title="故障转移处理"></a>故障转移处理</h2><p><strong>要点</strong></p><ul><li>程序与数据库的连接，基于虚地址而非真实ip，由负载均衡系统监控。</li><li>保持主从结构的简单化，否则很难做到故障点摘除。</li></ul><p><strong>思考方式</strong></p><ul><li>遍历对服务器集群的任何一台服务器，前端web，中间件，监控，缓存，db等等，假设该服务器出现故障，系统是否会出现异常？用户访问是否会出现异常。</li><li>目标：任意一台服务器崩溃，负载和数据操作均会很短时间内自动转移到其他服务器，不会影响业务的正常进行。不会造成恶性的数据丢失。（哪些是可以丢失的，哪些是不能丢失的）</li></ul><p><strong>常见故障</strong></p><ul><li>复制报错：主键冲突</li><li>硬件、系统崩溃：数据页损坏</li><li>误操作：数据误删除</li><li>硬件故障：阵列卡(掉线、IO性能下降)、CPU、内存</li></ul><h1 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h1><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>tpcc、sysbench<br>现在测试建议使用 tpcc，不使用 sysbench（因为有一定的局限性）</p><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>mysqlslap、前端加压</p><h1 id="存储-写入压力优化"><a href="#存储-写入压力优化" class="headerlink" title="存储/写入压力优化"></a>存储/写入压力优化</h1><ul><li>顺序读写性能远高于随机读写</li><li>将顺序写数据和随机读写数据分成不同的物理磁盘进行，有助于i/o压力的疏解<ul><li>数据库文件涉及索引等内容，写入是随即写</li><li>binlog文件是顺序写</li><li>淘宝数据库存储优化是这样处理的</li></ul></li><li>部分安全要求不高的写入操作可以用 /dev/shm 分区存储，简单变成内存写。</li><li>多块物理硬盘做raid10，可以提升写入能力</li><li>关键存储设备优化，善于比对不同存储介质的压力测试数据。<ul><li>例如fusion-io在新浪和淘宝都有较多使用。</li></ul></li><li>涉及必须存储较为庞大的数据量时<ul><li>压缩存储，可以通过增加cpu开销（压缩算法）减少i/o压力。前提是你确认cpu相对空闲而i/o压力很大。 新浪微博就是压缩存储的典范。</li><li>通过md5去重存储，案例是QQ的文件共享，以及dropbox这样的共享服务，如果你上传的是一个别人已有的文件，计算md5后，直接通过md5定位到原有文件，这样可以极大减少存储量。涉及文件共享，头像共享，相册等应用，通过这种方法可以减少超过70%的存储规模，对硬件资源的节省是相当巨大的。缺点是，删除文件需要甄别该md5是否有其他人使用。 去重存储，用户量越多，上传文件越多，效率越高！</li><li>文件尽量不要存储到数据库内。尽量使用独立的文件系统存储，该话题不展开。</li></ul></li></ul><h1 id="工具集合"><a href="#工具集合" class="headerlink" title="工具集合"></a>工具集合</h1><h2 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h2><ul><li>systemtap</li><li>sar</li><li>gdb</li><li>gcore</li><li>oprofile</li><li>pmp (Poor Man’s Profiler)</li><li>dstat</li></ul><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul><li>Xtrabackup<br>备份出来的数据，可以导入另外一个库，只要制定配置文件就行</li><li>ioprofile</li><li>pt-online-schema-change</li><li>pt-table-checksum</li><li>pt-query-digest + Box Anemometer/Query-Digest-UI – 分析 slow log<br>index_ratio 是 digest 的一个指标，意思是：总共扫描的记录数+最终返回的结果记录数</li><li>mysqldumpslow – 分析 slow log</li><li>pt-ioprofile – 查看哪个数据库读写频繁</li></ul><h1 id="开发人员行为"><a href="#开发人员行为" class="headerlink" title="开发人员行为"></a>开发人员行为</h1><ul><li>批量导入、导出数据须提前通知DBA，请求协助观察</li><li>推广活动或上线新功能须提前通知DBA，请求压力评估</li><li>不使用SUPER权限连接数据库</li><li>单表多次ALTER操作必须合并为一次操作</li><li>数据库DDL及重要SQL及早提交DBA评审</li><li>重要业务库须告知DBA重要等级、数据备份及时性要求</li><li>不在业务高峰期批量更新、查询数据库</li><li>提交线上DDL需求，所有SQL语句须有备注说明</li></ul><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><ul><li>启用log_queries_not_using_indexes</li><li>设置long_query_time为最小值</li><li>定期检查分析slow log</li><li>授权和生产环境一致</li><li>关闭Query Cache</li><li>设置较小InnoDB Buffer Pool、key buffer size</li><li>数据量不能太少，否则有些性能问题无法提前规避</li></ul><h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><ul><li>分配内存越多越好，可能导致OS Swap<br>专用服务器，禁用 swap; 考虑 numa 也禁</li><li>session级内存分配过大，导致OOM</li><li>索引越多越好，可能导致更多IO</li><li>Qcache设置过大，实际效果差(建议关闭)</li><li>认为MyISAM的只读效率远高于InnoDB(不一定)</li><li>过度优化，反而带来成本的上升<br>（改业务逻辑，改 sql，买昂贵的 io 设备，但实际上多加几级 cache 就可以解决）</li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;系统与软件&quot;&gt;&lt;a href=&quot;#系统与软件&quot; class=&quot;he
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/数据库/Mysql/性能优化/</id>
    <published>2017-11-17T14:20:00.000Z</published>
    <updated>2017-12-03T16:04:44.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h1><ul><li>第一步，完成数据库查询的优化，需要理解索引结构，才能学会判断影响结果集。而影响结果集对查询效率线性相关，掌握这一点，编写数据查询语句就很容易判断系统开销，了解业务压力趋势。</li><li>第二步，在SQL语句已经足够优化的基础上，学会对数据库整体状况的分析，能够对异常和负载的波动有正确的认识和解读；能够对系统资源的分配和瓶颈有正确的认识。学会通过监控和数据来进行系统的评估和优化方案设计，杜绝拍脑袋，学会抓大放小，把握要点的处理方法。</li><li>第三步，在彻底掌握数据库语句优化和运维优化的基础上，学会分布式架构设计，掌握复杂，大容量数据库系统的搭建方法。</li></ul><h1 id="优化SQL"><a href="#优化SQL" class="headerlink" title="优化SQL"></a>优化SQL</h1><h2 id="建立慢查询优化系统"><a href="#建立慢查询优化系统" class="headerlink" title="建立慢查询优化系统"></a>建立慢查询优化系统</h2><p>利用 <a href="https://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html" rel="external nofollow noopener noreferrer" target="_blank">pt-query-digest</a> 定期分析slow query log，并结合 <a href="https://github.com/box/Anemometer" rel="external nofollow noopener noreferrer" target="_blank">Box Anemometer</a> 构建slow query log分析及优化系统。</p><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>只选择自己需要的列，不要盲目的使用* ，因为不需要的列可能会导致内存 buffer pool 被这些“无效”数据把真正的热点数据给洗出去了（尤其有 text/blob 列时）</p><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><p>要把过滤性最大（不一定是数据量最小哦，而是只加了WHERE条件后过滤性最大的那个）的表选为驱动表。此外，如果JOIN之后有排序，排序字段一定要属于驱动表，才能利用驱动表上的索引完成排序。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>绝大多数情况下，排序的代价通常要来的更高，因此如果看到执行计划中有 Using filesort，优先创建排序索引吧。</p><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>详情见：<a href="http://dev.mysql.com/doc/refman/5.6/en/explain-output.html#explain-join-types" rel="external nofollow noopener noreferrer" target="_blank">mysql5.6 explain</a></p><p>结果解析：</p><table><thead><tr><th>字段名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>ALL</td><td>表示预计会进行全表扫描（full table scan）。通常全表扫描的代价是比较大的，建议创建适当的索引，通过索引检索避免全表扫描。此外，全索引扫描（full index scan）的代价有时候是比全表扫描还要高的，除非是基于InnoDB表的主键索引扫描。</td></tr><tr><td>Extra</td><td>Using temporary</td><td>表示需要创建临时表以满足需求，通常是因为GROUP BY的列没有索引，或者GROUP BY和ORDER BY的列不一样，也需要创建临时表，建议添加适当的索引。</td></tr><tr><td></td><td>Using filesort</td><td>表示无法利用索引完成排序，也有可能是因为多表连接时，排序字段不是驱动表中的字段，因此也没办法利用索引完成排序，建议添加适当的索引。</td></tr><tr><td></td><td>Using where</td><td>通常是因为全表扫描或全索引扫描时（type 列显示为 ALL 或 index），又加上了WHERE条件，建议添加适当的索引。</td></tr></tbody></table><h2 id="查询-优化影响结果集"><a href="#查询-优化影响结果集" class="headerlink" title="查询/优化影响结果集"></a>查询/优化影响结果集</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li>通过 Explain 分析 SQL，查看 rows 列内容</li><li>通过慢查询日志的Rows_examined: 后面的数字</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>核心：减少影响结果集数目</p><ul><li>基于影响结果集的理解去优化，不论从数据结构，代码，还是涉及产品策略上，都需要贯彻下去。</li><li>涉及 limit $start,$num的搜索，如果$start巨大，则影响结果集巨大，搜索效率会非常难过低，尽量用其他方式改写为 limit 0,$num； 确系无法改写的情况下，先从索引结构中获得 limit $start,$num 或limit $start,1 ；再用in操作或基于索引序的 limit 0,$num 二次搜索。</li><li>避免所有锁表的情况（比如 delete 操作无索引时）</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="实时排行榜"><a href="#实时排行榜" class="headerlink" title="实时排行榜"></a>实时排行榜</h4><p><strong>背景：</strong> 用户提交游戏积分，显示实时排名。</p><p><strong>原方案：</strong><br>设置积分区间，每个区间增加数据统计字段；每次都只 count 本区间的名次，再加上前面所有区间的总和。</p><ol><li>提交积分是插入记录，略，</li><li>select count(*) from jifen where gameid=$gameid and fenshu&gt;$fenshu</li></ol><p><strong>问题与挑战：</strong><br>即便索引是 gameid+fenshu 复合索引，涉及count操作，当分数较低时，影响结果集巨大，查询效率缓慢，高峰期会导致连接过多。</p><p><strong>优化思路：</strong><br>SQL 优化<br>减少影响结果集，又要取得实时数据，单纯从SQL上考虑，不太有方法。</p><p><strong>方案1：</strong><br>逻辑优化</p><ol><li>将游戏积分预定义分成数个积分断点，然后分成积分区间，原始状态，每个区间设置一个统计数字项，初始为0。</li><li>每次积分提交时，先确定该分数属于哪两个区间之间，这个操作非常简单，因为区间是预定义的，而且数量很少，只需遍历即可，找到最该分数符合的区间，该区间的统计数字项（独立字段，可用内存处理，异步回写数据库或文件）+1。 记录该区间上边界数字为$duandian。SQL:  select count(*) from jifen where gameid=$gameid and fenshu&gt;$fenshu and fenshu&lt;$duandian，如果处于第一区间，则无需$duandian，这样因为第一区间本身也是最好的成绩，影响结果集不会很多。 通过该SQL获得其在该区间的名次。获取前面区间的总数总和。（该数字是直接从上述提到的区间统计数字获取，不需要进行count操作）将区间内名次+前区间的统计数字和，获得总名次。</li></ol><p>该方法关键在于，积分区间需要合理定义，保证积分提交成绩能平均散落在不同区间。（如涉及较多其他条件，如日排行，总排行，以及其他独立用户去重等，请按照影响结果集思路自行发挥。）</p><p><strong>方案2：</strong><br>Redis方案<br>Zset 有序数组结构，分两个子结构，第一是多层树形的存储结构，第二是每个树形节点的计数器，这样类似于前面的分段方式，可以理解为多层分段方式，所以查询效率更高，缺点是更新效率有所增加。</p><h4 id="大数据量翻页"><a href="#大数据量翻页" class="headerlink" title="大数据量翻页"></a>大数据量翻页</h4><p><strong>背景</strong>：常见论坛帖子页 SQL: select * from post where tagid=$tagid order by lastpost limit $start, $end 翻页 。索引为 tagid+lastpost 复合索引</p><p><strong>挑战</strong>：超级热帖，几万回帖，用户频频翻到末页，limit 25770,30 一个操作下来，影响结果集巨大(25770+30)，查询缓慢。</p><p><strong>方案1：</strong><br>点击页码改为上下翻页；跳转页sql改为子查询或者内连接</p><ul><li><p>只涉及上下翻页情况<br>每次查询的时候将该页查询结果中最大的 $lastpost和最小的分别记录为 $minlastpost 和 $maxlastpost ，上翻页查询为 select <em> from post where tagid=$tagid and lastpost&lt;$minlastpost order by lastpost desc limit 30; 下翻页为 select </em> from post where tagid=$tagid and lastpost&gt;$maxlastpost order by lastpost limit 30; 使用这种方式，影响结果集只有30条，效率极大提升。</p></li><li><p>涉及跳转到任意页<br>互联网上常见的一个优化方案可以这样表述，select <em> from post where tagid=$tagid and lastpost&gt;=(select lastpost from post where tagid=$tagid order by lastpost limit $start,1) order by lastpost limit 30; 或者 select </em> from post where pid in (select pid from post where tagid=$tagid order by lastpost limit $start,30); (第2条S语法在新的mysql版本已经不支持，新版本mysql in的子语句不再支持limit条件，但可以分解为两条SQL实现，原理不变，不做赘述)</p></li></ul><p>以上思路在于，子查询的影响结果集仍然是$start +30，但是数据获取的过程（Sending data状态）发生在索引文件中，而不是数据表文件，这样所需要的系统开销就比前一种普通的查询低一个数量级，而主查询的影响结果集只有30条，几乎无开销。但是切记，这里仍然涉及了太多的影响结果集操作。</p><h2 id="常见杀手级SQL"><a href="#常见杀手级SQL" class="headerlink" title="常见杀手级SQL"></a>常见杀手级SQL</h2><ul><li><p>SELECT * vs SELECT col1, col2<br>减少磁盘 io 和网络 io</p></li><li><p>ORDER BY RAND()<br><a href="http://imysql.com/2014/07/04/mysql-optimization-case-rand-optimize.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2014/07/04/mysql-optimization-case-rand-optimize.shtml</a></p></li><li><p>LIMIT huge_num, offset<br><a href="http://imysql.com/2015/04/02/mysql-optimization-case-discuz-hot-post-very-old-paging-optimizing.shtml" rel="external nofollow noopener noreferrer" target="_blank">http://imysql.com/2015/04/02/mysql-optimization-case-discuz-hot-post-very-old-paging-optimizing.shtml</a></p></li><li><p>SELECT COUNT(*) on InnoDB table</p></li><li><p>WHERE func(key_col) = ? – 无法使用索引</p></li><li><p>WHERE key_part2 =? AND key_part3 =? – 无法使用索引</p></li><li><p>WHERE key_part1 &gt; ? AND key_part2 =? – 只能用到部分索引</p></li><li><p>SELECT … WHERE key_col + ? = ? – 无法使用索引</p></li></ul><h2 id="开启-分析慢查询"><a href="#开启-分析慢查询" class="headerlink" title="开启/分析慢查询"></a>开启/分析慢查询</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p><strong>检查是否开启</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slow%'</span>; //0为未开启</span><br></pre></td></tr></table></figure><p><strong>开启慢查询</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//my.cnf 添加</span><br><span class="line">[mysqld]</span><br><span class="line">log_slow_queries = 日志保存位置</span><br><span class="line">long_query_time=1 <span class="comment">#超过一秒的查询保存到日志</span></span><br><span class="line"><span class="built_in">log</span>-queries-not-using-indexes <span class="comment">#没有使用到索引的查询保存在日志</span></span><br><span class="line"><span class="built_in">log</span>-slow-admin-statements <span class="comment">#一些管理指令，也会被记录。比如OPTIMEZE TABLE, ALTER TABLE等等。</span></span><br></pre></td></tr></table></figure></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><p><strong>mysqldumpslow</strong></p><p>mysql自带,参数可–help查看</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -s：排序方式。c , t , l , r 表示记录次数、时间、查询时间的多少、返回的记录数排序；</span><br><span class="line"># ac , at , al , ar 表示相应的倒序；</span><br><span class="line"># -t：返回前面多少条的数据；</span><br><span class="line"># -g：包含什么，大小写不敏感的；</span><br></pre></td></tr></table></figure><p>使用案例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 /slowquery.log #slow记录最多的10个语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g "left join" /slowquery.log #按照时间排序前10中含有"left join"的</span><br></pre></td></tr></table></figure></li><li><p><strong>mysqlsla</strong></p><p>github地址: <a href="https://github.com/daniel-nichter/hackmysql.com/tree/master/mysqlsla" rel="external nofollow noopener noreferrer" target="_blank">点此进入</a></p><p>使用案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// mysqlsla会自动判断日志类型，为了方便可以建立一个配置文件“~/.mysqlsla”</span><br><span class="line">// 在文件里写上：top=100，这样会打印出前100条结果。</span><br><span class="line">mysqlsla /data/mysqldata/slow.log</span><br></pre></td></tr></table></figure><p>结果说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* queries total: 总查询次数</span><br><span class="line">* unique:去重后的sql数量</span><br><span class="line">* sorted by : 输出报表的内容排序最重大的慢sql统计信息, 包括平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数.</span><br><span class="line">* Count, sql的执行次数及占总的slow log数量的百分比.</span><br><span class="line">* Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</span><br><span class="line">* 95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</span><br><span class="line">* Lock Time, 等待锁的时间.</span><br><span class="line">* 95% of Lock , 95%的慢sql等待锁时间.</span><br><span class="line">* Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</span><br><span class="line">* Rows examined, 扫描的行数量.</span><br><span class="line">* Database, 属于哪个数据库</span><br><span class="line">* Users, 哪个用户,IP, 占到所有用户执行的sql百分比</span><br><span class="line">* Query abstract, 抽象后的sql语句</span><br><span class="line">* Query sample, sql语句</span><br></pre></td></tr></table></figure></li></ol><h2 id="优化索引"><a href="#优化索引" class="headerlink" title="优化索引"></a>优化索引</h2><ol><li><p>定期检查并删除重复的索引<br>用 pt-duplicate-key-checker 工具<br>比如 index idx1(a, b) 索引已经涵盖了 index idx2(a)，就可以删除 idx2 索引了。</p></li><li><p>索引量<br>基于索引的条件过滤，如果优化器意识到总共需要扫描的数据量超过 <strong>30%</strong> 时，就会直接改变执行计划为全表扫描，不再使用索引。</p></li><li><p>联合索引<br>WHERE中过滤条件的字段顺序和索引 <strong>无需一致</strong><br>排序、分组则就 <strong>必须一致</strong></p></li><li><p>合理利用覆盖索引，但字段尽量不超过5个</p></li><li><p>合理利用最左索引（前缀索引/部分索引）</p></li><li><p>及时删除冗余索引</p></li><li><p>索引字段条件不使用函数</p></li><li><p>内存表(HEAP 表)使用HASH索引时，不能使用范围检索或者ORDER BY等，只能使用=或者!=</p></li><li><p>两个独立索引，其中一个用于检索，一个用于排序 – 只能用到其中一个索引，5.6以上有ICP特性<br>优化器判断使用哪个索引</p></li><li><p>表关联字段类型要一样（也包括长度一样），否则会有类型隐式转换</p></li></ol><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>注意内存的使用优化：<a href="">系统与软件-&gt;内存使用考量</a></p><h2 id="查看-分析资源消耗"><a href="#查看-分析资源消耗" class="headerlink" title="查看/分析资源消耗"></a>查看/分析资源消耗</h2><p><strong>SHOW PROFILE 和 SHOW PROFILES</strong></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>作用域是会话级；</li><li>SHOW PROFILES显示最近发给服务器的多条语句，条数根据会话变量profiling_history_size定义，默认是15，最大值为100。设为0等价于关闭分析功能。</li><li><strong>默认是关闭</strong>；其是否启用是根据会话级的变量profiling</li><li>mysql5.7以后不建议使用SHOW PROFILE指令，或直接从INFORMATION_SCHEMA.PROFILING中查看，建议利用PERFORMANCE_SCHEMA中的几个视图查看。（因为会被废弃）</li></ol><h3 id="开启-1"><a href="#开启-1" class="headerlink" title="开启"></a>开启</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling=1;或 SET profiling=on;</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling=0;或 SET profiling=off;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE [<span class="keyword">type</span> [, <span class="keyword">type</span>] … ][<span class="keyword">FOR</span> <span class="keyword">QUERY</span> n][<span class="keyword">LIMIT</span> <span class="keyword">row_count</span> [<span class="keyword">OFFSET</span> <span class="keyword">offset</span>]]</span><br></pre></td></tr></table></figure><p>type是可选的，取值范围可以如下：</p><ul><li>ALL 显示所有性能信息</li><li>BLOCK IO 显示块IO操作的次数</li><li>CONTEXT SWITCHES 显示上下文切换次数，不管是主动还是被动</li><li>CPU 显示用户CPU时间、系统CPU时间</li><li>IPC 显示发送和接收的消息数量</li><li>MEMORY [暂未实现]</li><li>PAGE FAULTS 显示页错误数量</li><li>SOURCE 显示源码中的函数名称与位置</li><li>SWAPS 显示SWAP的次数</li></ul><p>SHOW PROFILE FOR QUERY n，这里的n就是对应SHOW PROFILES输出中的Query_ID。<br>如果没有指定FOR QUERY，那么输出最近一条语句的信息。</p><p><code>SHOW PROFILE ALL FOR QUERY 2</code> 的信息还可以通过<code>SELECT * FROM information_schema.profiling WHERE query_id = 2 ORDER BY seq;</code>获取。</p><p>参考：<br><a href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html" rel="external nofollow noopener noreferrer" target="_blank">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p><h2 id="查看执行状态"><a href="#查看执行状态" class="headerlink" title="查看执行状态"></a>查看执行状态</h2><h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">FULL</span>] <span class="keyword">PROCESSLIST</span></span><br></pre></td></tr></table></figure><p>SHOW PROCESSLIST显示哪些线程正在运行。您也可以使用mysqladmin processlist语句得到此信息。如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程（也就是，与您正在使用的MySQL账户相关的线程）。如果您不使用FULL关键词，则只显示每个查询的前100个字符。</p><h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.6/en/thread-commands.html" rel="external nofollow noopener noreferrer" target="_blank">https://dev.mysql.com/doc/refman/5.6/en/thread-commands.html</a></p><ul><li><p>Sleep<br>通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内</p><p>实例:因前端数据输出时（特别是输出到用户终端）未及时关闭数据库连接，导致因网络连接速度产生大量sleep连接，在网速出现异常时，数据库 too many connections挂死。</p><p>简单解读，数据查询和执行通常只需要不到0.01秒，而网络输出通常需要1秒左右甚至更长，原本数据连接在0.01秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在 结果未展现在用户桌面前，该数据库连接一直维持在sleep状态！</p></li><li><p>Waiting for net / reading from net / writing to net<br>偶尔出现无妨，如大量出现，迅速检查数据库到前端的网络连接状态和流量<br>Reading from net 表示server端正通过网络读取客户端发送过来的请求建议：减小客户端发送数据包大小，提高网络带宽/质量<br>Writing to net通过网络传输数据</p><p>案例: 因外挂程序，内网数据库大量读取，内网使用的百兆交换迅速爆满，导致大量连接阻塞在waiting for net，数据库连接过多崩溃</p></li><li><p>Locked<br>有更新操作锁定，通常使用innodb可以很好的减少locked状态的产生，但是切记，更新操作要正确使用索引，即便是低频次更新操作也不能疏忽。如上影响结果集范例所示。<br>在myisam的时代，locked是很多高并发应用的噩梦。所以mysql官方也开始倾向于推荐innodb。</p></li><li><p>Copy to tmp table<br>索引及现有结构无法涵盖查询条件，才会建立一个临时表来满足查询要求，产生巨大的恐怖的i/o压力。<br>很可怕的搜索语句会导致这样的情况，如果是数据分析，或者半夜的周期数据清理任务，偶尔出现，可以允许。频繁出现务必优化之。<br>执行ALTER TABLE修改表结构时建议：放在凌晨执行或者采用类似pt-osc工具<br>通常与连表查询有关，建议逐渐习惯不使用连表查询。</p><p>实战范例：某社区数据库阻塞，求救，经查，其服务器存在多个数据库应用和网站，其中一个不常用的小网站数据库产生了一个恐怖的copy to tmp table 操作，导致整个硬盘i/o和cpu压力超载。Kill掉该操作一切恢复。</p></li><li><p>Copying to tmp table<br>拷贝数据到内存中的临时表，常见于GROUP BY操作时,建议：创建适当的索引</p></li><li><p>Copying to tmp table on disk<br>临时结果集太大，内存中放不下，需要将内存中的临时表拷贝到磁盘上，形成 <code>*sql.MYD</code>、<code>*sql.MYI</code>（在5.6及更高的版本，临时表可以改成InnoDB引擎了，可以参考选项default_tmp_storage_engine）建议：创建适当的索引，并且适当加大sort_buffer_size/tmp_table_size/max_heap_table_size</p></li><li><p>Creating sort index<br>当前的SELECT中需要用到临时表在进行ORDER BY排序，建议：创建适当的索引</p></li><li><p>Sending data<br>并不是发送数据，别被这个名字所欺骗，这是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，<br>偶尔出现该状态连接无碍。回到上面影响结果集的问题，一般而言，如果sending data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化。<br>前文提到影响结果集对SQL查询效率线性相关，主要就是针对这个状态的系统开销。<br>如果出现大量相似的SQL语句出现在show proesslist列表中，并且都处于sending data状态，优化查询索引，记住用影响结果集的思路去思考。<br>从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见备注：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net</p><p>建议：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量</p></li><li><p>Creating tmp table<br>创建基于内存或磁盘的临时表，当从内存转成磁盘的临时表时，状态会变成：Copying to tmp table on disk<br>建议：创建适当的索引，或者少用UNION、视图(VIEW)、子查询(SUBQUERY)之类的，确实需要用到临时表的时候，可以在session级临时适当调大 tmp_table_size/max_heap_table_size 的值</p></li><li><p>Storing result to query cache<br>出现这种状态，如果频繁出现，使用set profiling分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query cache碎片较多<br>使用flush query cache 可即时清理，也可以做成定时任务<br>Query cache参数可适当酌情设置。</p></li><li><p>Freeing items<br>理论上这玩意不会出现很多。偶尔出现无碍<br>如果大量出现，内存，硬盘可能已经出现问题。比如硬盘满或损坏。<br>i/o压力过大时，也可能出现Free items执行时间较长的情况。</p></li><li><p>Sorting for …<br>和Sending data类似，结果集过大，排序条件没有索引化，需要在内存里排序，甚至需要创建临时结构排序。</p></li><li><p>Sorting result<br>正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序建议：创建适当的索引</p></li><li><p>statistics<br>进行数据统计以便解析执行计划，如果状态比较经常出现，有可能是磁盘IO性能很差建议：查看当前io性能状态，例如iowait</p></li><li><p>Waiting for global read lock<br>FLUSH TABLES WITH READ LOCK整等待全局读锁<br>建议：不要对线上业务数据库加上全局读锁，通常是备份引起，可以放在业务低谷期间执行或者放在slave服务器上执行备份</p></li><li><p>Waiting for tables,Waiting for table flush<br>FLUSH TABLES, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, OPTIMIZE TABLE等需要刷新表结构并重新打开<br>建议：不要对线上业务数据库执行这些操作，可以放在业务低谷期间执行</p></li><li><p>Waiting for lock_type lock<br>等待各种类型的锁：</p><ul><li>Waiting for event metadata lock</li><li>Waiting for global read lock</li><li>Waiting for schema metadata lock</li><li>Waiting for stored function metadata lock</li><li>Waiting for stored procedure metadata lock</li><li>Waiting for table level lock</li><li>Waiting for table metadata lock</li><li>Waiting for trigger metadata lock</li></ul><p>建议：比较常见的是上面提到的global read lock以及table metadata lock，建议不要对线上业务数据库执行这些操作，可以放在业务低谷期间执行。如果是table level lock，通常是因为还在使用MyISAM引擎表，赶紧转投InnoDB引擎吧，别再老顽固了</p></li></ul><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>官方文档:<a href="http://dev.mysql.com/doc/refman/5.6/en/general-thread-states.html" rel="external nofollow noopener noreferrer" target="_blank">http://dev.mysql.com/doc/refman/5.6/en/general-thread-states.html</a></p><ul><li><p>After create<br>当线程创建表（包括临时表）</p></li><li><p>Analyzing<br>线程正在分析MYISAM的key分布</p></li><li><p>checking permissions<br>线程正在检查执行语句的权限</p></li><li><p>Checking table<br>线程正在执行表check操作</p></li><li><p>Cleaning up<br>线程已经处理完一个命令然后开始准备释放内存和reset状态变量</p></li><li><p>Closing tables<br>线程把改变的表数据flush到磁盘然后关闭使用的表。这个操作应该是很快的，如果这个状态长时间出现，要留意检查磁盘的状态。</p></li><li><p>Converting HEAP to MyISAM<br>把一个内存中的临时表转换到磁盘上的MYISAM表</p></li><li><p>Copy to tmp table<br>线程执行alter table语句。这个状态出现在新的表结构已经创建但数据还在拷贝到新表之前。</p></li><li><p>Copying to group table<br>如果一个语句的group by和order by 条件不同，数据通过group by来排序然后拷贝到临时表</p></li><li><p>Copying to tmp table<br>拷贝到内存中的临时表</p></li><li><p>Copying to tmp table on disk<br>如果临时表过大，服务器要把内存中的临时表拷贝到磁盘。</p></li><li><p>Creating index<br>对一个MYISAM 执行ALTER TABLE … ENABLE KEYS</p></li><li><p>Creating sort index<br>线程通过执行一个临时表来执行select语句</p></li><li><p>Creating table<br>线程正在创建表（包括临时表）</p></li><li><p>Creating tmp table<br>创建临时表（在内存或者磁盘）上，如果表一开始在内存中到后面太大，临时表就会转换到磁盘上，而且状态也会变成Copying to tmp table on disk</p></li><li><p>deleting from main table<br>服务器正在执行一个多表delete语句的第一部分，也就是从第一张表删除数据，并且保留行以及偏移量数据以用来删除其他表中的数据。</p></li><li><p>deleting from reference tables<br>服务器正在执行一个多表delete语句的二部分</p></li><li><p>discard_or_import_tablespace<br>线程正在执行ALTER TABLE … DISCARD TABLESPACE 或者ALTER TABLE … IMPORT TABLESPACE 语句.</p></li><li><p>end<br>这个状态出现在ALTER TABLE, CREATE VIEW, DELETE, INSERT, SELECT, UPDATE语句结束之后，但在清理以前。</p></li><li><p>executing<br>线程开始执行一个语句</p></li><li><p>Execution of init_command<br>线程在init_command系统变量中执行语句</p></li><li><p>freeing items<br>线程已经执行命令。一些释放</p></li><li><p>Flushing tables<br>这个线程执行了FLUSH TABLES，而且等待所有的线程关闭表</p></li><li><p>FULLTEXT initialization<br>服务器准备执行文本搜索</p></li><li><p>Killed<br>发送了kill 语句给这个查询。这个语句在下次检查kill标志的时候，这个语句就应该放弃掉</p></li><li><p>Locked<br>查询被其他的查询锁住了</p></li><li><p>logging slow query<br>线程正在把慢sql写到慢查询log文件中</p></li><li><p>login<br>直到线程授权成功以前都是这个状态</p></li><li><p>manage keys<br>服务器正在管理表的索引</p></li><li><p>Opening tables, Opening table<br>线程正在打开表。这个操作是很快的，除非有其他原因阻止了打开操作，例如ALTER TABLE   LOCK TABLE</p></li><li><p>optimizing<br>服务器正在进行一个查询的初始阶段优化</p></li><li><p>preparing<br>正在进行查询优化</p></li><li><p>Purging old relay logs<br>线程删除不需要的relay log文件</p></li><li><p>query end<br>这个状态出现在处理完以后但在冻结item之前</p></li><li><p>Reading from net<br>服务器从网络读取包</p></li><li><p>Removing duplicates<br>查询使用了select distinct。mysq在发送数据到客户端之前需要一个额外的过程来删除重复的行</p></li><li><p>removing tmp table<br>在执行了select语句以后，线程正在删除内部的临时表</p></li><li><p>rename<br>线程正在重命名表</p></li><li><p>rename result table<br>线程正在执行一个alter table语句，而且已经创建了新表，对新表重命名来替换原始表。</p></li><li><p>Reopen tables<br>线程获取了一个表的锁。由于它已经得知它依赖的表结构已经发生了变化。线程需要释放锁、关闭表、然后尝试重新打开他。</p></li><li><p>Repair by sorting<br>修复代码通过排序来创建索引。</p></li><li><p>Repair done<br>线程完成了对一个myisam表的多线程修复。</p></li><li><p>Repair with keycache<br>修复代码正在通过key的缓存创建key。</p></li><li><p>Rolling back<br>线程正在回滚事物。</p></li><li><p>Saving state<br>myisam的analysis和repair操作中，线程会把表的一些信息例如表的行数、AUTO_INCREMENT的计数器以及key的分布都保存到.MYI文件的头部</p></li><li><p>Searching rows for update<br>语句执行的第一个阶段，找到所有满足条件的行记录</p></li><li><p>Sending data<br>线程在读取和处理SELECT语句，发送数据到客户端。由于语句需要大量的磁盘访问，这个状态会在语句的整个生命周期中占据最长的一个状态。</p></li><li><p>setup<br>线程开始进行ALTER TABLE 语句</p></li><li><p>Sorting for group<br>线程正在为group by 执行排序</p></li><li><p>Sorting for order<br>线程正在为order by 执行排序</p></li><li><p>Sorting index<br>在myisam表的优化操作中，进行索引页的排序以便获得更好的访问性能。</p></li><li><p>Sorting result<br>对结果进行排序</p></li><li><p>Statistics<br>服务器正在计算统计数据从而来生成一个执行计划。如果一个线程保留这个状态很长的时间，意味着服务器在执行其他的磁盘相关的工作。</p></li><li><p>System lock<br>线程正在请求和获取一个内部和外部锁。如果有这个状态</p></li><li><p>Table lock<br>System Lock后的另一个线程状态。线程已经获取了一个外部锁，然后接下来要去获取一个内部表锁。</p></li><li><p>update<br>线程已经准备好去更新</p></li><li><p>Updating<br>现在正在找或者正在更新行</p></li><li><p>updating main table<br>服务器正在执行一个多表update语句，正在更新第一张表，保存行和偏移量以用来更新其他表。</p></li><li><p>updating reference tables<br>服务器正在执行一个多表update语句的第二部分，正在从其他表更新行</p></li><li><p>User lock<br>请求或者等待获取一个锁</p></li><li><p>User sleep<br>线程sleep</p></li><li><p>Waiting for release of readlock<br>等待一个全局的读锁</p></li><li><p>Waiting for tables, Waiting for table<br>线程获得提示依赖的表结构发生了改变，线程需要重新打开表来获取新的结构。但是，重新打开表是需要等待其他的线程关闭表。</p></li><li><p>Waiting on cond<br>线程正在等条件变成true</p></li><li><p>Waiting to get readlock<br>线程用FLUSH TABLES WITH READ LOCK语句，所以要获得一个全局的读锁，这个状态表示正在等这个锁。</p></li><li><p>Writing to net<br>服务器把包写到网络</p></li></ul><h2 id="查看mysql状态"><a href="#查看mysql状态" class="headerlink" title="查看mysql状态"></a>查看mysql状态</h2><h3 id="show-status-与-show-global-status-区别"><a href="#show-status-与-show-global-status-区别" class="headerlink" title="show status 与 show global status 区别"></a>show status 与 show global status 区别</h3><p>status：当前连接的状态（当前会话/连接）<br>global status：mysql 启动后到目前的状态（全局会话）</p><h3 id="show-status-详解"><a href="#show-status-详解" class="headerlink" title="show status 详解"></a>show status 详解</h3><p>官方文档：<a href="http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html" rel="external nofollow noopener noreferrer" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html</a></p><table><thead><tr><th>状态名</th><th>作用域</th><th>详细解释</th></tr></thead><tbody><tr><td>Aborted_clients</td><td>Global</td><td>由于客户端没有正确关闭连接导致客户端终止而中断的连接数</td></tr><tr><td>Aborted_connects</td><td>Global</td><td>试图连接到MySQL服务器而失败的连接数</td></tr><tr><td>Binlog_cache_disk_use</td><td>Global</td><td>使用临时二进制日志缓存但超过binlog_cache_size值并使用临时文件来保存事务中的语句的事务数量</td></tr><tr><td>Binlog_cache_use</td><td>Global</td><td>使用临时二进制日志缓存的事务数量</td></tr><tr><td>Bytes_received</td><td>Both</td><td>从所有客户端接收到的字节数。</td></tr><tr><td>Bytes_sent</td><td>Both</td><td>发送给所有客户端的字节数。</td></tr><tr><td>com*</td><td></td><td>各种数据库操作的数量</td></tr><tr><td>Compression</td><td>Session</td><td>客户端与服务器之间只否启用压缩协议</td></tr><tr><td>Connections</td><td>Global</td><td>试图连接到(不管是否成功)MySQL服务器的连接数</td></tr><tr><td>Created_tmp_disk_tables</td><td>Both</td><td>服务器执行语句时在硬盘上自动创建的临时表的数量</td></tr><tr><td>Created_tmp_files</td><td>Global</td><td>mysqld已经创建的临时文件的数量</td></tr><tr><td>Created_tmp_tables</td><td>Both</td><td>服务器执行语句时自动创建的内存中的临时表的数量。如果Created_tmp_disk_tables较大，你可能要增加tmp_table_size值使临时表基于内存而不基于硬盘</td></tr><tr><td>Delayed_errors</td><td>Global</td><td>用INSERT DELAYED写的出现错误的行数(可能为duplicate key)。</td></tr><tr><td>Delayed_insert_threads</td><td>Global</td><td>使用的INSERT DELAYED处理器线程数。</td></tr><tr><td>Delayed_writes</td><td>Global</td><td>写入的INSERT DELAYED行数</td></tr><tr><td>Flush_commands</td><td>Global</td><td>执行的FLUSH语句数。</td></tr><tr><td>Handler_commit</td><td>Both</td><td>内部提交语句数</td></tr><tr><td>Handler_delete</td><td>Both</td><td>行从表中删除的次数。</td></tr><tr><td>Handler_discover</td><td>Both</td><td>MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。</td></tr><tr><td>Handler_prepare</td><td>Both</td><td>A counter for the prepare phase of two-phase commit operations.</td></tr><tr><td>Handler_read_first</td><td>Both</td><td>索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引。</td></tr><tr><td>Handler_read_key</td><td>Both</td><td>根据键读一行的请求数。如果较高，说明查询和表的索引正确。</td></tr><tr><td>Handler_read_next</td><td>Both</td><td>按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</td></tr><tr><td>Handler_read_prev</td><td>Both</td><td>按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</td></tr><tr><td>Handler_read_rnd</td><td>Both</td><td>根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。</td></tr><tr><td>Handler_read_rnd_next</td><td>Both</td><td>在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</td></tr><tr><td>Handler_rollback</td><td>Both</td><td>内部ROLLBACK语句的数量。</td></tr><tr><td>Handler_savepoint</td><td>Both</td><td>在一个存储引擎放置一个保存点的请求数量。</td></tr><tr><td>Handler_savepoint_rollback</td><td>Both</td><td>在一个存储引擎的要求回滚到一个保存点数目。</td></tr><tr><td>Handler_update</td><td>Both</td><td>在表内更新一行的请求数。</td></tr><tr><td>Handler_write</td><td>Both</td><td>在表内插入一行的请求数。</td></tr><tr><td>Innodb_buffer_pool_pages_data</td><td>Global</td><td>包含数据的页数(脏或干净)。</td></tr><tr><td>Innodb_buffer_pool_pages_dirty</td><td>Global</td><td>当前的脏页数。</td></tr><tr><td>Innodb_buffer_pool_pages_flushed</td><td>Global</td><td>要求清空的缓冲池页数</td></tr><tr><td>Innodb_buffer_pool_pages_free</td><td>Global</td><td>空页数。</td></tr><tr><td>Innodb_buffer_pool_pages_latched</td><td>Global</td><td>在InnoDB缓冲池中锁定的页数。这是当前正读或写或由于其它原因不能清空或删除的页数。</td></tr><tr><td>Innodb_buffer_pool_pages_misc</td><td>Global</td><td>忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。该值还可以计算为Innodb_buffer_pool_pages_total - Innodb_buffer_pool_pages_free - Innodb_buffer_pool_pages_data。</td></tr><tr><td>Innodb_buffer_pool_pages_total</td><td>Global</td><td>缓冲池总大小（页数）。</td></tr><tr><td>Innodb_buffer_pool_read_ahead_rnd</td><td>Global</td><td>InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。</td></tr><tr><td>Innodb_buffer_pool_read_ahead_seq</td><td>Global</td><td>InnoDB初始化的顺序read-aheads数。当InnoDB执行顺序全表扫描时发生。</td></tr><tr><td>Innodb_buffer_pool_read_requests</td><td>Global</td><td>InnoDB已经完成的逻辑读请求数。</td></tr><tr><td>Innodb_buffer_pool_reads</td><td>Global</td><td>不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。</td></tr><tr><td>Innodb_buffer_pool_wait_free</td><td>Global</td><td>一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。</td></tr><tr><td>Innodb_buffer_pool_write_requests</td><td>Global</td><td>向InnoDB缓冲池的写数量。</td></tr><tr><td>Innodb_data_fsyncs</td><td>Global</td><td>fsync()操作数。</td></tr><tr><td>Innodb_data_pending_fsyncs</td><td>Global</td><td>当前挂起的fsync()操作数。</td></tr><tr><td>Innodb_data_pending_reads</td><td>Global</td><td>当前挂起的读数。</td></tr><tr><td>Innodb_data_pending_writes</td><td>Global</td><td>当前挂起的写数。</td></tr><tr><td>Innodb_data_read</td><td>Global</td><td>至此已经读取的数据数量（字节）。</td></tr><tr><td>Innodb_data_reads</td><td>Global</td><td>数据读总数量。</td></tr><tr><td>Innodb_data_writes</td><td>Global</td><td>数据写总数量。</td></tr><tr><td>Innodb_data_written</td><td>Global</td><td>至此已经写入的数据量（字节）。</td></tr><tr><td>Innodb_dblwr_pages_written</td><td>Global</td><td>已经执行的双写操作数量</td></tr><tr><td>Innodb_dblwr_writes</td><td>Global</td><td>双写操作已经写好的页数</td></tr><tr><td>Innodb_log_waits</td><td>Global</td><td>我们必须等待的时间，因为日志缓冲区太小，我们在继续前必须先等待对它清空</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Innodb_log_write_requests</td><td>Global</td><td>日志写请求数。</td></tr><tr><td>Innodb_log_writes</td><td>Global</td><td>向日志文件的物理写数量。</td></tr><tr><td>Innodb_os_log_fsyncs</td><td>Global</td><td>向日志文件完成的fsync()写数量。</td></tr><tr><td>Innodb_os_log_pending_fsyncs</td><td>Global</td><td>挂起的日志文件fsync()操作数量。</td></tr><tr><td>Innodb_os_log_pending_writes</td><td>Global</td><td>挂起的日志文件写操作</td></tr><tr><td>Innodb_os_log_written</td><td>Global</td><td>写入日志文件的字节数。</td></tr><tr><td>Innodb_page_size</td><td>Global</td><td>编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。</td></tr><tr><td>Innodb_pages_created</td><td>Global</td><td>创建的页数。</td></tr><tr><td>Innodb_pages_read</td><td>Global</td><td>读取的页数。</td></tr><tr><td>Innodb_pages_written</td><td>Global</td><td>写入的页数。</td></tr><tr><td>Innodb_row_lock_current_waits</td><td>Global</td><td>当前等待的待锁定的行数。</td></tr><tr><td>Innodb_row_lock_time</td><td>Global</td><td>行锁定花费的总时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_time_avg</td><td>Global</td><td>行锁定的平均时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_time_max</td><td>Global</td><td>行锁定的最长时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_waits</td><td>Global</td><td>一行锁定必须等待的时间数。</td></tr><tr><td>Innodb_rows_deleted</td><td>Global</td><td>从InnoDB表删除的行数。</td></tr><tr><td>Innodb_rows_inserted</td><td>Global</td><td>插入到InnoDB表的行数。</td></tr><tr><td>Innodb_rows_read</td><td>Global</td><td>从InnoDB表读取的行数。</td></tr><tr><td>Innodb_rows_updated</td><td>Global</td><td>InnoDB表内更新的行数。</td></tr><tr><td>Key_blocks_not_flushed</td><td>Global</td><td>键缓存内已经更改但还没有清空到硬盘上的键的数据块数量。</td></tr><tr><td>Key_blocks_unused</td><td>Global</td><td>键缓存内未使用的块数量。你可以使用该值来确定使用了多少键缓存</td></tr><tr><td>Key_blocks_used</td><td>Global</td><td>键缓存内使用的块数量。该值为高水平线标记，说明已经同时最多使用了多少块。</td></tr><tr><td>Key_read_requests</td><td>Global</td><td>从缓存读键的数据块的请求数。</td></tr><tr><td>Key_reads</td><td>Global</td><td>从硬盘读取键的数据块的次数。如果Key_reads较大，则Key_buffer_size值可能太小。可以用Key_reads/Key_read_requests计算缓存损失率。</td></tr><tr><td>Key_write_requests</td><td>Global</td><td>将键的数据块写入缓存的请求数。</td></tr><tr><td>Key_writes</td><td>Global</td><td>向硬盘写入将键的数据块的物理写操作的次数。</td></tr><tr><td>Last_query_cost</td><td>Session</td><td>用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。默认值是0。Last_query_cost具有会话范围。</td></tr><tr><td>Max_used_connections</td><td>Global</td><td>服务器启动后已经同时使用的连接的最大数量。</td></tr><tr><td>ndb*</td><td></td><td>ndb集群相关</td></tr><tr><td>Not_flushed_delayed_rows</td><td>Global</td><td>等待写入INSERT DELAY队列的行数。</td></tr><tr><td>Open_files</td><td>Global</td><td>打开的文件的数目。</td></tr><tr><td>Open_streams</td><td>Global</td><td>打开的流的数量(主要用于记录)。</td></tr><tr><td>Open_table_definitions</td><td>Global</td><td>缓存的.frm文件数量</td></tr><tr><td>Open_tables</td><td>Both</td><td>当前打开的表的数量。</td></tr><tr><td>Opened_files</td><td>Global</td><td>文件打开的数量。不包括诸如套接字或管道其他类型的文件。 也不包括存储引擎用来做自己的内部功能的文件。</td></tr><tr><td>Opened_table_definitions</td><td>Both</td><td>已经缓存的.frm文件数量</td></tr><tr><td>Opened_tables</td><td>Both</td><td>已经打开的表的数量。如果Opened_tables较大，table_cache 值可能太小。</td></tr><tr><td>Prepared_stmt_count</td><td>Global</td><td>当前的预处理语句的数量。(最大数为系统变量: max_prepared_stmt_count)</td></tr><tr><td>Qcache_free_blocks</td><td>Global</td><td>查询缓存内自由内存块的数量。</td></tr><tr><td>Qcache_free_memory</td><td>Global</td><td>用于查询缓存的自由内存的数量。</td></tr><tr><td>Qcache_hits</td><td>Global</td><td>查询缓存被访问的次数。</td></tr><tr><td>Qcache_inserts</td><td>Global</td><td>加入到缓存的查询数量。</td></tr><tr><td>Qcache_lowmem_prunes</td><td>Global</td><td>由于内存较少从缓存删除的查询数量。</td></tr><tr><td>Qcache_not_cached</td><td>Global</td><td>非缓存查询数(不可缓存，或由于query_cache_type设定值未缓存)。</td></tr><tr><td>Qcache_queries_in_cache</td><td>Global</td><td>登记到缓存内的查询的数量。</td></tr><tr><td>Qcache_total_blocks</td><td>Global</td><td>查询缓存内的总块数。</td></tr><tr><td>Queries</td><td>Both</td><td>服务器执行的请求个数，包含存储过程中的请求。</td></tr><tr><td>Questions</td><td>Both</td><td>已经发送给服务器的查询的个数。</td></tr><tr><td>Rpl_status</td><td>Global</td><td>失败安全复制状态(还未使用)。</td></tr><tr><td>Select_full_join</td><td>Both</td><td>没有使用索引的联接的数量。如果该值不为0,你应仔细检查表的索引</td></tr><tr><td>Select_full_range_join</td><td>Both</td><td>在引用的表中使用范围搜索的联接的数量。</td></tr><tr><td>Select_range</td><td>Both</td><td>在第一个表中使用范围的联接的数量。一般情况不是关键问题，即使该值相当大。</td></tr><tr><td>Select_range_check</td><td>Both</td><td>在每一行数据后对键值进行检查的不带键值的联接的数量。如果不为0，你应仔细检查表的索引。</td></tr><tr><td>Select_scan</td><td>Both</td><td>对第一个表进行完全扫描的联接的数量。</td></tr><tr><td>Slave_heartbeat_period</td><td>Global</td><td>复制的心跳间隔</td></tr><tr><td>Slave_open_temp_tables</td><td>Global</td><td>从服务器打开的临时表数量</td></tr><tr><td>Slave_received_heartbeats</td><td>Global</td><td>从服务器心跳数</td></tr><tr><td>Slave_retried_transactions</td><td>Global</td><td>本次启动以来从服务器复制线程重试次数</td></tr><tr><td>Slave_running</td><td>Global</td><td>如果该服务器是连接到主服务器的从服务器，则该值为ON。</td></tr><tr><td>Slow_launch_threads</td><td>Both</td><td>创建时间超过slow_launch_time秒的线程数。</td></tr><tr><td>Slow_queries</td><td>Both</td><td>查询时间超过long_query_time秒的查询的个数。</td></tr><tr><td>Sort_merge_passes</td><td>Both</td><td>排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort_buffer_size系统变量的值。</td></tr><tr><td>Sort_range</td><td>Both</td><td>在范围内执行的排序的数量。</td></tr><tr><td>Sort_rows</td><td>Both</td><td>已经排序的行数。</td></tr><tr><td>Sort_scan</td><td>Both</td><td>通过扫描表完成的排序的数量。</td></tr><tr><td>ssl＊</td><td></td><td>ssl连接相关</td></tr><tr><td>Table_locks_immediate</td><td>Global</td><td>立即获得的表的锁的次数。</td></tr><tr><td>Table_locks_waited</td><td>Global</td><td>不能立即获得的表的锁的次数。如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。</td></tr><tr><td>Threads_cached</td><td>Global</td><td>线程缓存内的线程的数量。</td></tr><tr><td>Threads_connected</td><td>Global</td><td>当前打开的连接的数量。</td></tr><tr><td>Threads_created</td><td>Global</td><td>创建用来处理连接的线程数。如果Threads_created较大，你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections。</td></tr><tr><td>Threads_running</td><td>Global</td><td>激活的（非睡眠状态）线程数。</td></tr><tr><td>Uptime</td><td>Global</td><td>服务器已经运行的时间（以秒为单位）。</td></tr><tr><td>Uptime_since_flush_status</td><td>Global</td><td>最近一次使用FLUSH STATUS的时间（以秒为单位）。</td></tr></tbody></table><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;优化步骤&quot;&gt;&lt;a href=&quot;#优化步骤&quot; class=&quot;head
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>分析问题</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/数据库/Mysql/分析问题/</id>
    <published>2017-11-17T02:15:00.000Z</published>
    <updated>2017-12-03T16:04:44.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><ul><li>要学会怎样分析问题，而不是单纯拍脑袋优化</li><li>慢查询只是最基础的东西，要学会优化0.01秒的查询请求。</li><li>当发生连接阻塞时，不同状态的阻塞有不同的原因，要找到原因，如果不对症下药，就会南辕北辙<ul><li>范例：如果本身系统内存已经超载，已经使用到了swap，而还在考虑加大缓存来优化查询，那就是自寻死路了。</li></ul></li><li>影响结果集是非常重要的中间数据和优化指标，学会理解这一概念，理论上影响结果集与查询效率呈现非常紧密的线性相关。</li><li>监测与跟踪要经常做，而不是出问题才做<ul><li>读取频繁度抽样监测<ul><li>全监测不要搞，i/o吓死人。</li><li>按照一个抽样比例抽样即可。</li><li>针对抽样中发现的问题，可以按照特定SQL在特定时间内监测一段全查询记录，但仍要考虑i/o影响。</li></ul></li><li>写入频繁度监测<ul><li>基于binlog解开即可，可定时或不定时分析。</li></ul></li><li>微慢查询抽样监测<ul><li>高并发情况下，查询请求时间超过0.01秒甚至0.005秒的，建议酌情抽样记录。</li></ul></li><li>连接数预警监测<ul><li>连接数超过特定阈值的情况下，虽然数据库没有崩溃，建议记录相关连接状态。</li></ul></li></ul></li><li>学会通过数据和监控发现问题，分析问题，而后解决问题顺理成章。特别是要学会在日常监控中发现隐患，而不是问题爆发了才去处理和解决。</li></ul><h1 id="常见关注的重点"><a href="#常见关注的重点" class="headerlink" title="常见关注的重点"></a>常见关注的重点</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><ul><li><p>是否锁定，及锁定时间<br>如存在锁定，则该慢查询通常是因锁定因素导致，本身无需优化，需解决锁定问题。</p></li><li><p>影响结果集<br>如影响结果集较大，显然是索引项命中存在问题，需要认真对待。</p></li></ul><h2 id="Explain-操作"><a href="#Explain-操作" class="headerlink" title="Explain 操作"></a>Explain 操作</h2><ul><li><p>索引项使用<br>不建议用using index做强制索引，如未如预期使用索引，建议重新斟酌表结构和索引设置。</p></li><li><p>影响结果集<br>这里显示的数字不一定准确，结合之前提到对数据索引的理解来看，还记得嘛？就把索引当作有序序列来理解，反思SQL。</p></li></ul><h2 id="Set-profiling-show-profiles-for-query操作"><a href="#Set-profiling-show-profiles-for-query操作" class="headerlink" title="Set profiling , show profiles for query操作"></a>Set profiling , show profiles for query操作</h2><ul><li>执行开销<ul><li>注意，有问题的SQL如果重复执行，可能在缓存里，这时要注意避免缓存影响。通过这里可以看到。</li><li>执行时间超过0.005秒的频繁操作SQL建议都分析一下。</li><li>深入理解数据库执行的过程和开销的分布</li></ul></li></ul><h2 id="Show-processlist-执行状态监控"><a href="#Show-processlist-执行状态监控" class="headerlink" title="Show processlist 执行状态监控"></a>Show processlist 执行状态监控</h2><p>这是在数据库负载波动时经常进行的一项操作<br>具体参见：<a href="/技术之路/数据库/Mysql/优化/#执行状态">查看执行状态</a></p><h1 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h1><h2 id="确认问题"><a href="#确认问题" class="headerlink" title="确认问题"></a>确认问题</h2><p><strong>详细了解问题状况</strong></p><ul><li>Too many connections 是常见表象，有很多种原因。</li><li>索引损坏的情况在innodb情况下很少出现。</li><li>如出现其他情况应追溯日志和错误信息。</li></ul><h2 id="确认瓶颈"><a href="#确认瓶颈" class="headerlink" title="确认瓶颈"></a>确认瓶颈</h2><p><strong>常见的瓶颈</strong></p><ul><li><p>cpu 非常高–索引问题 or 并发太高（通常是索引问题）<br>并发问题：thread_pool 限制连接数（其他分支都支持线程池）</p></li><li><p>内存 swap高 – 内存分配不足（过多会 oom）<br>适量调整内存，不要太大也不要太小，50%-70%比较保守，80%太偏激，尽量覆盖全部热点数据<br>mysql 专用服务器，关闭 swap</p></li><li><p>iowait 太高 – 内存不足 or io 设备性能太低 or 索引不当 or 频繁读取 select  or 频繁排序/分组</p></li></ul><h3 id="了解基本运营状况"><a href="#了解基本运营状况" class="headerlink" title="了解基本运营状况"></a>了解基本运营状况</h3><ul><li>当前每秒读请求</li><li>当前每秒写请求</li><li>当前在线用户</li><li>当前数据容量</li></ul><h3 id="了解基本负载情况"><a href="#了解基本负载情况" class="headerlink" title="了解基本负载情况"></a>了解基本负载情况</h3><p>学会使用这些指令</p><ul><li>Top –系统状态，哪个服务/进程消耗的 cpu 、内存</li><li>Vmstat – 查看 cpu、io、内存负载</li><li>dstat – 和 vmstat 类似，结果更友好</li><li>sar – systat 工具包的一个命令；关注（sar  -u / -d / -r）cpu/io/内存</li><li>iotop – 查看哪个进程 io 消耗最高</li><li>oprofile – 神器，一般用不上，用法自己查</li><li>strace – 跟踪进程执行时的系统调用和所接收的信号</li><li>uptime</li><li>iostat</li><li>df</li></ul><p>Cpu负载构成</p><ul><li>特别关注i/o压力( wa%)</li><li>多核负载分配</li></ul><p>内存占用</p><ul><li>Swap分区是否被侵占，若Swap分区被侵占，物理内存是否较多空闲</li></ul><p>磁盘状态</p><ul><li>硬盘满和inode节点满的情况要迅速定位和迅速处理</li></ul><h3 id="查看-mysql-的状态"><a href="#查看-mysql-的状态" class="headerlink" title="查看 mysql 的状态"></a>查看 mysql 的状态</h3><p><strong>当前连接数</strong></p><ul><li>Netstat –an|grep 3306|wc –l</li><li>Show processlist</li></ul><p><strong>当前连接分布 show processlist</strong></p><ul><li>前端应用请求数据库不要使用root帐号！<ul><li>Root帐号比其他普通帐号多一个连接数许可。</li><li>前端使用普通帐号，在too many connections的时候root帐号仍可以登录数据库查询 show processlist!</li><li>记住，前端应用程序不要设置一个不叫root的root帐号来糊弄！非root账户是骨子里的，而不是名义上的。</li></ul></li><li>状态分布<ul><li>不同状态代表不同的问题，有不同的优化目标。</li></ul></li><li>雷同SQL的分布<ul><li>是否较多雷同SQL出现在同一状态</li></ul></li></ul><p><strong>当前是否有较多慢查询日志</strong></p><ul><li>是否锁定</li><li>影响结果集</li></ul><p><strong>常用命令</strong></p><ul><li><p>slow log<br>优先频次高，其次耗时久</p></li><li><p>show global status</p><ol><li>查看连接数（活跃、不活跃），设置 interactive_timeout、wait_timeout 的 timecount值，减少不活跃连接</li><li>TPS、QPS、DML_Active<ul><li>tps=(handler_commit_d+handler_rollback_d)/uptime_d</li><li>qps=(questions_d2 - questions_d1)/uptime_d</li><li>dml_active=(com_select_d+com_insert_d+com_update_d+com_delete_d)/uptime_d</li></ul></li><li>各种 buffer、cache 的利用率、命中率<ul><li>innodb_buffer_pool_wait_free&gt;0 说明 innodb_buffer 不够用,有 wait、wait_free 发生，都要关注下</li><li>innodb_row_lock_current_waits 当前行锁的个数</li><li>slow_queries 慢查询的次数</li><li>table_locks_immediate 表锁的次数</li><li>table_locks_waited 表锁等待的次数</li></ul></li></ol></li><li><p>show processlist</p></li><li><p>show engine innodb status<br>主要看锁，事务，等待</p></li><li><p>pt-ioprofile<br>可以查看哪个表在频繁的读写</p></li></ul><h3 id="频繁度分析"><a href="#频繁度分析" class="headerlink" title="频繁度分析"></a>频繁度分析</h3><ul><li>写频繁度<ul><li>如果i/o压力高，优先分析写入频繁度</li><li>Mysqlbinlog 输出最新binlog文件，编写脚本拆分</li><li>最多写入的数据表是哪个</li><li>最多写入的数据SQL是什么</li><li>是否存在基于同一主键的数据内容高频重复写入？<ul><li>涉及架构优化部分，参见架构优化-缓存异步更新</li></ul></li></ul></li><li>读取频繁度<ul><li>如果cpu资源较高，而i/o压力不高，优先分析读取频繁度</li><li>程序中在封装的db类增加抽样日志即可，抽样比例酌情考虑，以不显著影响系统负载压力为底线。</li><li>最多读取的数据表是哪个</li><li>最多读取的数据SQL是什么<ul><li>该SQL进行explain 和set profiling判定</li><li>注意判定时需要避免query cache影响<ul><li>比如，在这个SQL末尾增加一个条件子句 and 1=1 就可以避免从query cache中获取数据，而得到真实的执行状态分析。</li></ul></li></ul></li><li>是否存在同一个查询短期内频繁出现的情况<ul><li>涉及前端缓存优化</li></ul></li></ul></li></ul><h2 id="制定方案"><a href="#制定方案" class="headerlink" title="制定方案"></a>制定方案</h2><p>抓大放小，解决显著问题</p><ul><li>不苛求解决所有优化问题，但是应以保证线上服务稳定可靠为目标。</li><li>解决与评估要同时进行，新的策略或解决方案务必经过评估后上线。</li></ul><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>确认优化方案的覆盖范围，不要为了解决1%的问题而忽略了99%的问题，并且不能带来新的问题（索引滥用，太多索引，导致 dml 效率降低）而且最好再测试环境验证通过后再上线</p><h2 id="实施方案"><a href="#实施方案" class="headerlink" title="实施方案"></a>实施方案</h2><h2 id="回顾反馈"><a href="#回顾反馈" class="headerlink" title="回顾反馈"></a>回顾反馈</h2><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="服务器出现too-many-connections-阻塞"><a href="#服务器出现too-many-connections-阻塞" class="headerlink" title="服务器出现too many connections 阻塞"></a>服务器出现too many connections 阻塞</h2><p>入手点：</p><ul><li>查看服务器状态，cpu占用，内存占用，硬盘占用，硬盘i/o压力</li><li>查看网络流量状态，mysql与应用服务器的输入输出状况</li><li>通过Show processlist查看当前运行清单</li><li>注意事项，日常应用程序连接数据库不要使用root账户，保证故障时可以通过root 进入数据库查看 show processlist。</li></ul><p>状态分析：</p><ul><li>参见如上执行状态清单，根据连接状态的分布去确定原因。</li></ul><p>紧急恢复</p><ul><li>在确定故障原因后，应通过kill掉阻塞进程的方式 立即恢复数据库。</li></ul><p>善后处理：以下针对常见问题简单解读</p><ul><li>Sleep 连接过多导致，应用端及时释放连接，排查关联因素。</li><li>Locked连接过多，如源于myisam表级锁，更innodb引擎;如源于更新操作使用了不恰当的索引或未使用索引，改写更新操作SQL或建立恰当索引。</li><li>Sending data连接过多，用影响结果集的思路优化SQL查询，优化表索引结构。</li><li>Free items连接过多，i/o压力过大 或硬盘故障</li><li>Waiting for net , writing to net 连接过多， mysql与应用服务器连接阻塞。</li><li>其他仍参见如上执行状态清单所示分析。</li><li>如涉及不十分严格安全要求的数据内容，可用定期脚本跟踪请求进程，并kill掉僵死进程。如数据安全要求较严格，则不能如此进行。</li></ul><h2 id="数据库负载过高，响应缓慢"><a href="#数据库负载过高，响应缓慢" class="headerlink" title="数据库负载过高，响应缓慢"></a>数据库负载过高，响应缓慢</h2><p><strong>入手点：</strong></p><ul><li>查看cpu状态，服务器负载构成</li></ul><p><strong>可能问题1：i/o占用过高</strong></p><ul><li>步骤1： 检查内存是否占用swap分区，排除因内存不足导致的i/o开销。</li><li>步骤2：通过iostat 指令分析i/o是否集中于数据库硬盘，是否是写入度较高。</li><li>步骤3：如果压力来自于写，使用mysqlbinlog 解开最新的binlog文件。</li><li>步骤4：编写日志分析脚本或grep指令，分析每秒写入频度和写入内容。<ul><li>写入频度不高，则说明i/o压力另有原因或数据库配置不合理。</li></ul></li><li>步骤5：编写日志分析脚本或grep 指令，分析写入的数据表构成，和写入的目标构成。</li><li>步骤6：编写日志分析脚本，分析是否存在同一主键的重复写入。 比如出现大量 update post set views=views+1 where tagid=的操作，假设在一段时间内出现了2万次，而其中不同的tagid有1万次，那么就是有50%的请求是重复update请求，有可以通过异步更新合并的空间。</li></ul><p>提示一下，以上所提及的日志分析脚本编写，正常情况下不应超过1个小时，而对系统负载分析所提供的数据支持价值是巨大的，对性能优化方案的选择是非常有意义的，如果您认为这项工作是繁冗而且复杂的工作，那么一定是在分析思路和目标把握上出现了偏差。</p><p><strong>可能问题2：i/o占用不高，CPU 占用过高</strong></p><ul><li>步骤1：查看慢查询日志</li><li>步骤2：不断刷新查看Show processlist清单，并把握可能频繁出现的处于Sending data状态的SQL。</li><li>步骤3：记录前端执行SQL<ul><li>于前端应用程序执行查询的封装对象内，设置随机采样，记录前端执行的SQL，保证有一定的样本规模，并且不会带来前端i/o负载的激增。</li><li>基于采样率和记录频率，获得每秒读请求次数数据指标。</li><li>编写日志分析脚本，分析采样的SQL构成，所操作的数据表，所操作的主键。</li><li>对频繁重复读取的SQL(完全一致的SQL)进行判定，是否数据存在频繁变动，是否需要实时展现最新数据，如有可能，缓存化，并预估缓存命中率。</li><li>对频繁读取但不重复的(SQL结构一致，但条件中的数据不一致)SQL进行判定，是否索引足够优化，影响结果集与输出结果是否足够接近。</li></ul></li><li>步骤4：将导致慢查询的SQL或频繁出现于show processlist状态的SQL，或采样记录的频繁度SQL进行分析，按照影响结果集的思路和索引理解来优化。</li><li>步骤5：对如上难以界定问题的SQL进行 set profiling 分析。</li><li>步骤6：优化后分析继续采样跟踪分析。并跟踪比对结果。</li></ul><p><strong>善后处理</strong></p><ul><li>日常跟踪脚本，不断记录一些状态信息。保证每个时间节点都能回溯。</li><li>确保随时能了解服务器的请求频次，读写请求的分布。</li><li>记录一些未造成致命影响的隐患点，可暂不解决，但需要记录。</li><li>如确系服务器请求频次过高，可基于负载分布决定硬件扩容方案，比如i/o压力过高可考虑固态硬盘；内存占用swap可考虑增加内容容量等。用尽可能少的投入实现最好的负载支撑能力，而不是简单的买更多服务器。</li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;head
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title> 架构与表设计</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/数据库/Mysql/架构与表设计/</id>
    <published>2017-11-16T15:35:00.000Z</published>
    <updated>2017-12-03T16:04:44.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ol><li><strong>默认使用innodb 引擎</strong>，基本抛弃 myisam（只读也不一定比 innodb 快）</li><li><strong>text/blob 垂直拆分后，转成 myisam 表</strong>，innodb 存 blob 会产生大量的磁盘碎片</li></ol><p>各存储引擎区别：<a href="/技术之路/数据库/Mysql/基础知识/#数据引擎">存储引擎</a></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><strong>默认使用utf-8</strong></p><p>注意字符集问题，server=&gt;database(trigger、stored procedure、event scheduler)=&gt;table=&gt;column<br>不要同时指定字符集（character set）和校验集（collect set），避免出现和默认对应关系不一致</p><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol><li>越小越好</li><li>字段都NOT NULL<ul><li>默认都加上NOT NULL约束，必须为NULL用0表示</li><li>在对该字段进行COUNT(*)统计时，统计结果更准确（值为NULL的不会被COUNT统计进去）</li></ul></li></ol><h3 id="存储技巧"><a href="#存储技巧" class="headerlink" title="存储技巧"></a>存储技巧</h3><ol><li><p><strong>可使用枚举类型</strong><br>ENUM的内部存储机制是采用TINYINT或SMALLINT（并非CHAR/VARCHAR），性能一点都不差</p></li><li><p><strong>存储ipv4地址</strong><br>用INT UNSIGNED存储IPV4地址，用INET_ATON()、INET_NTOA()进行转换</p></li><li><p><strong>存储日期时间</strong><br><strong>一个常识性误导：建议用TIMESTAMP取代DATETIME。</strong><br>从5.6开始，建议优先选择DATETIME存储日期时间。因为它的可用范围比TIMESTAMP更大，物理存储上仅比TIMESTAMP多1个字节，整体性能上的损失并不大。</p></li><li><p><strong>InnoDB表行记录物理长度不超过8KB</strong><br><strong>InnoDB的data page默认是16KB的情况下。</strong><br>当实际存储长度超过8KB（尤其有TEXT/BLOB列）且读写频繁的话, 则最好把这些列拆分到子表中，不要和主表放在一起存储。如果不太频繁，可以考虑继续保留在主表中<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率">[1]</span></a></sup>。</p></li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol><li>显式指定自增 int/bigint unsigned not null 作为主键(有主键 TPS 提升9%，不要使用 uuid，性能差)</li><li>选择适当的索引顺序，选择性高条件靠前</li><li>基数（ Cardinality ）很低（30%以下）的字段不创建索引（MySQL还不支持 bitmap 索引）</li><li>常用排序（ORDER BY）、分组（GROUP BY）、取唯一（DISTINCT）字段上创建索引</li><li>单表索引数量不超过5个</li><li>不使用外键</li><li>超过20个长度的字符串列（不需要排序），创建前缀索引而非整列索引<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="例如：`ALTER TABLE t1 ADD INDEX(user(20))`前缀索引的长度可以基于对该字段的统计得出，一般略大于平均长度一点就可以了。">[6]</span></a></sup><ul><li>优点:有效提高索引利用率</li><li>缺点:对这个列排序时用不到前缀索引</li></ul></li></ol><h2 id="高级特性使用"><a href="#高级特性使用" class="headerlink" title="高级特性使用"></a>高级特性使用</h2><ol><li><p><strong>是否使用分区表？</strong><br>在可以提升性能或者运维便利性的场景下，还是建议使用分区表。例如：日志系统，按时间纬度进行分区，方便删除历史数据</p></li><li><p><strong>是否使用存储过程、触发器？</strong><br>单机可用，分布式舍弃。（存储器场景：不变的业务逻辑）</p></li><li><p><strong>是否使用视图？</strong><br>MySQL因为没有物化视图，因此视图尽量少用（不用）</p></li></ol><h1 id="缓存与数据库结合"><a href="#缓存与数据库结合" class="headerlink" title="缓存与数据库结合"></a>缓存与数据库结合</h1><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以减少数据库读取请求<br>缺点：增加代码复杂度、增加维护难度</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul><li>评估进入缓存的数据规模，以及命中率优化<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实景分析： 前端请求先连接缓存，缓存未命中连接数据库，进行查询，未命中状态比单纯连接数据库查询多了一次连接和查询的操作；如果缓存命中率很低，则这个额外的操作非但不能提高查询效率，反而为系统带来了额外的负载和复杂性，得不偿失。">[2]</span></a></sup><ul><li>不是所有数据都适合被缓存，也并不是进入了缓存就意味着效率提升</li><li>命中率是第一要评估的数据；<strong>核心在于如何判断哪些属于热点数据</strong></li></ul></li><li>善于利用内存，请注意数据存储的格式及压缩算法。</li></ul><h3 id="如何确定热点数据"><a href="#如何确定热点数据" class="headerlink" title="如何确定热点数据"></a>如何确定热点数据</h3><p>见<a href="#热点数据分表">下文</a></p><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：减少数据库写入<code>i/o</code>压力<br>缺点：数据不能第一时间持久化，有丢失风险</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h3><p>缓存实时更新，数据库异步更新（使用队列,请注意使用<code>increment</code>来维持队列序号）</p><ul><li>不要通过<code>get-&gt;处理数据-&gt;set-&gt;更新数据</code>的方式维护队列<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例:`$var=Memcache_get($memcon,”var”);$var++;memcache_set($memcon,”var”,$var);`这样一个脚本，使用apache ab去跑，100个并发，跑10000次，然后输出缓存存取的数据，很遗憾，并不是1000，而是5000多，6000多这样的数字，中间的数字全在 get & set的过程中丢掉了。原因：读写间隔中其他并发写入，导致数据丢失。">[3]</span></a></sup>。 使用<code>increment</code>存储队列编号，用标记+编号作为<code>key</code>存储队列内容<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例2:用memcache_increment来做这个操作，同样跑测试会得到完整的10000，一条数据不会丢。">[4]</span></a></sup>。</li><li>后台基于缓存队列读取更新数据并更新数据库<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：某论坛热门贴，前端不断有views=views+1数据更新请求。缓存实时更新该状态后台任务对数据库做异步更新时，假设执行周期是5分钟，那么五分钟可能会接收到这样的请求多达数十次乃至数百次，合并更新后只执行一次update即可。类似操作还包括游戏打怪，生命和经验的变化；个人主页访问次数的变化等。">[5]</span></a></sup><ul><li>基于队列读取后可以合并更新</li><li><strong>更新合并率</strong>是重要指标</li></ul></li></ul><h3 id="异步更新风险"><a href="#异步更新风险" class="headerlink" title="异步更新风险"></a>异步更新风险</h3><ul><li><strong>前后端同时写，可能导致覆盖风险。</strong><ul><li>使用后端异步更新，前端应用程序不要写数据库，否则可能造成写入冲突。</li><li>一种兼容的解决方案是，前端和后端不要写相同的字段<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：用户在线上时，后台异步更新用户状态。管理员后台屏蔽用户是直接更新数据库。结果管理员屏蔽某用户操作完成后，因该用户在线有操作，后台异步更新程序再次基于缓存更新用户状态，用户状态被复活，屏蔽失效。">[7]</span></a></sup>。</li></ul></li><li><strong>缓存数据丢失或服务崩溃可能导致数据丢失风险。</strong><ul><li>如缓存中间出现故障，则缓存队列数据不会回写到数据库，而用户会认为已经完成，此时会带来比较明显的用户体验问题。</li><li>一个不彻底的解决方案是，确保高安全性，高重要性数据实时数据更新，而低安全性数据通过缓存异步回写方式完成。此外，使用相对数值操作而不是绝对数值操作更安全<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例：支付信息，道具的购买与获得，一旦丢失会对用户造成极大的伤害。而经验值，访问数字，如果只丢失了很少时间的内容，用户还是可以容忍的。">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例：如果使用 `Views=Views+…`的操作，一旦出现数据格式错误，从binlog中反推是可以进行数据还原，但是如果使用Views=特定值的操作，一旦缓存中数据有错误，则直接被赋予了一个错误数据，无法回溯！">[9]</span></a></sup>。</li></ul></li><li><strong>异步更新如出现队列阻塞可能导致数据丢失风险。</strong><ul><li>异步更新通常是使用缓存队列后，在后台由cron或其他守护进程写入数据库。</li><li>如果队列生成的速度&gt;后台更新写入数据库的速度，就会产生阻塞，导致数据越累计越多，数据库响应迟缓，而缓存队列无法迅速执行，导致溢出或者过期失效。</li><li>解决办法：使用 MQ 队列产品而不使用 memcache 来进行缓存异步更新</li></ul></li></ul><h1 id="反范式设计（冗余）"><a href="#反范式设计（冗余）" class="headerlink" title="反范式设计（冗余）"></a>反范式设计（冗余）</h1><ul><li>适度冗余可以减少查询请求</li><li>适度冗余可以解决分表带来的索引查询问题</li><li>适度冗余可以解决统计类负载较高的查询问题</li><li>适度冗余可以减少 io 请求频次，提高 io 支撑能力(cpu 换 io)</li></ul><h2 id="反范式设计的概念"><a href="#反范式设计的概念" class="headerlink" title="反范式设计的概念"></a>反范式设计的概念</h2><ul><li>无外键，无连表查询，强调索引,去关联化</li><li>不考虑触发器及其他内部的存储过程</li><li>便于分布式设计，允许适度冗余，为了容量扩展允许适度开销。</li><li>基于业务自由优化，基于i/o 或查询设计，无须遵循范式结构设计。</li></ul><h2 id="冗余结构设计所面临的典型场景"><a href="#冗余结构设计所面临的典型场景" class="headerlink" title="冗余结构设计所面临的典型场景"></a>冗余结构设计所面临的典型场景</h2><ul><li>原有展现程序涉及多个表的查询，希望精简查询程序</li><li>数据表拆分往往基于主键，而原有数据表往往存在非基于主键的关键查询，无法在分表结构中完成。</li><li>存在较多数据统计需求（count, sum等），效率低下。</li></ul><h2 id="冗余造成的问题"><a href="#冗余造成的问题" class="headerlink" title="冗余造成的问题"></a>冗余造成的问题</h2><p>一致性问题–业务层校验</p><h2 id="冗余设计方案"><a href="#冗余设计方案" class="headerlink" title="冗余设计方案"></a>冗余设计方案</h2><h3 id="基于展现的冗余设计"><a href="#基于展现的冗余设计" class="headerlink" title="基于展现的冗余设计"></a>基于展现的冗余设计</h3><p>冗余特征：字段简单，更改度不高<br>为了简化展现程序，在一些数据表中往往存在冗余字段<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：论坛板块的发帖量，回帖量，每日新增数据等。网站每日新增用户数等。参见Discuz论坛系统数据结构，有较多相关结构。参见前文分段积分结构，是典型用于统计的冗余结构。后台可以通过源数据表更新该数字。Redis的Zset类型可以理解为存在一种冗余统计结构。">[13]</span></a></sup></p><h3 id="基于查询的冗余设计"><a href="#基于查询的冗余设计" class="headerlink" title="基于查询的冗余设计"></a>基于查询的冗余设计</h3><ul><li>涉及分表操作后，一些常见的索引查询可能需要跨表，带来不必要的麻烦。确认查询请求远大于写入请求时，应设置便于查询项的冗余表。</li><li>冗余表要点<ul><li>数据一致性，简单说：同增，同删，同更新。</li><li>可以做全冗余，或者只做主键关联的冗余，比如通过用户名查询uid，再基于uid查询源表。</li></ul></li></ul><p>实战示例<sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例1: 用户分表将用户库分成若干数据表;基于用户名的查询和基于uid的查询都是高并发请求。用户分表基于uid分成数据表，同时基于用户名做对应冗余表。如果允许多方式登陆，可以有如下设计方法：`uid,passwd,用户信息等等，主数据表，基于uid分表``ukey,ukeytype,uid 基于ukey分表，便于用户登陆的查询。分解成如下两个SQL:``select uid from ulist_key_13 where ukey=’$username’ and ukeytype=‘login’;``select * from ulist_uid_23 where uid=$uid and passwd=’$passwd’;``ukeytype定义用户的登陆依据，比如用户名，手机号，邮件地址，网站昵称等。 Ukey+ukeytype 必须唯一``此种方式需要登陆密码统一，对于第三方connect接入模式，可以通过引申额外字段完成`">[10]</span></a></sup><sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例2：用户游戏积分排名表结构 uid,gameid,score 参见前文实时积分排行。表内容巨大，需要拆表。需求1：基于游戏id查询积分排行需求2：基于用户id查询游戏积分记录解决方案：建立完全相同的两套表结构，其一以uid为拆表主键，其二以gameid为拆表主键，用户提交积分时，向两个数据结构同时提交。">[11]</span></a></sup><sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例3：全冗余查询结构主信息表仅包括 主键及备注memo字段（text类型），只支持主键查询，可以基于主键拆表。所以需要展现和存储的内容均在memo字段重体现。对每一个查询条件，建立查询冗余表，以查询条件字段为主键，以主信息表主键id 为内容。日常查询只基于查询冗余表，然后通过in的方式从主信息表获得内容。优点是结构扩展非常方便，只需要扩展新的查询信息表即可，核心思路是，只有查询才需要独立的索引结构，展现无需独立字段。缺点是只适合于相对固定的查询架构，对于更加灵活的组合查询束手无策。">[12]</span></a></sup></p><h3 id="基于统计的冗余结构"><a href="#基于统计的冗余结构" class="headerlink" title="基于统计的冗余结构"></a>基于统计的冗余结构</h3><ul><li>为了减少会涉及大规模影响结果集的表数据操作，比如count，sum操作。应将一些统计类数据通过冗余数据结构保存。</li><li>冗余数据结构可能以字段方式存在，也可能以独立数据表结构存在，但是都应能通过源数据表恢复。</li></ul><p>实战示例<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：论坛板块的发帖量，回帖量，每日新增数据等。网站每日新增用户数等。参见Discuz论坛系统数据结构，有较多相关结构。参见前文分段积分结构，是典型用于统计的冗余结构。后台可以通过源数据表更新该数字。Redis的Zset类型可以理解为存在一种冗余统计结构。">[13]</span></a></sup></p><h3 id="基于-io-压力优化的冗余"><a href="#基于-io-压力优化的冗余" class="headerlink" title="基于 io 压力优化的冗余"></a>基于 io 压力优化的冗余</h3><p><strong>现象：</strong></p><p>单次请求多次写入的情况</p><ul><li>请求频次较高，io 压力较大</li><li>存在高频读取请求，数据可靠性要求高</li></ul><p><strong>可用方案:</strong></p><ul><li>数据压缩存储</li><li>写入缓存队列</li><li>通过冗余结构，合并为一次写入<sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="游戏组队，5个武将。（建立临时的武将表，定时更新到主表）">[14]</span></a></sup><sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实时统计">[15]</span></a></sup></li></ul><h3 id="历史数据表"><a href="#历史数据表" class="headerlink" title="历史数据表"></a>历史数据表</h3><p>历史数据表对应于热点数据表，将需求较少又不能丢弃的数据存入，仅在少数情况下被访问。</p><h1 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h1><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul><li>读写分离对负载的减轻远远不如分库分表来的直接。</li><li>写压力会传递给从表，只读从库一样有写压力，一样会产生读写锁！</li><li>一主多从结构下，主库是单点隐患，很难解决（如主库当机，从库可以响应读写，但是无法自动担当主库的分发功能）</li><li>主从延迟也是重大问题。一旦有较大写入问题，如表结构更新，主从会产生巨大延迟。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>部署简单</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul><li>io 压力无法分布，性价比不高（主是多线程写，从是单线程写；分担读压力，不能分担写压力）</li><li>同步延时避免不了</li><li>一主多从，主库单点，很难自动故障转移（一从转主，其他从不能自动关联到这个新主）</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一主一从</p><ul><li>在线热备</li><li>异地分布<ul><li>写分布，读统一。</li><li>仍然困难重重，受限于网络环境问题巨多！</li></ul></li><li>自动障碍转移<ul><li>主崩溃，从自动接管</li></ul></li><li>个人建议，负载均衡主要使用分库方案，主从主要用于热备和障碍转移。</li></ul><h2 id="潜在优化点"><a href="#潜在优化点" class="headerlink" title="潜在优化点"></a>潜在优化点</h2><p>为了减少写压力，有些人建议主不建索引提升i/o性能，从建立索引满足查询要求。个人认为这样维护较为麻烦。而且从本身会继承主的i/o压力，因此优化价值有限。该思路特此分享，不做推荐(caoz观点)。</p><h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><ul><li>设计分布式之前，先优化单机：</li><li>单机读 qps 几千很容易</li><li>单机写 qps 几千很容易</li><li>数据量最少在3000万以上（具体业务具体分析）</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="防止单点隐患"><a href="#防止单点隐患" class="headerlink" title="防止单点隐患"></a>防止单点隐患</h3><p><strong>lvs nginx（轮询，自动切换）</strong></p><ul><li>所谓单点隐患，就是某台设备出现故障，会导致整体系统的不可用，这个设备就是单点隐患。</li><li>理解连带效应，所谓连带效应，就是一种问题会引发另一种故障，举例而言，memcache+mysql是一种常见缓存组合，在前端压力很大时，如果memcache崩溃，理论上数据会通过mysql读取，不存在系统不可用情况，但是mysql无法对抗如此大的压力冲击，会因此连带崩溃。因A系统问题导致B系统崩溃的连带问题，在运维过程中会频繁出现。<sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例： 在mysql连接不及时释放的应用环境里，当网络环境异常（同机房友邻服务器遭受拒绝服务攻击，出口阻塞），网络延迟加剧，空连接数急剧增加，导致数据库连接过多崩溃。">[16]</span></a></sup><sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="实战范例：前端代码 通常我们封装 mysql_connect和memcache_connect，二者的顺序不同，会产生不同的连带效应。如果mysql_connect在前，那么一旦memcache连接阻塞，会连带mysql空连接过多崩溃。">[17]</span></a></sup><ul><li>连带效应是常见的系统崩溃，日常分析崩溃原因的时候需要认真考虑连带效应的影响，头疼医头，脚疼医脚是不行的。</li></ul></li></ul><h3 id="方便系统扩容"><a href="#方便系统扩容" class="headerlink" title="方便系统扩容"></a>方便系统扩容</h3><ul><li>数据容量增加后，要考虑能够将数据分布到不同的服务器上。</li><li>请求压力增加时，要考虑将请求压力分布到不同服务器上。</li><li>扩容设计时需要考虑防止单点隐患。</li></ul><h3 id="安全可控，成本可控"><a href="#安全可控，成本可控" class="headerlink" title="安全可控，成本可控"></a>安全可控，成本可控</h3><ul><li>数据安全，业务安全</li><li>人力资源成本 &gt; 带宽流量成本 &gt; 硬件成本<ul><li>成本与流量的关系曲线应低于线性增长（流量为横轴，成本为纵轴）。</li><li>规模优势</li></ul></li></ul><h2 id="分库-amp-分表"><a href="#分库-amp-分表" class="headerlink" title="分库&amp;分表"></a>分库&amp;分表</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>负载分担较好</li><li>不存在同步延迟</li><li>拆分方法灵活</li></ul><h3 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h3><ul><li>需要有备份和自动故障转移的方案</li><li>需要应用端配合，无法完全满足关联查询的需求</li></ul><h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><ul><li>以分库、分表为负载和数据支撑方案</li><li>以主从结构为热备和故障转移方案</li><li>使用中间件作为分布式数据库的前端（amoeba，要去关联化）</li><li>数据一致性问题解决<ul><li>前端校验</li><li>后端 cron 定时跑数据</li></ul></li></ul><h3 id="基本认识-1"><a href="#基本认识-1" class="headerlink" title="基本认识"></a>基本认识</h3><ul><li>用分库&amp;拆表是解决数据库容量问题的唯一途径。</li><li>分库&amp;拆表也是解决性能压力的最优选择。</li><li>分库 – 不同的数据表放到不同的数据库服务器中（也可能是虚拟服务器）</li><li>拆表 – 一张数据表拆成多张数据表，可能位于同一台服务器，也可能位于多台服务器（含虚拟服务器）。</li></ul><h3 id="去关联化原则"><a href="#去关联化原则" class="headerlink" title="去关联化原则"></a>去关联化原则</h3><ul><li>摘除数据表之间的关联，是分库的基础工作。</li><li>摘除关联的目的是，当数据表分布到不同服务器时，查询请求容易分发和处理。</li><li>学会理解反范式数据结构设计，所谓反范式，第一要点是不用外键，不允许Join操作，不允许任何需要跨越两个表的查询请求。第二要点是适度冗余减少查询请求<sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="比如说，信息表，fromuid, touid, message字段外，还需要一个fromuname字段记录用户名，这样查询者通过touid查询后，能够立即得到发信人的用户名，而无需进行另一个数据表的查询。">[18]</span></a></sup></li><li>去关联化处理会带来额外的考虑，比如说，某一个数据表内容的修改，对另一个数据表的影响。这一点需要在程序或其他途径去考虑。</li></ul><h3 id="分库方案"><a href="#分库方案" class="headerlink" title="分库方案"></a>分库方案</h3><h4 id="安全性拆分"><a href="#安全性拆分" class="headerlink" title="安全性拆分"></a>安全性拆分</h4><p>运维优化，易于管理</p><ul><li>将高安全性数据与低安全性数据分库，这样的好处第一是便于维护，第二是高安全性数据的数据库参数配置可以以安全优先，而低安全性数据的参数配置以性能优先。参见运维优化相关部分。</li><li>安全性开启参数：sync_binlog，innodb_flush_log_at_trx_commit = 2(丢失最后1s 数据);开启后性能下降10~100倍</li></ul><h4 id="基于业务逻辑拆分"><a href="#基于业务逻辑拆分" class="headerlink" title="基于业务逻辑拆分"></a>基于业务逻辑拆分</h4><p>易于管理，对应用端友好，负载不能均分</p><ul><li>根据数据表的内容构成，业务逻辑拆分，便于日常维护和前端调用。</li><li>基于业务逻辑拆分，可以减少前端应用请求发送到不同数据库服务器的频次，从而减少链接开销。</li><li>基于业务逻辑拆分，可保留部分数据关联，前端web工程师可在限度范围内执行关联查询。</li></ul><h4 id="基于负载压力拆分"><a href="#基于负载压力拆分" class="headerlink" title="基于负载压力拆分"></a>基于负载压力拆分</h4><p>负载相对可以均摊；管理不方便</p><ul><li>基于负载压力对数据结构拆分，便于直接将负载分担给不同的服务器。</li><li>基于负载压力拆分，可能拆分后的数据库包含不同业务类型的数据表，日常维护会有一定的烦恼。</li></ul><h4 id="混合拆分组合"><a href="#混合拆分组合" class="headerlink" title="混合拆分组合"></a>混合拆分组合</h4><ul><li>基于安全与业务拆分为数据库实例，但是可以使用不同端口放在同一个服务器上。</li><li>基于负载可以拆分为更多数据库实例分布在不同数据库上</li></ul><p>例如:</p><ul><li>基于安全拆分出A数据库实例，</li><li>基于业务拆分出B,C数据库实例，</li><li>C数据库存在较高负载，基于负载拆分为C1,C2,C3,C4等 实例。</li><li>数据库服务器完全可以做到 A+B+C1为一台，C2,C3,C4各单独一台。</li></ul><h3 id="分表方案"><a href="#分表方案" class="headerlink" title="分表方案"></a>分表方案</h3><p>数据量过大或者访问压力过大的数据表需要切分</p><h4 id="纵向分表（常见为忙闲分表）"><a href="#纵向分表（常见为忙闲分表）" class="headerlink" title="纵向分表（常见为忙闲分表）"></a>纵向分表（常见为忙闲分表）</h4><ul><li>单数据表字段过多，可将频繁更新的整数数据与非频繁更新的字符串数据切分<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="范例: user表 ，个人简介，地址，QQ号，联系方式，头像 这些字段为字符串类型，更新请求少； 最后登录时间，在线时常，访问次数，信件数这些字段为整数型字段，更新频繁，可以将后面这些更新频繁的字段独立拆出一张数据表，表内容变少，索引结构变少，读写请求变快。">[19]</span></a></sup></li><li>过于频繁的，使用 nosql（memcached，redis 等）</li></ul><h4 id="横向切表"><a href="#横向切表" class="headerlink" title="横向切表"></a>横向切表</h4><ul><li>等分切表，如哈希切表或其他基于对某数字取余的切表。等分切表的优点是负载均分；缺点是当容量继续增加时无法方便的扩容，需要重新进行数据的切分或转表。而且一些关键主键不易处理。（只能基于差存条件进行拆分，否则没法查询）</li><li>递增切表，比如每1kw用户开一个新表，优点是可以适应数据的自增趋势；缺点是往往新数据负载高（最新的表），压力分配不平均。</li><li>日期切表，适用于日志记录式数据，优缺点等同于递增切表。</li><li>个人倾向于递增切表，具体根据应用场景决定。</li></ul><h4 id="热点数据分表"><a href="#热点数据分表" class="headerlink" title="热点数据分表"></a>热点数据分表</h4><p>将数据量较大的数据表中将读写频繁的数据抽取出来，形成热点数据表。通常一个庞大数据表经常被读写的内容往往具有一定的集中性，如果这些集中数据单独处理，就会极大减少整体系统的负载。</p><p><strong>热点数据表与旧有数据关系:</strong></p><ul><li>可以是一张冗余表，即该表数据丢失不会妨碍使用，因源数据仍存在于旧有结构中。优点是安全性高，维护方便，缺点是写压力不能分担，仍需要同步写回原系统。</li><li>可以是非冗余表，即热点数据的内容原有结构不再保存，优点是读写效率全部优化；缺点是当热点数据发生变化时，维护量较大。</li><li>具体方案选择需要根据读写比例决定，在读频率远高于写频率情况下，优先考虑冗余表方案。</li></ul><p><strong>数据存储：</strong><br>热点数据表可以用单独的优化的硬件存储，比如昂贵的闪存卡或大内存系统。</p><p><strong>热点数据表的重要指标:</strong></p><ul><li>热点数据的定义需要根据业务模式自行制定策略，常见策略为，按照最新的操作时间；按照内容丰富度等等。</li><li>数据规模，比如从1000万条数据，抽取出100万条热点数据。</li><li>热点命中率，比如查询10次，多少次命中在热点数据内。</li><li>理论上，数据规模越小，热点命中率越高，说明效果越好。需要根据业务自行评估。</li></ul><p><strong>热点数据表的动态维护:</strong></p><ul><li>加载热点数据方案选择<ul><li>定时从旧有数据结构中按照新的策略获取</li><li>在从旧有数据结构读取时动态加载到热点数据</li></ul></li><li>剔除热点数据方案选择<ul><li>基于特定策略，定时将热点数据中访问频次较少的数据剔除</li><li>如热点数据是冗余表，则直接删除即可，如不是冗余表，需要回写给旧有数据结构。</li></ul></li></ul><p>通常，热点数据往往是基于缓存或者key-value方案冗余存储，所以这里提到的热点数据表，其实更多是理解思路，用到的场合可能并不多。（适合组合条件场景，数据规模中等，像淘宝的数据量就需要第三方搜索引擎）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://imysql.com/2014/09/28/mysql-optimization-case-blob-stored-in-innodb-optimization.shtml" rel="external nofollow noopener noreferrer" target="_blank">[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率</a></li><li>《Mysql 性能优化教程-曹政》</li></ul><!--以下是脚注--><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实景分析： 前端请求先连接缓存，缓存未命中连接数据库，进行查询，未命中状态比单纯连接数据库查询多了一次连接和查询的操作；如果缓存命中率很低，则这个额外的操作非但不能提高查询效率，反而为系统带来了额外的负载和复杂性，得不偿失。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例:<br><code>$var=Memcache_get($memcon,”var”);$var++;memcache_set($memcon,”var”,$var);</code><br>这样一个脚本，使用apache ab去跑，100个并发，跑10000次，然后输出缓存存取的数据，很遗憾，并不是1000，而是5000多，6000多这样的数字，中间的数字全在 get &amp; set的过程中丢掉了。原因：读写间隔中其他并发写入，导致数据丢失。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例2:<br>用memcache_increment来做这个操作，同样跑测试会得到完整的10000，一条数据不会丢。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>某论坛热门贴，前端不断有views=views+1数据更新请求。<br>缓存实时更新该状态<br>后台任务对数据库做异步更新时，假设执行周期是5分钟，那么五分钟可能会接收到这样的请求多达数十次乃至数百次，合并更新后只执行一次update即可。<br>类似操作还包括游戏打怪，生命和经验的变化；个人主页访问次数的变化等。<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">例如：<code>ALTER TABLE t1 ADD INDEX(user(20))</code><br>前缀索引的长度可以基于对该字段的统计得出，一般略大于平均长度一点就可以了。<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>用户在线上时，后台异步更新用户状态。管理员后台屏蔽用户是直接更新数据库。结果管理员屏蔽某用户操作完成后，因该用户在线有操作，后台异步更新程序再次基于缓存更新用户状态，用户状态被复活，屏蔽失效。<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例：支付信息，道具的购买与获得，一旦丢失会对用户造成极大的伤害。而经验值，访问数字，如果只丢失了很少时间的内容，用户还是可以容忍的。<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例：如果使用 <code>Views=Views+…</code>的操作，一旦出现数据格式错误，从binlog中反推是可以进行数据还原，但是如果使用Views=特定值的操作，一旦缓存中数据有错误，则直接被赋予了一个错误数据，无法回溯！<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例1: 用户分表<br>将用户库分成若干数据表;基于用户名的查询和基于uid的查询都是高并发请求。<br>用户分表基于uid分成数据表，同时基于用户名做对应冗余表。<br>如果允许多方式登陆，可以有如下设计方法：<br><code>uid,passwd,用户信息等等，主数据表，基于uid分表</code><br><code>ukey,ukeytype,uid 基于ukey分表，便于用户登陆的查询。分解成如下两个SQL:</code><br><code>select uid from ulist_key_13 where ukey=’$username’ and ukeytype=‘login’;</code><br><code>select <em> from ulist_uid_23 where uid=$uid and passwd=’$passwd’;</em></code><br><code>ukeytype定义用户的登陆依据，比如用户名，手机号，邮件地址，网站昵称等。 Ukey+ukeytype 必须唯一</code><br><code>此种方式需要登陆密码统一，对于第三方connect接入模式，可以通过引申额外字段完成</code><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例2：用户游戏积分排名<br>表结构 uid,gameid,score 参见前文实时积分排行。表内容巨大，需要拆表。<br>需求1：基于游戏id查询积分排行<br>需求2：基于用户id查询游戏积分记录<br>解决方案：建立完全相同的两套表结构，其一以uid为拆表主键，其二以gameid为拆表主键，用户提交积分时，向两个数据结构同时提交。<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例3：全冗余查询结构<br>主信息表仅包括 主键及备注memo字段（text类型），只支持主键查询，可以基于主键拆表。所以需要展现和存储的内容均在memo字段重体现。<br>对每一个查询条件，建立查询冗余表，以查询条件字段为主键，以主信息表主键id 为内容。<br>日常查询只基于查询冗余表，然后通过in的方式从主信息表获得内容。<br>优点是结构扩展非常方便，只需要扩展新的查询信息表即可，核心思路是，只有查询才需要独立的索引结构，展现无需独立字段。<br>缺点是只适合于相对固定的查询架构，对于更加灵活的组合查询束手无策。<a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">举例，信息表 message，存在字段 fromuid,touid,msg,sendtime 四个字段，其中 touid+sendtime是复合索引。存在查询为 select  from message where touid=$uid order by sendtime desc limit 0,30;<br>展示程序需要显示发送者姓名，此时通常会在message表中增加字段fromusername，甚至有的会增加fromusersex，从而无需连表查询直接输出信息的发送者姓名和性别。这就是一种简单的，为了避免连表查询而使用的冗余字段设计。<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：<br>论坛板块的发帖量，回帖量，每日新增数据等。<br>网站每日新增用户数等。<br>参见Discuz论坛系统数据结构，有较多相关结构。<br>参见前文分段积分结构，是典型用于统计的冗余结构。<br>后台可以通过源数据表更新该数字。<br>Redis的Zset类型可以理解为存在一种冗余统计结构。<a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">游戏组队，5个武将。（建立临时的武将表，定时更新到主表）<a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实时统计<a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例： 在mysql连接不及时释放的应用环境里，当网络环境异常（同机房友邻服务器遭受拒绝服务攻击，出口阻塞），网络延迟加剧，空连接数急剧增加，导致数据库连接过多崩溃。<a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">实战范例：前端代码 通常我们封装 mysql_connect和memcache_connect，二者的顺序不同，会产生不同的连带效应。如果mysql_connect在前，那么一旦memcache连接阻塞，会连带mysql空连接过多崩溃。<a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">比如说，信息表，fromuid, touid, message字段外，还需要一个fromuname字段记录用户名，这样查询者通过touid查询后，能够立即得到发信人的用户名，而无需进行另一个数据表的查询。<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">范例: user表 ，个人简介，地址，QQ号，联系方式，头像 这些字段为字符串类型，更新请求少； 最后登录时间，在线时常，访问次数，信件数这些字段为整数型字段，更新频繁，可以将后面这些更新频繁的字段独立拆出一张数据表，表内容变少，索引结构变少，读写请求变快。<a href="#fnref:19" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;数据表设计&quot;&gt;&lt;a href=&quot;#数据表设计&quot; class=&quot;he
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/数据库/Mysql/基础知识/</id>
    <published>2017-11-16T15:24:00.000Z</published>
    <updated>2017-12-03T16:04:44.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="Mysql-常用数据结构"><a href="#Mysql-常用数据结构" class="headerlink" title="Mysql 常用数据结构"></a>Mysql 常用数据结构</h2><ul><li>B+ Tree</li><li>Hash index</li></ul><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><h3 id="b-tree"><a href="#b-tree" class="headerlink" title="b+tree"></a>b+tree</h3><p><img src="/images/2017/11/16/b-tree.png" alt="b+tree"><br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。</p><p>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。</p><p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大</p><h3 id="Hash-index"><a href="#Hash-index" class="headerlink" title="Hash index"></a>Hash index</h3><p><img src="/images/2017/11/16/hash-index.png" alt="hash-index"><br>简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</p><p>哈希索引只能使用 in ，=，!=</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>如果是等值查询，那么哈希索引明显有绝对优势</li><li>如果是范围查询检索，这时候哈希索引就毫无用武之地了</li><li>哈希索引也没办法利用索引完成排序</li><li>哈希索引也不支持多列联合索引的最左匹配规则</li><li>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="为什么使用索引能提高效率"><a href="#为什么使用索引能提高效率" class="headerlink" title="为什么使用索引能提高效率"></a>为什么使用索引能提高效率</h3><p>关系型数据库的数据索引（Btree及常见索引结构）的存储是<strong>有序</strong>的（在有序的情况下，通过索引查询一个数据是无需遍历索引记录的）。</p><ul><li>「默认 b+tree索引」查询效率趋近于二分法，趋近于 log2(N)。</li><li>「hash 索引」查询效率是寻址操作，趋近于1次查询，比有序索引查询效率更高</li></ul><h3 id="如何理解数据索引的结构"><a href="#如何理解数据索引的结构" class="headerlink" title="如何理解数据索引的结构"></a>如何理解数据索引的结构</h3><p><strong>从结构</strong></p><ul><li>数据索引通常默认采用b+tree索引，（内存表使用了hash索引）。</li><li>单向 <strong>有序</strong> 排序序列是查找效率最高的（二分查找），使用树形索引的目的是为了达到快速的更新和增删操作。</li><li>在极端情况下（比如数据查询需求量非常大，而数据更新需求极少，实时性要求不高，数据规模有限），直接使用 <strong>单一排序序列</strong>，折半查找速度最快。</li></ul><p><strong>从优化</strong></p><ul><li>在进行索引分析和SQL优化时，可以将数据索引字段想象为单一有序序列，并以此作为分析的基础。</li><li>涉及到复合索引情况，复合索引按照索引顺序拼凑成一个字段，想象为单一有序序列，并以此作为分析的基础。</li></ul><p><strong>从查询优化器</strong></p><ul><li>一条数据查询只能使用一个索引，索引可以是多个字段合并的复合索引。但是一条数据查询不能使用多个索引。</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ol><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" rel="external nofollow noopener noreferrer" target="_blank">MySQL索引背后的数据结构及算法原理</a></li><li><a href="http://blog.codinglabs.org/articles/index-condition-pushdown.html" rel="external nofollow noopener noreferrer" target="_blank">MySQL索引与Index Condition Pushdown</a></li><li><a href="http://imysql.com/2015/10/29/mysql-faq-clustered-index.shtml" rel="external nofollow noopener noreferrer" target="_blank">FAQ系列 | MySQL索引之聚集索引</a></li><li><a href="http://imysql.com/2015/11/11/mysql-faq-primary-key-vs-secondary-key.shtml" rel="external nofollow noopener noreferrer" target="_blank">FAQ系列 | MySQL索引之主键索引</a></li></ol><h1 id="Mysql加密"><a href="#Mysql加密" class="headerlink" title="Mysql加密"></a>Mysql加密</h1><h2 id="mysql用户名密码公式-5-7以前-："><a href="#mysql用户名密码公式-5-7以前-：" class="headerlink" title="mysql用户名密码公式(5.7以前)："></a>mysql用户名密码公式(5.7以前)：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat('*',sha1(unhex(sha1('mypassword')))) //等于 password('mypassword')</span><br></pre></td></tr></table></figure><h2 id="记录密码方式"><a href="#记录密码方式" class="headerlink" title="记录密码方式"></a>记录密码方式</h2><ul><li>binlog 记录密码方式</li><li>5.6以前 binlog 会打印明文密码</li><li>5.6以后 以密文方式记录 binlog 的命令</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> … <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> …</span><br><span class="line"><span class="keyword">GRANT</span> … <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> …</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> …</span><br><span class="line"><span class="keyword">SLAVE</span> <span class="keyword">START</span> … <span class="keyword">PASSWORD</span> = … (<span class="keyword">as</span> <span class="keyword">of</span> <span class="number">5.6</span><span class="number">.4</span>)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SERVER</span> … OPTIONS(… <span class="keyword">PASSWORD</span> …) (<span class="keyword">as</span> <span class="keyword">of</span> <span class="number">5.6</span><span class="number">.9</span>)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SERVER</span> … OPTIONS(… <span class="keyword">PASSWORD</span> …) (<span class="keyword">as</span> <span class="keyword">of</span> <span class="number">5.6</span><span class="number">.9</span>)</span><br><span class="line">//<span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> 不在此范畴中，在启动主从时会有 <span class="keyword">warning</span> 提示</span><br></pre></td></tr></table></figure><h1 id="影响结果集"><a href="#影响结果集" class="headerlink" title="影响结果集"></a>影响结果集</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> [<span class="keyword">sql</span>]</span><br></pre></td></tr></table></figure><h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><p>查询条件与索引的关系决定影响结果集。</p><h2 id="影响结果集是什么？"><a href="#影响结果集是什么？" class="headerlink" title="影响结果集是什么？"></a>影响结果集是什么？</h2><p>影响结果集不是输出结果数，不是查询返回的记录数，而是<strong>索引所扫描的结果数</strong>。</p><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><ul><li>影响结果集越趋近于<strong>实际输出</strong>或操作的<strong>目标结果集</strong>，索引效率越高。</li><li><strong>影响结果集与查询开销的关系可以理解为线性相关</strong>。减少一半影响结果集，即可提升一倍查询效率！当一条搜索query可以符合多个索引时，选择影响结果集最少的索引。</li></ul><h2 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h2><p><strong>SQL的优化，核心就是对结果集的优化</strong>，认识索引是增强对结果集的判断，基于索引的认识，可以在编写SQL的时候，对该SQL可能的影响结果集有预判，并做出适当的优化和调整。</p><h2 id="Limit-的影响"><a href="#Limit-的影响" class="headerlink" title="Limit 的影响"></a>Limit 的影响</h2><ul><li>如果<strong>索引与查询条件和排序条件完全命中</strong>，影响结果集就是limit后面的数字（$start + $end），比如 limit 200,30 影响结果集是230. 而不是30.</li><li><p>如果索引只命中部分查询条件，甚至无命中条件，在<strong>无排序条件</strong>情况下，会在索引命中的结果集 中遍历到满足所有其他条件为止。</p><blockquote><p>比如 select * from user limit 10; 虽然没用到索引，但是因为不涉及二次筛选和排序，系统直接返回前10条结果，影响结果集依然只有10条，就不存在效率影响。</p></blockquote></li><li><p>如果搜索所包含的<strong>排序条件没有被索引命中</strong>，则系统会遍历所有索引命中的结果，并且排序。</p><blockquote><p>例如 Select <em> from user order by timeline desc limit 10; 如果timeline不是索引，影响结果集是全表，就存在需要全表数据排序，这个效率影响就巨大。再比如 Select </em> from user where area=’厦门’ order by timeline desc limit 10; 如果area是索引，而area+timeline未建立索引，则影响结果集是所有命中 area=’厦门’的用户，然后在影响结果集内排序。</p></blockquote></li></ul><h1 id="Cpu-内存-磁盘利用特点"><a href="#Cpu-内存-磁盘利用特点" class="headerlink" title="Cpu/内存/磁盘利用特点"></a>Cpu/内存/磁盘利用特点</h1><h2 id="Cpu利用特点"><a href="#Cpu利用特点" class="headerlink" title="Cpu利用特点"></a>Cpu利用特点</h2><p>每个连接对应一个线程，每个并发query只能使用到一个核</p><ul><li>&lt;5.1，多核心支持较弱</li><li>5.1，可利用4个核</li><li>5.5，可利用24个核</li><li>5.6，可利用64个核</li></ul><h2 id="内存利用特点"><a href="#内存利用特点" class="headerlink" title="内存利用特点"></a>内存利用特点</h2><ul><li><p>类似ORACLE的SGA(全局)、PGA（会话）模式，注意PGA不宜分配过大</p><blockquote><p>SGA：System Global Area是Oracle Instance的基本组成部分，在实例启动时分配;系统全局域SGA主要由三部分构成：共享池、数据缓冲区、日志缓冲区。<br>PGA：Process Global Area是为每个连接到Oracle database的用户进程保留的内存<br>Mysql 中会话内存分配不要太大，否则会造成 OOM（out of memory）</p></blockquote></li><li><p>内存管理简单、有效。<strong>在高TPS、高并发环境下，可增加物理内存以减少物理IO，提高并发性能</strong></p></li><li><p>Mysql 锁并发竞争比较严重，MariaDB、Percona进行优化</p><blockquote><p>2014年建议使用 Percona &gt; MariaDB &gt; Mysql</p></blockquote></li><li><p>有类似ORACLE library cache的query cache，但效果不佳，建议关闭</p><blockquote><p>Qcache有个全局锁,有数据变更，则会更新 Qcache；<br>Dml 不频繁时（只读），Qcache 还是有用的–没有只读的场景，从服务也要写</p></blockquote></li><li><p>执行计划没有缓存，每次都需要解析 SQL</p></li><li>通常内存建议按热点数据总量的15%-20%来规划，专用单实例则可以分配物理内存的50~70%左右</li></ul><h2 id="磁盘利用特点"><a href="#磁盘利用特点" class="headerlink" title="磁盘利用特点"></a>磁盘利用特点</h2><ul><li>binlog、redo log、undo log主要顺序IO</li><li>datafile是主要是 「<strong>随机IO</strong>」 和顺序IO也有</li><li>OLTP业务（数据查询）以随机IO为主，建议加大内存，尽量合并随机IO为顺序IO<blockquote><p>通过 innodb buffer 进行合并</p></blockquote></li><li>OLAP业务（数据分析）以顺序IO为主，加大内存的同时增加硬盘数量提高顺序IO性能</li><li><p>MyISAM是堆组织表（HOT），InnoDB是索引组织表（IOT）</p><blockquote><p>MYISAM ：新写的数据放入堆的最后<br>Innodb ：B+tree 的索引结构</p></blockquote></li><li><p>InnoDB相比MyISAM更消耗磁盘空间</p><blockquote><p>Innodb 的占用空间通常比 MyISAM 多1.5~2倍<br>innodb 保存更多的数据，比如：事务信息</p></blockquote></li></ul><h1 id="数据引擎"><a href="#数据引擎" class="headerlink" title="数据引擎"></a>数据引擎</h1><h2 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h2><p>速度快，响应快。表级锁是致命问题</p><ul><li>表级锁 – 读和写是串行的</li><li>不支持事务</li><li>内存只缓存索引</li></ul><h2 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h2><p>目前主流存储引擎</p><ul><li>行级锁 – 不同数据读写可并行处理</li><li>支持事务</li><li>内存缓存数据和索引</li><li>Crash Recovery – 故障自动修复，修复相比MyISAM速度更快</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>使用 hash 索引</p><ul><li>频繁更新和海量读取情况下仍会存在锁定状况</li><li>不支持范围查询及排序，只能=,!=,in</li></ul><h1 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h1><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ul><li>减少物理I/O，让MySQL闲下来 (减少负载（前端+各级cache）)</li><li>转变随机I/O为顺序I/O （本地写队列，最后合并写）</li><li>减小活跃数据 (冷热数据分离)</li><li>分库分表 (垂直、水平拆分、分布式集群)</li><li>读写分离 (从只读，加大 buffer使读的性能更好些)</li><li>OLTP、OLAP分离</li></ul><h2 id="禁止"><a href="#禁止" class="headerlink" title="禁止"></a>禁止</h2><ul><li>禁止 Mysql 做运算</li><li>快速更新大数据表，禁止直接运行count(*)统计</li></ul><h2 id="数据量控制"><a href="#数据量控制" class="headerlink" title="数据量控制"></a>数据量控制</h2><ul><li>单表行记录数控制在1000万以内，行平均长度控制在16KB以内，单表20GB以内</li><li>单实例下数据表数量不超过2000个， 单库下数据表数量不超过500个</li></ul><h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><ul><li>读写分离，主库只写和少量实时读取请求，统计在从库上执行</li><li>采用队列方式合并多次写请求， 持续写入， 避免瞬间压力</li></ul><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul><li>「垂直拆分」超长text/blob进行垂直拆分，并先行压缩</li><li>「水平拆分」冷热数据进行水平拆分，LRU原则</li><li>压力分散，在线表和归档表（日志表）分开存储</li></ul><h2 id="SQL规范"><a href="#SQL规范" class="headerlink" title="SQL规范"></a>SQL规范</h2><ul><li>注意引号问题会导致类型转换（where id = ‘1234’）</li><li>过滤用户提交SQL，防止注入</li><li>杜绝 like ‘%xxx%’，不用/少用 like ‘xxx%’</li><li>不用/少用子查询，改造成连接（JOIN）</li><li>不用/少用FOR UPDATE、LOCK IN SHARE MODE，防止锁范围扩大化</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://imysql.com/2016/01/06/mysql-faq-different-between-btree-and-hash-index.shtml" rel="external nofollow noopener noreferrer" target="_blank">FAQ系列 | B+树索引和哈希索引的区别</a></li></ul><!--以下是脚注-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="http://yoursite.com/GIT/git/"/>
    <id>http://yoursite.com/GIT/git/</id>
    <published>2017-11-16T13:21:00.000Z</published>
    <updated>2017-12-03T16:04:44.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h1><p><img src="/images/2017/11/16/git.png" alt="git"></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h1 id="GIT-配置"><a href="#GIT-配置" class="headerlink" title="GIT 配置"></a>GIT 配置</h1><p>Git的设置文件为.git/config，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><ul><li>显示当前的Git配置:<br><code>git config --list</code></li><li>编辑Git配置文件:<br><code>git config -e [--global]</code></li><li>设置提交代码时的用户信息<br><code>git config [--global] user.name [name]</code><br><code>git config [--global] user.email [email address]</code></li></ul><h1 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h1><ul><li>当前目录<br><em>空目录/拷贝的 git 目录</em><br><code>git init</code></li><li>创建目录<br><code>git init [project-name]</code></li><li>下载一个项目(包含历史)<br><code>git clone [url]</code></li><li>本地初始化远端<br><code>git remote add origin [http://xxx.git]</code><br><code>git push -u origin master</code></li></ul><h1 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h1><ul><li>添加指定文件到暂存区<br><code>git add [file1] [file2] ...</code></li><li>添加指定目录到暂存区，包括子目录<br><code>git add [dir]</code></li><li>添加文件的部分到暂存区<br><code>git add -e [file]</code></li><li>删除工作区文件，并且将这次删除放入暂存区<br><code>git rm [file1] [file2] ...</code></li><li>停止追踪指定文件，但该文件会保留在工作区<br><code>git rm --cached [file]</code></li><li>改名文件，并且将这个改名放入暂存区<br><code>git mv [file-original] [file-renamed]</code></li></ul><h1 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h1><ul><li>提交暂存区到仓库区<br><code>git commit -m [message]</code></li><li>提交暂存区的指定文件到仓库区<br><code>git commit [file1] [file2] ... -m [message]</code></li><li>提交工作区自上次commit之后的变化，直接到仓库区<br><code>git commit -a</code></li><li>提交时显示所有diff信息<br><code>git commit -v</code></li><li>使用一次新的commit，替代上一次提交<br><em>如果代码没有任何新变化，则用来改写上一次commit的提交信息</em><br><code>git commit --amend -m [message]</code></li><li>重做上一次commit，并包括指定文件的新变化<br><code>git commit --amend ...</code></li><li>修改提交信息<br><code>git rebase HEAD^^ -i</code><br><code>//-i 是交互模式</code><br><code>//reword 修改注释信息</code><br><code>//squash 与之前的注释合并</code></li></ul><h1 id="暂存数据（Stage）"><a href="#暂存数据（Stage）" class="headerlink" title="暂存数据（Stage）"></a>暂存数据（Stage）</h1><ul><li>把文件写入 Stage<br><code>git stash save [file]</code></li><li>查看 Stage 列表<br><code>git stash list</code></li><li>应用最后一个 Stage<br><code>git stash pop</code></li><li>应用指定的 Stage<br><code>git stash apply [stash@{1}]</code></li></ul><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><ul><li>下载远程仓库的所有变动<br><code>git fetch [remote]</code></li><li>下载远程仓库的所有tag<br><code>git fetch —tags</code></li><li>只下载远程仓库的分支<br><code>git fetch [remote] &lt;本地master&gt;:&lt;新建分支名&gt;</code></li><li>显示所有远程仓库<br><code>git remote -v</code></li><li>显示某个远程仓库的信息<br><code>git remote show [remote]</code></li><li>增加一个新的远程仓库，并命名<br><code>git remote add [shortname] [url]</code></li><li>取回远程仓库的变化，并与本地分支合并<br><code>git pull [remote] [branch]</code></li><li>上传本地指定分支到远程仓库<br><code>git push [remote] [branch]</code></li><li>强行推送当前分支到远程仓库，即使有冲突<br><code>git push [remote] --force</code></li><li>推送所有分支到远程仓库<br><code>git push [remote] --all</code></li><li>在已有项目中添加子项目<br><code>git submodule add [remote] [dir]</code></li></ul><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><ul><li>恢复暂存区的指定文件到工作区<br><code>git checkout [file]</code></li><li>恢复某个commit的指定文件到工作区<br><code>git checkout [commit] [file]</code></li><li>恢复上一个commit的所有文件到工作区<br><code>git checkout .</code></li><li>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br><code>git reset [file]</code></li><li>重置暂存区与工作区，与上一次commit保持一致<br><code>git reset --hard</code></li><li>重置暂存区，保留已修改<br><code>git reset —soft</code></li><li>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset [commit]</code></li><li>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br><code>git reset --hard [commit]</code></li><li>重置当前HEAD为指定commit，但保持暂存区和工作区不变<br><code>git reset --keep [commit]</code></li><li>新建一个commit，用来撤销指定commit<br><code>#_后者的所有变化都将被前者抵消，并且应用到当前分支_</code><br><code>git revert [commit]</code></li></ul><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul><li>列出所有本地分支<br><code>git branch</code></li><li>列出所有远程分支<br><code>git branch -r</code></li><li>列出所有本地分支和远程分支<br><code>git branch -a</code></li><li>新建一个分支，但依然停留在当前分支<br><code>git branch [branch-name]</code></li><li>新建一个分支，并切换到该分支<br><code>git checkout -b [branch]</code></li><li>新建一个分支，指向指定commit<br><code>git branch [branch] [commit]</code></li><li>新建一个分支，与指定的远程分支建立追踪关系<br><code>git branch --track [branch] [remote-branch]</code></li><li>切换到指定分支，并更新工作区<br><code>git checkout [branch-name]</code></li><li>建立追踪关系，在现有分支与指定的远程分支之间<br><code>git branch --set-upstream [branch] [remote-branch]</code></li><li>合并指定分支到当前分支<br><code>git merge [branch]</code></li><li>保留 commit 信息（即使在 fast-forward模式）<br><code>git merge –no-ff [branch]</code></li><li>合并多个commit为一次提交<br><code>git merge —squash [branch]</code></li><li>选择一个commit，合并进当前分支<br><code>git cherry-pick [commit]</code></li><li>删除分支<br><code>git branch -d [branch-name]</code></li><li>删除远程分支<br><code>git push origin --delete</code><br><code>git branch -dr</code></li><li>衍合分支到主干<br><code>git checkout [branch]</code><br><code>git rebase [master]</code></li><li>合并分支到主干<br><code>git checkout [master]</code><br><code>git merge [branch]</code></li></ul><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p><strong>若 tag 和 branch 重名，操作时可指定，比如：tags/v2</strong></p><ul><li>列出所有tag<br><code>git tag</code></li><li>新建一个tag在当前commit<br><code>git tag [tag]</code></li><li>新建一个tag在指定commit<br><code>git tag [tag] [commit]</code></li><li>查看tag信息<br><code>git show [tag]</code></li><li>提交指定tag<br><code>git push [remote] [tag]</code></li><li>提交所有tag<br><code>git push [remote] --tags</code></li><li>新建一个分支，指向某个tag<br><code>git checkout -b [branch] [tag]</code></li></ul><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><p><strong>多个条件默认是or 关系，使用 –all-match 变为 AND 关系</strong></p><ul><li>显示有变更的文件<br><code>git status</code></li><li>显示当前分支的版本历史<br><code>git log</code></li><li>显示commit历史，以及每次commit发生变更的文件<br><code>git log --stat</code></li><li>显示某个文件的版本历史，包括文件改名<br><code>git log --follow [file]</code><br><code>git whatchanged [file]</code></li><li>显示指定文件相关的每一次diff<br><code>git log -p [file]</code></li><li>显示两个 tag 之间的版本历史<br><code>git log [tag1]…[tag2]</code></li><li>显示指定时间范围的版本历史<br><code>git log --since=2.months.ago --until=1.day.ago</code></li><li>显示在分支2而不在分支1上的版本历史（branch2没有提交的历史）<br><code>git log [old_branch1]…[new_branch2]</code></li><li>搜索特定提交者<br><code>git log —author=[name]</code></li><li>搜索历史信息<br><code>git log —grep=&#39;search message&#39;</code></li><li>显示指定文件是什么人在什么时间修改过<br><code>git blame [file]</code></li><li>显示暂存区和工作区的差异<br><code>git diff</code></li><li>显示暂存区和上一个commit的差异<br><code>git diff --cached</code></li><li>显示工作区与当前分支最新commit之间的差异<br><code>git diff HEAD</code></li><li>显示两次提交之间的差异<br><code>git diff [first-branch]...[second-branch]</code></li><li>显示某次提交的元数据和内容变化<br><code>git show [commit]</code></li><li>显示某次提交发生变化的文件<br><code>git show --name-only [commit]</code></li><li>显示某次提交时，某个文件的内容<br><code>git show [commit]:[filename]</code></li><li>显示分支发生的变化<br><code>git show [branch]</code></li><li>显示最后一次提交发生的变化<br><code>git show HEAD</code></li><li>显示当前分支的最近几次提交<br><code>git reflog</code></li><li>查找信息<br><code>git grep [pattern] [search_scope]</code></li><li>查看分支间的关系<br><code>git show-branch</code><br><code>//(加号)表示所在分支 包含 此行所标识的 commit</code><br><code>//(空格)表示所在分支 不包含 此行所标识的 commit</code><br><code>//(减号)表示所在分支是经过 merge 得到的,而所在行的内容即是 merge 的基本信息</code><br><code>//(星号)表示如果需要在某列标识+(加号),且此列为当前分支所在列,那么则将+(加号)转变为*(星号)</code></li><li>显示两个分支的差异<br><code>git whatchanged -p [branch1]…[branch2]</code></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>仓库移了位置<br><code>git remote set-url origin &lt;new repo addr&gt;</code></li><li>生成一个可供发布的压缩包<br><code>git archive</code></li><li>压缩信息，清理垃圾<br><code>git gc</code></li><li>一致性检查<br><code>git fsck</code></li><li>查看对象数据库<br><code>#四种对象类型：blob、commit、tag、tree</code><br><code>#commit 指向 tree</code><br><code>#tree 显示一个目录的状态，指向 tree 或者 blob</code></li><li>显示对象类型<br><code>git cat-file -t [ID]</code></li><li>显示对象信息<br><code>git cat-file [type] [ID]</code></li><li>显示 tree 信息<br><code>git ls-tree [ID]</code></li></ul><h1 id="忽略本地修改"><a href="#忽略本地修改" class="headerlink" title="忽略本地修改"></a>忽略本地修改</h1><ul><li>忽略本地修改（仓库存在）<br><code>git update-index --assume-unchanged [file]</code></li><li>删除忽略的本地修改<br><code>git update-index --no-assume-unchanged [file]</code></li></ul><h1 id="意外情况"><a href="#意外情况" class="headerlink" title="意外情况"></a>意外情况</h1><ul><li>找回删除的文件<br><code>git reflog / git fsck --lost-found</code><br><code>git checkout [hash值]</code></li><li>从本地分支生成 patch（用于 email 提交）<br><code>git format-patch origin</code></li><li>与主干同步<br><code>git fetch origin</code><br><code>git rebase origin/master</code></li><li>提交到了错误的分支<br><code>git branch experimental //创建一个指向当前master的位置的指针</code><br><code>git reset --hard master~3 //移动master分支的指针到3个版本之前</code><br><code>git checkout experimental</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;工作流程图&quot;&gt;&lt;a href=&quot;#工作流程图&quot; class=&quot;he
      
    
    </summary>
    
      <category term="GIT" scheme="http://yoursite.com/categories/GIT/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议</title>
    <link href="http://yoursite.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp-ip-%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/计算机网络/tcp-ip-协议/</id>
    <published>2017-11-11T03:00:00.000Z</published>
    <updated>2017-12-03T16:04:44.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>指代整个协议族；之所以叫<code>TCP/IP协议</code>，是因为<code>TCP</code>、<code>IP</code>是核心的协议。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义</p></blockquote><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p><img src="/images/2017/11/tcp-transfer.png" alt="tcp-transfer"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><strong>WHY</strong></p><blockquote><p><strong>为什么要三次握手？</strong><br>为了防止已失效的客户端连接请求突然又传送到了服务端，若没有客户端确认，则会占用服务端的资源。</p></blockquote><p><strong>HOW</strong></p><p><img src="/images/2017/11/tcp-三次握手.png" alt="tcp 三次握手"></p><table><thead><tr><th>客户端</th><th>传输</th><th>服务端</th></tr></thead><tbody><tr><td>SYN(x)</td><td>-&gt;</td><td>SYN(x)</td></tr><tr><td>SYN(y)-ACK(x+1)</td><td>&lt;-</td><td>SYN(y)+ACK(x+1)</td></tr><tr><td>ACK(y+1)</td><td>-&gt;</td><td>ACK(Y+1)</td></tr></tbody></table><blockquote><p>必须是客户端发起的SYN</p></blockquote><p>SYN: 同步序列编号（Synchronize Sequence Numbers）<br>ACK: 确认编号（Acknowledgement Number）</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><strong>WHY</strong></p><blockquote><p><strong>为什么要四次挥手？</strong><br>全双工通信，所以必须双方都确认 FIN 才可以关闭连接</p></blockquote><p><strong>HOW</strong></p><p><img src="/images/2017/11/tcp-四次挥手.png" alt="tcp-四次挥手"></p><table><thead><tr><th>客户端</th><th>传输</th><th>服务端</th></tr></thead><tbody><tr><td>FIN(客户端传输完毕)</td><td>-&gt;</td><td>FIN</td></tr><tr><td>ACK</td><td>&lt;-</td><td>ACK（先确认）</td></tr><tr><td>FIN</td><td>&lt;-</td><td>FIN （服务端传输完毕）</td></tr><tr><td>ACK</td><td>-&gt;</td><td>ACK</td></tr></tbody></table><blockquote><p>客户端、服务端都可以发起 FIN</p></blockquote><p>FIN: 数据传输完毕 (Finsh)</p><h3 id="包头结构"><a href="#包头结构" class="headerlink" title="包头结构"></a>包头结构</h3><table><thead><tr><th>名称</th><th>长度</th></tr></thead><tbody><tr><td>源端口</td><td>16位</td></tr><tr><td>目标端口</td><td>16位</td></tr><tr><td>序列号</td><td>32位</td></tr><tr><td>回应序号</td><td>32位</td></tr><tr><td>TCP头长度</td><td>4位</td></tr><tr><td>reserved</td><td>6位</td></tr><tr><td>控制代码</td><td>6位</td></tr><tr><td>窗口大小</td><td>16位</td></tr><tr><td>偏移量</td><td>16位</td></tr><tr><td>校验和</td><td>16位</td></tr><tr><td>选项</td><td>32位(可选)</td></tr></tbody></table><blockquote><p>TCP包头的最小长度，为20字节。</p></blockquote><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一种无连接的传输层协议；可靠性通过「应用层」保证。</p><h3 id="数据传输-1"><a href="#数据传输-1" class="headerlink" title="数据传输"></a>数据传输</h3><p>不提供数据包分组、组装和不能对数据包进行排序</p><h3 id="包头结构-1"><a href="#包头结构-1" class="headerlink" title="包头结构"></a>包头结构</h3><table><thead><tr><th>名称</th><th>长度</th></tr></thead><tbody><tr><td>源端口</td><td>16位</td></tr><tr><td>目的端口</td><td>16位</td></tr><tr><td>长度</td><td>16位</td></tr><tr><td>校验和</td><td>16位</td></tr></tbody></table><blockquote><p>UDP包头只有8个字节</p></blockquote><h3 id="常见的协议"><a href="#常见的协议" class="headerlink" title="常见的协议"></a>常见的协议</h3><p>DNS</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol><li>面向数据报方式</li><li>网络数据大多为短消息</li><li>拥有大量Client</li><li>对数据安全性无特殊要求</li><li>网络负担非常重，但对响应速度要求高</li></ol><h2 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h2><table><thead><tr><th>-</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>可靠（面向连接）</td><td>不可靠（无连接）</td></tr><tr><td>有序性</td><td>有序</td><td>无序</td></tr><tr><td>占用资源</td><td>多</td><td>少</td></tr><tr><td>程序结构</td><td>复杂</td><td>简单</td></tr><tr><td>数据模式</td><td>数据流<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="可以合并多个请求数据(放在缓冲区中)，一次/多次读取完">[1]</span></a></sup>（字节流）</td><td>数据报文<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="发送几次请求，就需要接收几次；一次只能读取一个完整的报文">[2]</span></a></sup></td></tr><tr><td>通信模式</td><td>点对点</td><td>一对一，一对多，多对一，多对多</td></tr><tr><td>首部开销</td><td>20字节</td><td>8字节</td></tr><tr><td>通信信道</td><td>全双工</td><td>不可靠信道</td></tr></tbody></table><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>IP协议是<code>TCP/IP协议簇</code>中的核心协议，也是<code>TCP/IP</code>的载体。<br>所有的<code>TCP，UDP，ICMP及IGMP数据</code>都以 <strong>IP数据报</strong> 格式传输。<br>IP提供<strong>不可靠</strong>的，<strong>无连接</strong>的数据传送服务；如果<strong>发生某种错误，IP会丢失该数据，然后发送ICMP消息给信源端</strong></p><h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><p><img src="/images/2017/11/ip1.png" alt="ip1"><br><img src="/images/2017/11/ip2.png" alt="ip2"></p><h3 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h3><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><p>经过<strong>ARP协议</strong>将目的主机的IP地址解析为MAC地址</p><h4 id="非局域网"><a href="#非局域网" class="headerlink" title="非局域网"></a>非局域网</h4><p>主机通过IP数据报连接目的主机时，按照如下步骤搜索:</p><ol><li>搜索路由表，优先搜索<strong>匹配主机</strong>，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机</li><li>搜索路由表，如果匹配主机失败，则匹配<strong>同子网的路由器</strong>，这需要子网掩码的协助。如果找到路由器，则将该包发向路由器。</li><li>搜索路由表，如果匹配同子网路由器失败，则匹配<strong>同网号路由器</strong>，如果找到路由器，则将该包发向路由器。</li><li>搜索路由表，如果以上都失败了，就<strong>搜索默认路由</strong>，如果默认路由存在，则发包</li><li>如果都失败了，就丢掉这个包。</li></ol><h3 id="如何查看路由表"><a href="#如何查看路由表" class="headerlink" title="如何查看路由表"></a>如何查看路由表</h3><p><img src="/images/2017/11/ip-router.png" alt="ip-router"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" rel="external nofollow noopener noreferrer" target="_blank">维基百科-TCP</a></li><li><a href="https://baike.baidu.com/item/TCP/33012?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">百科-TCP</a></li><li><a href="http://network.51cto.com/art/201411/456783.htm" rel="external nofollow noopener noreferrer" target="_blank">CDSN-TCP</a></li><li><a href="http://blog.csdn.net/houdong/article/details/1505798" rel="external nofollow noopener noreferrer" target="_blank">IP协议-CSDN</a></li><li><a href="https://jingyan.baidu.com/article/36d6ed1f56b9fe1bce48837f.html" rel="external nofollow noopener noreferrer" target="_blank">IP协议-百度经验</a></li></ul><!--以下是脚注--><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">可以合并多个请求数据(放在缓冲区中)，一次/多次读取完<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">发送几次请求，就需要接收几次；一次只能读取一个完整的报文<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;指代整个协议族；之所以叫&lt;code&gt;TCP/IP协议&lt;/code&gt;，是因为&lt;
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>网络参考模型</title>
    <link href="http://yoursite.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/计算机网络/网络参考模型/</id>
    <published>2017-11-10T18:52:00.000Z</published>
    <updated>2017-12-03T16:04:44.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><blockquote><p><strong>国际标准化组织(ISO)</strong> 和 <strong>国际电报电话咨询委员会(CCITT)</strong> 联合制定了 <strong>OSI（Open System Interconnect）</strong></p></blockquote><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>OSI参考模型是计算机网路体系结构发展的产物；其目的是为异种计算机互连提供 <strong>一个共同的基础和标准框架</strong> ，并为保持相关标准的一致性和兼容性提供共同的参考。</p><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h2><p>实现「开放系统互连」所建立的「通信功能」的「分层模型」；分七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><ul><li>每一层的功能是独立的，利用下一层为上一层提供<strong>服务</strong>；</li><li>同等层实体之间通信由该层的<strong>协议</strong>管理。</li><li>除物理层之外，每层都会在原始数据前添加一串属于自己的<strong>协议头</strong>；接收端向上传递过程中会删除自己的协议头<blockquote><p><strong>服务</strong>：下一层向上一层提供的「通信功能」和「层之间的会话规定」。<br><strong>协议</strong>：两个开放系统中的 <strong>同等层之间的通信规则和约定</strong><br>  1～4层协议称为<strong>下层协议</strong><br>  5～7层协议称为<strong>上层协议</strong></p></blockquote></li></ul><h2 id="分层说明"><a href="#分层说明" class="headerlink" title="分层说明"></a>分层说明</h2><h3 id="应用层-Application"><a href="#应用层-Application" class="headerlink" title="应用层 (Application)"></a>应用层 (Application)</h3><p>网络服务与最终用户的一个接口。<br>协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p><h3 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h3><p>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）<br>格式有，JPEG、ASCll、DECOIC、加密格式等</p><h3 id="会话层（Session-Layer）"><a href="#会话层（Session-Layer）" class="headerlink" title="会话层（Session Layer）"></a>会话层（Session Layer）</h3><p>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）<br>对应主机进程，指本地主机与远程主机正在进行的会话</p><h3 id="传输层-Transport"><a href="#传输层-Transport" class="headerlink" title="传输层 (Transport)"></a>传输层 (Transport)</h3><p>定义传输数据的协议端口号，以及流控和差错校验。<br>协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</p><h3 id="网络层-Network"><a href="#网络层-Network" class="headerlink" title="网络层 (Network)"></a>网络层 (Network)</h3><p>进行逻辑地址寻址，实现不同网络之间的路径选择。<br>协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP</p><h3 id="数据链路层-Link"><a href="#数据链路层-Link" class="headerlink" title="数据链路层 (Link)"></a>数据链路层 (Link)</h3><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p><h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><p>建立、维护、断开物理连接。（由底层网络定义协议）</p><p><img src="/images/2017/11/osi.png" alt="OSI"></p><h1 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h1><blockquote><p>TCP/IP是先有了协议，才制定TCP/IP模型。目前是互联网的事实标准</p></blockquote><h2 id="WHY-1"><a href="#WHY-1" class="headerlink" title="WHY"></a>WHY</h2><p>ARPANET是由美国国防部DoD（U.S.Department of Defense）赞助的研究网络。逐渐地它通过租用的电话线连结了数百所大学和政府部门。当无线网络和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。</p><h2 id="WHAT-1"><a href="#WHAT-1" class="headerlink" title="WHAT"></a>WHAT</h2><p>由 TCP、IP 两个协议演进过来的，共分为四层：网络访问层、互联网层、传输层和应用层</p><h2 id="HOW-1"><a href="#HOW-1" class="headerlink" title="HOW"></a>HOW</h2><p><img src="/images/2017/11/osi-translate.png" alt="osi-translate"></p><h2 id="分层说明-1"><a href="#分层说明-1" class="headerlink" title="分层说明"></a>分层说明</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>为用户提供所需要的各种服务<br>协议有：HTTP、FTP、Telnet、DNS、SMTP等.</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>为应用层提供端到端的通信功能<br>协议有：TCP、UDP</p><h3 id="网络互联层"><a href="#网络互联层" class="headerlink" title="网络互联层"></a>网络互联层</h3><p>负责分配地址和传送二进制数据。<br>协议有：IP、IGMP、ICMP<br><strong>IP协议</strong>是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>负责监视数据在主机和网络之间的交换。<strong>事实上，TCP/IP本身并未定义该层的协议</strong>，所以其具体实现的方法随着网络类型的不同而不同。</p><h1 id="OSI-比对-TCP-IP"><a href="#OSI-比对-TCP-IP" class="headerlink" title="OSI 比对 TCP/IP"></a>OSI 比对 TCP/IP</h1><p><img src="/images/2017/11/osi-tcp-ip.png" alt="OSI-TCP/IP"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.colasoft.com.cn/download/protocols_map.php" rel="external nofollow noopener noreferrer" target="_blank">科来协议图</a></li><li><a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">百科-七层模型</a></li><li><a href="https://baike.baidu.com/item/TCP%2FIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B" rel="external nofollow noopener noreferrer" target="_blank">百科-TCP/IP参考模型</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;OSI-参考模型&quot;&gt;&lt;a href=&quot;#OSI-参考模型&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>欢迎来到贺龙飞的知识库！</title>
    <link href="http://yoursite.com/index/"/>
    <id>http://yoursite.com/index/</id>
    <published>2017-11-08T13:20:17.000Z</published>
    <updated>2017-11-16T13:19:29.818Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="何为「知识库」？"><a href="#何为「知识库」？" class="headerlink" title="何为「知识库」？"></a>何为「知识库」？</h1><p>在这个信息爆炸的年代，获取信息的成本接近于0，每天都有很多新的信息蜂拥而来；过往针对这些信息，我都是放在云笔记中（尝试过有道、印象、为知、蚂蚁等），但是放在笔记中不等于掌握，所以需要进一步的进行归纳和整理，所以才有了「知识库」。</p><h1 id="为什么要用-github-page-作为「知识库」"><a href="#为什么要用-github-page-作为「知识库」" class="headerlink" title="为什么要用 github page 作为「知识库」?"></a>为什么要用 <code>github page</code> 作为「知识库」?</h1><p>之前都是放在云笔记中，但是不利于查找和分享，同时有些需求云笔记不太能满足我；这边整理了下自己对「知识库」的需求：</p><ol><li>无限级分类</li><li>可以全文搜索</li><li>内容有目录</li><li>可以方便查询</li><li>便于进行知识梳理</li><li>保证数据不会丢失</li><li>内容有更新历史</li></ol><p>所以最终选择了使用 <code>github page</code>。</p><h1 id="「知识库」和「博客」有什么区别？"><a href="#「知识库」和「博客」有什么区别？" class="headerlink" title="「知识库」和「博客」有什么区别？"></a>「知识库」和「博客」有什么区别？</h1><p>个人学习的过程是：<code>收集-&gt;整理-&gt;吸收-&gt;输出</code></p><p><strong>收集</strong>：采用「evernote」进行信息的收集<br><strong>整理</strong>：采用「知识库」进行信息/知识的整理<br><strong>吸收</strong>：在工作/学习中「实战」<br><strong>输出</strong>：采用「博客」对知识进行深入的剖析/个人见解</p><p>综上所述，「知识库」是对知识的整理，「博客」是对知识的剖析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;何为「知识库」？&quot;&gt;&lt;a href=&quot;#何为「知识库」？&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YAR</title>
    <link href="http://yoursite.com/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/yar/"/>
    <id>http://yoursite.com/程序语言/PHP/yar/</id>
    <published>2017-11-07T14:35:00.000Z</published>
    <updated>2017-12-03T16:04:44.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>一个轻量级可并行的 RPC 框架，支持三种打包协议（msgpack,json,php）,传输协议支持 http（tcp/unix以后会支持）<br>​</p><blockquote><p>github 地址：<a href="https://github.com/laruence/yar" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/laruence/yar</a><br>php 官网：<a href="http://php.net/manual/zh/book.yar.php" rel="external nofollow noopener noreferrer" target="_blank">http://php.net/manual/zh/book.yar.php</a></p></blockquote><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>鸟哥举了两个场景(传统 web 应用)：  </p><ol><li><p>一个进程，一个请求，但是涉及到多个没有依赖性的数据源，只能串行处理（依次等待所有数据源处理）完毕后才能响应；  </p><blockquote><p>yar 可以并行处理，减少时间开销</p></blockquote></li><li><p>一个应用系统随着业务的增加，人员流失，只做加法，等到不可维护性的时候，只能重构</p><blockquote><p>yar 可以给系统进行解耦（实际上是 soa 思想）</p></blockquote></li></ol><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>放置在 web 服务器上，通过 http 访问(默认get访问会输出 doc 信息)</p><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><ol><li>串行调用</li><li>并行调用（yar 内部使用 libcurl + epoll ）</li></ol><h1 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h1><h2 id="Yar-协议分析"><a href="#Yar-协议分析" class="headerlink" title="Yar 协议分析"></a>Yar 协议分析</h2><p>Yar整个协议由82字节长度的yar_header + 8字节的数据打包协议(MSGPACK、JSON、PHP)  + N字节的Body组成。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><blockquote><p>未验证</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _yar_header &#123;</span><br><span class="line">  unsigned int   id;            // transaction id</span><br><span class="line">  unsigned short version;       // protocl version</span><br><span class="line">  unsigned int   magic_num;     // default is: 0x80DFEC60</span><br><span class="line">  unsigned int   reserved;</span><br><span class="line">  unsigned char  provider[32];  // reqeust from who</span><br><span class="line">  unsigned char  token[32];     // request token, used for authentication</span><br><span class="line">  unsigned int   body_len;      // request body len</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>struct <code>_yar_header</code>中需要注意的是magic_num值。该值在Client与Server都应该保持一致。否则视为不合法的数据。我们可以通过修改这个值，定制一个yar框架，防止其他人恶意请求。</p></blockquote><h2 id="跨语言"><a href="#跨语言" class="headerlink" title="跨语言"></a>跨语言</h2><blockquote><p>利用 yar 可以接收 struct 实现</p></blockquote><ul><li>client</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array(</span><br><span class="line">  &quot;i&quot; =&gt; &apos;&apos;, // transaction id</span><br><span class="line">  &quot;m&quot; =&gt; &apos;&apos;,  // the method which being called</span><br><span class="line">  &quot;p&quot; =&gt; array(), // parameters</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>server</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array(</span><br><span class="line">   &quot;i&quot; =&gt; &apos;&apos;,</span><br><span class="line">   &quot;s&quot; =&gt; &apos;&apos;, //status</span><br><span class="line">   &quot;r&quot; =&gt; &apos;&apos;, //return value</span><br><span class="line">   &quot;o&quot; =&gt; &apos;&apos;, //output</span><br><span class="line">   &quot;e&quot; =&gt; &apos;&apos;, //error or exception</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://www.laruence.com/2012/09/15/2779.html" rel="external nofollow noopener noreferrer" target="_blank">Yar – 并行的RPC框架(Concurrent RPC framework)</a></li><li><a href="http://www.searchtb.com/2013/10/yar-%E5%B9%B6%E8%A1%8Crpc%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6.html" rel="external nofollow noopener noreferrer" target="_blank">YAR 并行RPC框架研究</a></li><li><a href="http://blog.weixinhost.com/wei-ming-ming/" rel="external nofollow noopener noreferrer" target="_blank">Yar协议分析与跨语言实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;head
      
    
    </summary>
    
      <category term="程序语言" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="yar" scheme="http://yoursite.com/tags/yar/"/>
    
      <category term="php_ext" scheme="http://yoursite.com/tags/php-ext/"/>
    
  </entry>
  
  <entry>
    <title>MAC 必备软件</title>
    <link href="http://yoursite.com/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mac/"/>
    <id>http://yoursite.com/效率工具/mac/</id>
    <published>2017-11-06T15:25:00.000Z</published>
    <updated>2017-11-16T13:18:31.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><ul><li><a href="http://matthewpalmer.net/vanilla/" rel="external nofollow noopener noreferrer" target="_blank">Vanilla</a>：隐藏菜单栏</li><li><a href="https://www.spectacleapp.com/" rel="external nofollow noopener noreferrer" target="_blank">Spectacle</a>：窗口分屏</li><li><a href="https://coffitivity.com/" rel="external nofollow noopener noreferrer" target="_blank">Coffitivity</a>：白噪音</li><li><a href="https://www.enpass.io/" rel="external nofollow noopener noreferrer" target="_blank">Enpass</a>：密码管理工具</li><li><a href="https://www.teamviewer.com/zhCN/" rel="external nofollow noopener noreferrer" target="_blank">TeamViewer</a>：远程控制</li><li><a href="http://www.yingdev.com/projects/tickeys" rel="external nofollow noopener noreferrer" target="_blank">Tickeys</a>：打字音效</li><li><a href="https://getlantern.org/" rel="external nofollow noopener noreferrer" target="_blank">Lantern</a>：出国工具</li><li>Irvue：自动切换壁纸</li><li>OmniDiskSweeper: 查看磁盘占用工具</li></ul><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><ul><li><a href="https://apps.ankiweb.net/" rel="external nofollow noopener noreferrer" target="_blank">Anki</a>：复习工具</li><li><a href="https://www.yinxiang.com/" rel="external nofollow noopener noreferrer" target="_blank">Evernote</a>：收集资料</li><li><a href="https://leanote.com/" rel="external nofollow noopener noreferrer" target="_blank">Leanote</a>：笔记</li><li><a href="https://marginnote.com/" rel="external nofollow noopener noreferrer" target="_blank">MarginNote Pro</a>：学习 pdf 神器（收费）</li><li><a href="https://mindnode.com/" rel="external nofollow noopener noreferrer" target="_blank">MindNode</a>：思维导图（收费）</li><li><a href="http://wiki.kiwix.org/wiki/Main_Page/zh-cn" rel="external nofollow noopener noreferrer" target="_blank">kiwix</a>：离线维基百科</li></ul><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul><li><a href="https://atom.io/" rel="external nofollow noopener noreferrer" target="_blank">Atom</a>：编辑器</li><li><a href="https://www.charlesproxy.com/" rel="external nofollow noopener noreferrer" target="_blank">Charles</a>：抓包工具（收费）</li><li><a href="https://kapeli.com/dash" rel="external nofollow noopener noreferrer" target="_blank">Dash</a>：文档（收费）</li><li><a href="http://www.iterm2.com/" rel="external nofollow noopener noreferrer" target="_blank">iTerm 2</a>：终端</li><li><a href="https://www.jetbrains.com/phpstorm/" rel="external nofollow noopener noreferrer" target="_blank">PhpStorm</a>：PHP 的 IDE</li><li><a href="http://www.sequelpro.com/" rel="external nofollow noopener noreferrer" target="_blank">Sequel Pro</a>：Mysql 客户端</li><li><a href="https://www.sourcetreeapp.com/" rel="external nofollow noopener noreferrer" target="_blank">SourceTree</a>：Git 客户端</li><li><a href="http://www.sublimetext.com/" rel="external nofollow noopener noreferrer" target="_blank">Sublime Text</a>：轻量可定制编辑器</li><li><a href="https://www.typora.io/" rel="external nofollow noopener noreferrer" target="_blank">Typora</a>：MD 编辑器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;系统&quot;&gt;&lt;a href=&quot;#系统&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="效率工具" scheme="http://yoursite.com/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Blog 系统之 Hexo</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%AE%80%E6%9E%90/blog/"/>
    <id>http://yoursite.com/开源软件简析/blog/</id>
    <published>2017-11-05T06:26:00.000Z</published>
    <updated>2017-11-08T15:59:00.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Blog-系统"><a href="#Blog-系统" class="headerlink" title="Blog 系统"></a>Blog 系统</h1><p>之前用的是 Octopress ，由于不更新了，且使用的是 ruby 开发，生成 html 比较慢，所以迁移到 hexo。</p><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><p><a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noopener noreferrer" target="_blank">hexo 文档</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli</span><br><span class="line"><span class="meta">$</span> hexo init &lt;folder&gt;</span><br><span class="line"><span class="meta">$</span> cd &lt;folder&gt;</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure><p>安装完毕后，请自行修改 <code>/_config.yml</code></p><p><strong> 最后别忘记添加 CNAME</strong></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>采用 Hiker 主题；<a href="https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/README.cn.md" rel="external nofollow noopener noreferrer" target="_blank">[中文说明]</a> <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" rel="external nofollow noopener noreferrer" target="_blank">[Github]</a></p><p><strong>删除作者自己的 cnzz 统计代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># source/js/scripts.js 中，删除以下代码</span><br><span class="line"><span class="keyword">var</span> s = [</span><br><span class="line">        <span class="string">'&lt;div style="display: none;"&gt;'</span>,</span><br><span class="line">          <span class="string">'&lt;script src="https://s11.cnzz.com/z_stat.php?id=1260716016&amp;web_id=1260716016" language="JavaScript"&gt;&lt;/script&gt;'</span>,</span><br><span class="line">        <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">      ].join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> di = $(s);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#container'</span>).append(di);</span><br></pre></td></tr></table></figure><p><strong>修改主题的配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /themes/hiker/_config.yml</span></span><br><span class="line"><span class="comment"># 清空以下信息，都是作者本人信息</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">donate:</span></span><br><span class="line"><span class="comment"># 其他数据请自行填充</span></span><br></pre></td></tr></table></figure><h1 id="Atom-配置"><a href="#Atom-配置" class="headerlink" title="Atom 配置"></a>Atom 配置</h1><blockquote><p>采用 atom 作为 md 的编辑器</p></blockquote><p>详细配置见：<a href="/intro/atom.html#hexo">atom-hexo配置</a></p><h1 id="Hexo-命令"><a href="#Hexo-命令" class="headerlink" title="Hexo 命令"></a>Hexo 命令</h1><blockquote><p>详细命令清单见：<kbd><a href="https://hexo.io/zh-cn/docs/commands.html" rel="external nofollow noopener noreferrer" target="_blank">hexo 命令</a></kbd></p></blockquote><h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h2 id="实时更新预览"><a href="#实时更新预览" class="headerlink" title="实时更新预览"></a>实时更新预览</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -w</span><br></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h1 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h1><p><strong>配置</strong></p><p>bash/zsh 的配置文件 .basrc/.zshrc  增加如下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> BLOG_PATH=<span class="string">"blog的目录"</span></span><br><span class="line"><span class="built_in">alias</span> blog_root=<span class="string">"cd <span class="variable">$BLOG_PATH</span>/"</span></span><br><span class="line">PATH=<span class="string">"...:<span class="variable">$BLOG_PATH</span>/shell"</span></span><br></pre></td></tr></table></figure><h2 id="进入-Hexo-根目录"><a href="#进入-Hexo-根目录" class="headerlink" title="进入 Hexo 根目录"></a>进入 Hexo 根目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog_root</span><br></pre></td></tr></table></figure><h2 id="预览-1"><a href="#预览-1" class="headerlink" title="预览"></a>预览</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog_preview</span><br></pre></td></tr></table></figure><h2 id="生成-html"><a href="#生成-html" class="headerlink" title="生成 html"></a>生成 html</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog_generate</span><br></pre></td></tr></table></figure><h2 id="发布-1"><a href="#发布-1" class="headerlink" title="发布"></a>发布</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog_deploy</span><br></pre></td></tr></table></figure><h2 id="打开-atom"><a href="#打开-atom" class="headerlink" title="打开 atom"></a>打开 atom</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog_atom</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Blog-系统&quot;&gt;&lt;a href=&quot;#Blog-系统&quot; class
      
    
    </summary>
    
      <category term="开源软件简析" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%AE%80%E6%9E%90/"/>
    
    
      <category term="atom" scheme="http://yoursite.com/tags/atom/"/>
    
  </entry>
  
  <entry>
    <title>Atom 编辑器</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%AE%80%E6%9E%90/atom/"/>
    <id>http://yoursite.com/开源软件简析/atom/</id>
    <published>2017-11-04T21:51:00.000Z</published>
    <updated>2017-11-08T16:01:35.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><ul><li>markdown-preview-enhanced ：增强版 md 预览</li><li>markdown-writer ：写博客必备利器</li><li>tool-bar ：工具栏基类</li><li>tool-bar-markdown-writer ： md-writer的工具栏</li><li>vim-mode-plus ：vim 插件</li><li>markdown-table-editor ：表格编辑工具</li><li>atom-terminal ：终端</li></ul><p><strong>tool-bar-markdown-writer</strong></p><p>修改文件 <code>~/.atom/packages/tool-bar-markdown-writer/lib/tool-bar-markdown-writer.coffee</code> 增加如下功能：</p><ul><li>增加 publish-draft</li><li>Preview markdown 增加支持 <code>markdown-preview-enhanced</code></li></ul><p>新增的配置如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'icon'</span>: <span class="string">'content-duplicate'</span></span><br><span class="line">  <span class="string">'tooltip'</span>: <span class="string">'Publish Draft'</span></span><br><span class="line">  <span class="string">'callback'</span>: <span class="string">'markdown-writer:publish-draft'</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'icon'</span>: <span class="string">'markdown'</span></span><br><span class="line">  <span class="string">'tooltip'</span>: <span class="string">'Preview Markdown'</span></span><br><span class="line">  <span class="string">'data'</span>: [<span class="string">'markdown-preview-enhanced'</span>, <span class="string">'markdown-preview-plus'</span>,<span class="string">'markdown-preview'</span>]</span><br><span class="line">  <span class="string">'visible'</span>: (data) -&gt;</span><br><span class="line">    pkg = data.find (pkg) -&gt; !!atom.packages.getLoadedPackage(pkg)</span><br><span class="line">    <span class="string">"#&#123;pkg&#125;:toggle"</span> <span class="keyword">if</span> pkg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Atom 配置文件</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*"</span><span class="string">:</span></span><br><span class="line"><span class="attr">  core:</span></span><br><span class="line"><span class="attr">    packagesWithKeymapsDisabled:</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"markdown-preview"</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line"><span class="attr">    telemetryConsent:</span> <span class="string">"no"</span></span><br><span class="line"><span class="attr">  "exception-reporting":</span></span><br><span class="line"><span class="attr">    userId:</span> <span class="string">"5a8289c3-5832-4d26-af7b-3235427b72da"</span></span><br><span class="line"><span class="attr">  "markdown-preview-enhanced":</span></span><br><span class="line"><span class="attr">    enableExtendedTableSyntax:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    imageDropAction:</span> <span class="string">"copy to image folder"</span></span><br><span class="line"><span class="attr">    mathRenderingOption:</span> <span class="string">"MathJax"</span></span><br><span class="line"><span class="attr">  "markdown-writer":</span></span><br><span class="line"><span class="attr">    fileExtension:</span> <span class="string">".md"</span></span><br><span class="line"><span class="attr">    renameImageOnCopy:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  "tool-bar":</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  "tool-bar-markdown-writer":</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  "vim-mode-plus":</span></span><br><span class="line"><span class="attr">    notifiedCoffeeScriptNoLongerSupportedToExtendVMP:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  welcome:</span></span><br><span class="line"><span class="attr">    showOnStartup:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h1 id="Simiki-配置"><a href="#Simiki-配置" class="headerlink" title="Simiki 配置"></a>Simiki 配置</h1><blockquote><p>主要使用的是 md-writer</p></blockquote><p>生成项目专用的配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击 packages -&gt; markdown-writer -&gt; configurations -&gt; create project configs</span><br></pre></td></tr></table></figure><p>最终在项目的根目录下生成 <code>_mdwriter.cson</code></p><p>修改如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory to drafts from siteLocalDir</span></span><br><span class="line"><span class="attr">siteDraftsDir:</span> <span class="string">"content/"</span></span><br><span class="line"><span class="comment"># Directory to posts from siteLocalDir</span></span><br><span class="line"><span class="attr">sitePostsDir:</span> <span class="string">"content/"</span></span><br><span class="line"><span class="comment"># Directory to images from siteLocalDir</span></span><br><span class="line"><span class="comment"># - E.g. to use the current filename directory, can use &#123;directory&#125;</span></span><br><span class="line"><span class="attr">siteImagesDir:</span> <span class="string">"attach/img/&#123;year&#125;/&#123;month&#125;/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Filename format of new drafts created</span></span><br><span class="line"><span class="attr">newDraftFileName:</span> <span class="string">"&#123;slug&#125;&#123;extension&#125;"</span></span><br><span class="line"><span class="comment"># Filename format of new posts created</span></span><br><span class="line"><span class="attr">newPostFileName:</span> <span class="string">"&#123;slug&#125;&#123;extension&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Front matter date format, determines the &#123;date&#125; in frontMatter</span></span><br><span class="line"><span class="attr">frontMatterDate:</span> <span class="string">"&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;"</span></span><br><span class="line"><span class="comment"># Front matter template</span></span><br><span class="line"><span class="attr">frontMatter:</span> <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">title: "</span><span class="string">&#123;title&#125;"</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">"&#123;date&#125;"</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">"page"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">[TOC]</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># File extension of posts/drafts</span></span><br><span class="line"><span class="string">fileExtension: "</span><span class="string">.md"</span></span><br><span class="line"><span class="comment"># File slug separator</span></span><br><span class="line"><span class="attr">slugSeparator:</span> <span class="string">"-"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tableExtraPipes:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h1><blockquote><p>主要使用的是 md-writer</p></blockquote><p>生成项目专用的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击 packages -&gt; markdown-writer -&gt; configurations -&gt; create project configs</span><br></pre></td></tr></table></figure><p>最终在项目的根目录下生成 <code>_mdwriter.cson</code></p><p>修改如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">siteEngine:</span> <span class="string">"hexo"</span></span><br><span class="line"><span class="comment"># Website URL of your blog</span></span><br><span class="line"><span class="attr">siteUrl:</span> <span class="string">"http://www.helongfei.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory to drafts from siteLocalDir</span></span><br><span class="line"><span class="attr">siteDraftsDir:</span> <span class="string">"source/_drafts/"</span></span><br><span class="line"><span class="comment"># Directory to posts from siteLocalDir</span></span><br><span class="line"><span class="attr">sitePostsDir:</span> <span class="string">"source/_posts/&#123;year&#125;/"</span></span><br><span class="line"><span class="comment"># Directory to images from siteLocalDir</span></span><br><span class="line"><span class="comment"># - E.g. to use the current filename directory, can use &#123;directory&#125;</span></span><br><span class="line"><span class="attr">siteImagesDir:</span> <span class="string">"source/images/&#123;year&#125;/&#123;month&#125;/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Filename format of new drafts created</span></span><br><span class="line"><span class="attr">newDraftFileName:</span> <span class="string">"&#123;slug&#125;&#123;extension&#125;"</span></span><br><span class="line"><span class="comment"># Filename format of new posts created</span></span><br><span class="line"><span class="attr">newPostFileName:</span> <span class="string">"&#123;slug&#125;&#123;extension&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Front matter date format, determines the &#123;date&#125; in frontMatter</span></span><br><span class="line"><span class="attr">frontMatterDate:</span> <span class="string">"&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;"</span></span><br><span class="line"><span class="comment"># Front matter template</span></span><br><span class="line"><span class="attr">frontMatter:</span> <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">layout: "</span><span class="string">&#123;layout&#125;"</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">"&#123;title&#125;"</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">"&#123;date&#125;"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># File extension of posts/drafts</span></span><br><span class="line"><span class="string">fileExtension: "</span><span class="string">.md"</span></span><br><span class="line"><span class="comment"># File slug separator</span></span><br><span class="line"><span class="attr">slugSeparator:</span> <span class="string">"-"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Table row continuation</span></span><br><span class="line"><span class="comment"># - Enable to auto insert table columns when you press enter in a table row</span></span><br><span class="line"><span class="attr">tableNewLineContinuation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;安装插件&quot;&gt;&lt;a href=&quot;#安装插件&quot; class=&quot;head
      
    
    </summary>
    
      <category term="开源软件简析" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%AE%80%E6%9E%90/"/>
    
    
      <category term="atom" scheme="http://yoursite.com/tags/atom/"/>
    
  </entry>
  
  <entry>
    <title>Wiki 系统之 Simiki</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%AE%80%E6%9E%90/wiki/"/>
    <id>http://yoursite.com/开源软件简析/wiki/</id>
    <published>2017-11-03T16:00:00.000Z</published>
    <updated>2017-11-08T16:23:55.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Wiki-系统"><a href="#Wiki-系统" class="headerlink" title="Wiki 系统"></a>Wiki 系统</h1><p>需求：git+md</p><table><thead><tr><th style="text-align:left">系统</th><th style="text-align:left">实现方式</th><th style="text-align:left">缺点</th><th style="text-align:left">优点</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.dokuwiki.org/dokuwiki#" rel="external nofollow noopener noreferrer" target="_blank">dokuwiki</a></td><td style="text-align:left">php+文本</td><td style="text-align:left">编辑器不好用；数据量大搜索可能有性能问题（txt）</td><td style="text-align:left">插件丰富，txt移植方便</td></tr><tr><td style="text-align:left"><a href="https://www.mediawiki.org/wiki/MediaWiki" rel="external nofollow noopener noreferrer" target="_blank">mediawiki</a></td><td style="text-align:left">php+mysql</td><td style="text-align:left">配置复杂；visualeditor 加载慢</td><td style="text-align:left">功能全面，visualeditor</td></tr><tr><td style="text-align:left"><a href="http://simiki.org/" rel="external nofollow noopener noreferrer" target="_blank">simiki</a></td><td style="text-align:left">git+md</td><td style="text-align:left">全量生成html；图片支持不好</td><td style="text-align:left">可定制</td></tr><tr><td style="text-align:left"><a href="https://www.gitbook.com/" rel="external nofollow noopener noreferrer" target="_blank">gitbook</a></td><td style="text-align:left">git+md</td><td style="text-align:left">全量生成 html ( 渲染巨慢 )</td><td style="text-align:left">有编辑器</td></tr></tbody></table><h1 id="Simiki-安装"><a href="#Simiki-安装" class="headerlink" title="Simiki 安装"></a>Simiki 安装</h1><p><a href="http://simiki.org/zh-docs/" rel="external nofollow noopener noreferrer" target="_blank">simiki 文档</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install simiki</span><br><span class="line">mkdir mywiki &amp;&amp; <span class="built_in">cd</span> mywiki</span><br><span class="line">simiki init</span><br></pre></td></tr></table></figure><p>配置 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span></span><br><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">author:</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">yasimple_x2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">fenced_code</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">extra</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">codehilite(css_class=hlcode,</span> <span class="string">linenums=False)</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">toc(title=Table</span> <span class="string">of</span> <span class="string">Contents)</span></span><br></pre></td></tr></table></figure><p>增加 CNAME 文件</p><blockquote><p>为了域名解析；文本内容为待解析域名</p></blockquote><h1 id="Atom-配置"><a href="#Atom-配置" class="headerlink" title="Atom 配置"></a>Atom 配置</h1><blockquote><p>使用 Atom 作为 md 编辑器</p></blockquote><p>详细配置见 <a href="/intro/atom.html#simiki">Atom-simike 配置</a></p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><h2 id="fab"><a href="#fab" class="headerlink" title="fab"></a>fab</h2><p>需要<code>_config.yml</code>增加如下配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  - type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">    remote:</span> <span class="string">origin</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure><p>发布的时候如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fab deploy#不支持python3</span><br></pre></td></tr></table></figure><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>使用自定义命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wiki_deploy</span><br></pre></td></tr></table></figure><h1 id="simiki-命令"><a href="#simiki-命令" class="headerlink" title="simiki 命令"></a>simiki 命令</h1><h2 id="生成-html"><a href="#生成-html" class="headerlink" title="生成 html"></a>生成 html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simiki g</span><br></pre></td></tr></table></figure><h2 id="预览-wiki"><a href="#预览-wiki" class="headerlink" title="预览 wiki"></a>预览 wiki</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simiki p</span><br></pre></td></tr></table></figure><h2 id="实时生成-html"><a href="#实时生成-html" class="headerlink" title="实时生成 html"></a>实时生成 html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simiki p -w</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Wiki-系统&quot;&gt;&lt;a href=&quot;#Wiki-系统&quot; class
      
    
    </summary>
    
      <category term="开源软件简析" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%AE%80%E6%9E%90/"/>
    
    
      <category term="atom" scheme="http://yoursite.com/tags/atom/"/>
    
  </entry>
  
  <entry>
    <title>Codeception 之验收测试</title>
    <link href="http://yoursite.com/%E6%B5%8B%E8%AF%95/codeception/"/>
    <id>http://yoursite.com/测试/codeception/</id>
    <published>2016-05-02T07:38:09.000Z</published>
    <updated>2017-12-03T16:04:44.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Acceptance-Testing"><a href="#Acceptance-Testing" class="headerlink" title="Acceptance Testing"></a>Acceptance Testing</h1><p>验收测试针对整个站点进行测试，模拟真实用户的访问流程。</p><p>写测试的人员不需要知道网站的内部实现。</p><h1 id="两种测试类型"><a href="#两种测试类型" class="headerlink" title="两种测试类型"></a>两种测试类型</h1><h2 id="PhpBrowser"><a href="#PhpBrowser" class="headerlink" title="PhpBrowser"></a>PhpBrowser</h2><p>配置<code>tests/acceptance.suite.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_name: AcceptanceTester</span><br><span class="line">modules:</span><br><span class="line">    enabled:</span><br><span class="line">        - PhpBrowser:</span><br><span class="line">            url:</span><br><span class="line">        - \Helper\Acceptance</span><br></pre></td></tr></table></figure><h2 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h2><p>配置<code>tests/acceptance.suite.yml</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class_name: AcceptanceTester</span><br><span class="line">modules:</span><br><span class="line">    enabled:</span><br><span class="line">        - WebDriver:</span><br><span class="line">            url:</span><br><span class="line">            browser: chrome</span><br><span class="line">        - \Helper\Acceptance</span><br></pre></td></tr></table></figure><p>配置<code>Selenium</code>环境</p><ol><li>下载<a href="http://docs.seleniumhq.org/download/" rel="external nofollow noopener noreferrer" target="_blank">Selenium Standalone Server</a></li><li>下载<a href="https://sites.google.com/a/chromium.org/chromedriver/" rel="external nofollow noopener noreferrer" target="_blank">Google Chrome Driver</a></li><li>启动：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//启动selenium-server</span><br><span class="line">java -jar selenium-server-standalone-2.53.0.jar</span><br><span class="line">//启动Chrome Driver</span><br><span class="line">./chromedriver</span><br></pre></td></tr></table></figure><h1 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h1><blockquote><p>测试写在<code>tests/acceptance</code>,后缀为<code>Cept</code>，例如：<code>SiginCept.php</code></p></blockquote><h2 id="PhpBrowser测试"><a href="#PhpBrowser测试" class="headerlink" title="PhpBrowser测试"></a>PhpBrowser测试</h2><p>文档参考：PHP Browser</p><ul><li>actions</li><li>Assertions  </li><li>Grabbers</li><li>Comments</li><li>Cookies, Urls, Title</li></ul><h2 id="Selenium-WebDriver测试"><a href="#Selenium-WebDriver测试" class="headerlink" title="Selenium WebDriver测试"></a>Selenium WebDriver测试</h2><p>文档参考：Selenium WebDriver</p><ul><li>Session Snapshots</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="DB配置"><a href="#DB配置" class="headerlink" title="DB配置"></a>DB配置</h3><ol><li>SQL语句<br>放在 <code>/tests/_data</code> 下</li><li>DB-config<br>修改<code>codeception.yml</code></li></ol><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><ol><li>命令行增加 <code>--debug</code></li><li>手动输出 <code>codecept_debug()</code></li><li>手动下一步 <a href="http://codeception.com/docs/modules/WebDriver#pauseExecution" rel="external nofollow noopener noreferrer" target="_blank">pauseExecution</a></li><li>记录测试 <a href="http://codeception.com/addons#CodeceptionExtensionRecorder" rel="external nofollow noopener noreferrer" target="_blank">Recorder extension</a></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://codeception.com/docs/03-AcceptanceTests" rel="external nofollow noopener noreferrer" target="_blank">Acceptance Testing介绍</a></li><li><a href="http://codeception.com/docs/03-AcceptanceTests#PHP-Browser" rel="external nofollow noopener noreferrer" target="_blank">PHP Browser介绍</a></li><li><a href="http://codeception.com/docs/modules/PhpBrowser" rel="external nofollow noopener noreferrer" target="_blank">PHP Browser文档</a></li><li><a href="http://codeception.com/docs/modules/WebDriver" rel="external nofollow noopener noreferrer" target="_blank">Selenium WebDriver文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Acceptance-Testing&quot;&gt;&lt;a href=&quot;#Acc
      
    
    </summary>
    
      <category term="测试" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="Codeception" scheme="http://yoursite.com/tags/Codeception/"/>
    
  </entry>
  
</feed>
