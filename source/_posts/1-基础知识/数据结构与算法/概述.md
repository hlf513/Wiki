---
title: 概述
date: '2017-12-31 18:16'
toc: true
tags:
  - 数据结构
top: 9999
---

# 数据结构
> 数据结构是相互之间存在一种或多种定关系的数据元素的集合。

## 组成
![组成](/images/2017/12/31/组成.png)

注意：
* 数据项是数据的最小单元
* 数据元素是讨论问题时在数据结构中建立数据模型的着眼点

## 分类
### 逻辑结构

> 逻辑结构：数据对象中数据元素之间的关系。

#### 集合结构
![集合结构](/images/2017/12/31/集合结构.png)
数据元素同属于一个集合，互相之间没有关系。

#### 线性结构

![线性结构](/images/2017/12/31/线性结构.png)

数据元素之间是一对一的关系

#### 树性结构
![树形结构](/images/2017/12/31/树形结构.png)

数据元素之间是一对多的关系

#### 图形结构
![图形结构](/images/2017/12/31/图形结构.png)
数据元素之间是多对多的关系

### 物理结构

> 物理结构：数据的逻辑结构在计算机中的存储形式。

#### 顺序存储结构

![顺序存储结构](/images/2017/12/31/顺序存储结构.png)

数据元素放在地址连续的存储单元里。

#### 链式存储结构

![链式存储结构](/images/2017/12/31/链式存储结构.png)
数据元素放在任意位置的存储单元里；每个数据元素需要一个额外的指定地址。

# 算法

> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

## 特性

* 输入（0个或多个）
* 输出（至少1个）
* 有穷性（在可接受的时间内执行完毕）
* 确定性（每个算法步骤不能有二义性）
* 可行性（每个算法步骤都是实际可执行，而不是理论可行）

## 设计的要求

### 正确性
> 正确性：算法至少应该具有输入、输出和加工处理无歧义、能正确反映问题的需求、能够得到问题的正确答案。

算法程序的正确，大体分为以下四个层次：

1. 没有语法错误
2. 对合法的输入数据能够产生满足要求的输出结果
3. 对非法的输入数据能够产生满足规格说明的结果
4. 对精心设计的测试数据有满足要求的输出结果

因为测试层次4的代价比较昂贵；所以一般情况下，我们把层次3作为一个算法是否正确的标准。

### 可读性

> 可读性：算法设计是为了方便阅读、理解和交流。

### 健壮性

> 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名的结果。

### 高效率低存储

高效率：算法的执行时间短
低储存：算法在执行过程中占用的存储空间低

## 效率的度量方法

### 事后统计方法

通过实际测试不同算法的运行时间来比较效率的高低。因为会有不准确，成本高等缺点，所以不予采纳。

不准确：硬件不同、测试数据的规模不同
成本高：需要实现各种算法、设计测试数据

### 事前分析估算方法

经过分析，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。计算对运行时间有消耗的基本操作的执行次数，即可测定运行时间。

#### 理论依据

通过对比算法的「**关键执行次数**」的函数的渐进增长性，基本可以分析出：
某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。(函数渐进增长)

#### 如何判断算法的好坏？

通常我们使用「时间复杂度」来考核一个算法的好坏。

#### 复杂度



##### 时间复杂度
> 算法的时间复杂度，也就是算法的时间量度，计算公式记作：T(n) = O(f(n))，表示随着 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同；其中 n 表示问题规模，f(n) 是问题规模的某个函数。

一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。

###### 复杂度的渐进表示法

* T(n) = O(f(n)) 表示存在常数 C>0，N>0 使得当 n>N 时有 T(n) <= C*f(n)
* T(n) = Ω(g(n)) 表示存在常数 C>0，N>0 使得当 n>N 时有 T(n) >= C*g(n)
* T(n) = 𝚯(h(n)) 表示同时有 T(n) = O(h(n)) 和 T(n) = Ω(h(n))

O：上界
Ω：下界
𝚯：即是上界也是下界

注意：
O 通常是找最小的上界
Ω 通常是找最大的下界

###### 推导大 O 阶的方法

获取大 O 阶：

1. 用常数 1 取代运行时间中的所有加法常数。
2. 运行次数函数只保留最高阶项
3. 若最高阶项存在且不是1，则去除与其相乘的常数。
4. 若两段算法分别有复杂度 T1(n) = O(f1(n)) 和 T2(n) = O(f2(n))则
  * T1(n) + T2(n) = max(O(f1(n)),O(f2(n)))
  * T1(n) * T2(n) = O(f1(n) * f2(n))
5. 若 T(n) 是关于 n 的 k 阶多项式，那么 T(n) = 𝚯(n^k)
6. 一个 for 循环的时间复杂度等于循环次数 * 循环体代码的复杂度
7. if-else 结构的复杂度取决于 if 的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大

![常见时间复杂度](/images/2017/12/31/常见时间复杂度.png)


###### 最坏情况与平均情况

最坏情况：运行时间的最坏情况。
平均情况：期望得到的运行时间；无法通过分析估算，一般是通过运行一定数量的数据后估算出来的。

一般情况下，我们提到的运行时间都是指：最坏时间复杂度。


##### 空间复杂度

> 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中 n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。


# 参考资料

* 《大话数据结构》
* 《浙大-数据结构》

<!--以下是脚注-->
