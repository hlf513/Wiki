---
title: 线性表
date: '2018-01-01 20:53'
toc: true
tags:
  - 数据结构
top: 9998
---

# 定义

> 线性表是零个或多个具有相同类型的数据元素的有限序列。

# 抽象数据类型

```
ADT 线性表(list)
Data
  线性表的数据对象集合为{a1....an}，每个元素的类型均为 DataType。其中，除第一个元素 a1 外，每一个元素有且只有一个前驱元素，除了最后一个元素 an 外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
  InitList(*L): 初始化操作，建立一个空的线性表 L
  ListEmpty(L): 若线性表为空，返回 true，否则返回 false
  ClearList(*L): 将线性表清空
  GetElem(L,i,*e): 将线性表 L 中第 i 个位置元素值返回给 e
  LocateElem(L,e): 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
  ListInsert(*L,i,e): 在线性表 L 中的第 i 个位置插入新元素 e
  ListDelete(*L,i,*e): 删除线性表 L 中第 i 个位置元素，并用 e 返回其值
  ListLength(L): 返回线性表 L 的元素个数
endADT
```

# 存储结构

## 顺序存储结构

> 线性表的顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。

![线性表顺序存储结构](/images/2018/01/01/线性表顺序存储结构.png)

### 存储方式

通常使用「一维数组」来实现

### 操作
#### 获取

直接根据「数组」下标获取；时间复杂度：O(1)。

#### 插入

思路：
1. 如果插入位置不合理，抛出异常
2. 若线性表长度 >= 数组长度，则抛出异常或动态增加容量
3. 从最后一个元素开始向前遍历到第 i 个位置，分别将他们都向后移动一个位置
4. 将要插入元素填入位置 i 处
5. 表长加1

时间复杂度 O(n)。

![线性表-顺序存储-插入](/images/2018/01/01/线性表-顺序存储-插入.png)

#### 删除

思路：
1. 若删除位置不合理，抛出异常
2. 取出删除元素
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
4. 表长减1

时间复杂度 O(n)。

![线性表-顺序存储-删除](/images/2018/01/01/线性表-顺序存储-删除.png)

### 优缺点

**优点：**
* 无需为表示表中元素的逻辑关系而增加额外的存储空间（指针）
* 可以快速读取表中的任一位置的元素

**缺点：**
* 插入和删除操作需要移动大量元素
* 当线性表长度变化较大时，难以确定存储空间的容量
* 会造成存储空间的「碎片」

### 使用场景

* 已知固定长度
* 不经常更新（新增、删除）

## 链式存储结构

### 术语
**结点：** 数据域 + 指针域
**头指针：** 链表中第一个结点的存储位置，通常作为链表名称；链表的必要元素
**头结点：** 链表的第一个结点前附设的一个结点，数据域一般为空，也可存放公共数据；存在的作用是使对第一个结点的操作和其他的结点保持一致
**前驱结点：** 当前结点的前一个结点
**后继结点：** 当前结点的下一个结点

![头指针与头结点](/images/2018/01/01/头指针与头结点.png)

### 单链表
> n 个结点链接成一个链表，每个结点只有一个指针域

![线性表-链式存储-单链表](/images/2018/01/01/线性表-链式存储-单链表.png)

#### 操作
##### 整表创建
思路：
1. 声明一结点 p 和计数器变量 i
2. 初始化一空链表 L
3. 让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表
4. 循环
    - 生成一新结点赋值给 p
    - 随机生成一数字赋值给 p 的数据域 p->Data
    - 将 p 插入到头结点与前一结点之间

##### 整表删除
思路：
1. 声明一结点 p 和 q
2. 将第一个结点赋值给 p
3. 循环
    - 将下一结点赋值给 q
    - 释放 p
    - 将 q 赋值给 p

##### 读取元素

思路：
1. 声明一个结点 p 指向链表第一个结点，初始化 j 从1开始
2. 当 j < 1 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加1
3. 若到链表末尾 p 为空，则说明第 i 个元素不存在
4. 否则查找成功，返回结点 p 的数据

最坏情况的时间复杂度 O(n)

##### 插入元素

思路：
1. 声明一结点 p 指向链表第一个结点，初始化 j 从1开始
2. 当 j < 1 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加1
3. 若到链表末尾 p 为空，则说明第 i 个元素不存在
4. 否则查找成功，在系统中生成一个空结点 s
5. 将数据元素 e 赋值给 s->data
6. 单链表的插入标准语句 s->next=p->next; p->next=s
7. 返回成功

最坏情况的时间复杂度 O(n)

![线性表-链式存储-单链表-插入](/images/2018/01/02/线性表-链式存储-单链表-插入.png)


##### 删除元素

思路：
1. 声明一结点 p 指向链表第一个结点，初始化 j 从1开始
2. 当 j < i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加1
3. 若到链表末尾 p 为空，则说明第 i 个元素不存在
4. 否则查找成功，将欲删除的结点 p->next 赋值给 q
5. 单链表的删除标准语句 p->next=q->next
6. 将 q 结点中的数据赋值给 e，作为返回
7. 释放 q 结点
8. 返回成功

最坏情况的时间复杂度 O(n)

![线性表-链式存储-单链表-删除](/images/2018/01/02/线性表-链式存储-单链表-删除.png)

#### 与顺序存储结构对比
![单链表 vs 顺序存储](/images/2018/01/02/单链表-vs-顺序存储.png)

#### 使用场景

* 频繁更新（插入、删除）
* 表空间未知

### 静态链表
使用「数组」实现单链表；数组有两个元素：数据+指针。

![线性表-链式存储-静态链表](/images/2018/01/01/线性表-链式存储-静态链表.png)

### 循环链表
> 循环链表：将单链表的终端结点的指针由 null 改为指向头结点，就使整个单链表形成一个环

![线性表-链式存储-循环链表-空链表](/images/2018/01/02/线性表-链式存储-循环链表-空链表.png)

![线性表-链式存储-循环链表-非空链表](/images/2018/01/02/线性表-链式存储-循环链表-非空链表.png)

### 双向链表
> 双向链表：在单链表的每个结点中，再设置一个指向其前驱结点的指针域

![线性表-链式存储-双向链表-空链表](/images/2018/01/02/线性表-链式存储-双向链表-空链表.png)

![线性表-链式存储-双向链表-非空链表](/images/2018/01/02/线性表-链式存储-双向链表-非空链表.png)

#### 操作

##### 插入元素
![线性表-链式存储-双向链表-插入](/images/2018/01/02/线性表-链式存储-双向链表-插入.png)

##### 删除元素
![线性表-链式存储-双向链表-删除](/images/2018/01/02/线性表-链式存储-双向链表-删除.png)

# 参考资料
* 《大话数据结构》
<!--以下是脚注-->
