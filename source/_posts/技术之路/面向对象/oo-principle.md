---
title: 设计原则
date: '2016-02-21 14:04'
tag:
  - OO
toc: true
---

# 前言

在面对一个复杂项目的时候，为了提高项目的 **扩展性**、 **复用性**、 **可维护性**，我们往往会进行抽象设计；而这些原则是从许多成功设计方案中总结出的指导性原则，为我们学习设计模式和设计系统提供了很好的帮助。

# 设计原则

| 设计原则名称                                           | 定义                                             | 使用频率 |
|------------------------------------------------------|--------------------------------------------------|----------|
| 开闭原则<br>(Open-Closed Principle, OCP)               | 一个软件实体对扩展开放，而对修改关闭             | ★★★★★    |
| 里氏代换原则<br>(Liskov Substitution Principle, LSP)   | 所有引用基类对象的地方能够透明地使用其子类的对象 | ★★★★★    |
| 依赖倒转原则<br>(Dependence  Inversion Principle, DIP) | 抽象不应该依赖于细节，细节应该依赖于抽象         | ★★★★★    |
| 单一职责原则<br>(Single Responsibility Principle, SRP) | 一个类只负责一个功能领域中的相应职责             | ★★★★☆    |
| 合成复用原则<br>(Composite Reuse Principle, CRP)       | 尽量使用对象组合，而不是继承来达到复用的目的     | ★★★★☆    |
| 迪米特法则<br>(Law of Demeter, LoD)                    | 一个软件实体应当尽可能少地与其他实体发生相互作用 | ★★★☆☆    |
| 接口隔离原则<br>(Interface Segregation Principle, ISP) | 使用多个专门的接口，而不使用单一的总接口         | ★★☆☆☆    |

## 开闭原则

「软件实体」可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。

**作用**

在项目的迭代过程中，出现新的需求或者需求改动时，在不修改现有代码的情况下，就可扩展新的行为。(总目标)

**如何做？**
>思考增加需求时，如何实现？

* **抽象化是开闭原则的关键**
把 **可能会发生变化的地方** （ **要对需求的变更有预见性** ）放到抽象类中，具体的实现在子类中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可。

* **避免过度使用**
遵循开闭原则，通常会引入新的抽象层次， **增加代码的复杂度**。需要把注意力集中在设计中 **最有可能改变的地方** ，然后应用开闭原则。每个地方都采用开闭原则，是一种浪费，也没必要，还会导致代码变得复杂且难以理解。

**具体实例**

* 多图表-柱状、饼状[2]

## 里氏替换原则

**作用**

里氏代换原则是实现开闭原则的重要方式之一；保证整个继承体系不被破坏。

**如何做？**
>子类不能重新定义父类的方法/属性

* **子类的所有方法必须在父类中声明**，或子类必须实现父类中声明的所有方法
* **尽量把父类设计为抽象类或者接口**，让子类继承父类或实现父接口，并实现在父类中声明的方法。（运行时，子类实例替换父类实例）

**具体实例**

* 给不同等级的客户发送邮件[3]

## 依赖倒转原则

**作用**

依赖倒转原则就是面向对象设计的主要实现机制之一；它是系统抽象化的具体实现。
依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。

**如何做？**

>要针对接口编程，而不是针对实现编程

* **传递参数时或在关联关系中，尽量引用层次高的抽象层类**；使用 **接口和抽象类** 进行变量类型声明、参数类型声明等使用继承时，遵循里氏替换原则
* **针对抽象层编程**，而将具体类的对象通过 **[依赖注入]** 的方式注入到其他对象中;[依赖注入]是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象；主要有以下三种方式：构造注入、设值注入（Setter注入）、接口注入

**具体实例**

* 存储不同格式的文件到数据库[4]

## 单一职责原则

**作用**

单一职责原则是实现 **高内聚、低耦合** 的指导方针；提高类的复用性。
当一个模块或一个类被设计成只支持一组相关功能时，我们说它具有「高内聚」。

**如何做？**
>发现类的不同职责并将其分离；一个类应该只有一个引起变化的原因

* 将不同的职责(变化原因)封装在不同的类中
* 如果多个职责总是同时发生改变则可将它们封装在同一类中
* 随着系统的成长，随时查看某个类是否超过一个变化原因,

**具体实例**

* 客户关系管理[8]

## 合成复用原则

**作用**

程序设计中，确定复用是用继承还是组合

**如何做？**
>要判断使用组合/聚合关系（关联关系）还是继承

组合/聚合
>优先考虑；两个类之间是“Has-A”的关系应使用组合或聚合；Has-A 表示某一个角色具有某一项责任

- **优点：**
    - “黑盒”复用，因为被包含对象的内部细节对外是不可见（封装性好）
    - 通过获取具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合。
- **缺点：** 对象过多，不易理解


继承
>两个类之间是“Is-A”关系可使用继承；Is-A 表示一个类是另一个类的"一种"

- **优点：** 有效使用继承会有助于对问题的理解，降低复杂度（严格遵循里氏代换原则）
- **缺点：**
    - 滥用继承反而会增加系统构建和维护的难度以及系统的复杂度
    - “白盒”复用，因为父类的内部细节对于子类而言通常是可见的。（封装性差）
    - 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性
    - 继承只能在有限的环境中使用（如类没有声明为不能被继承）

**具体实例**

* 数据保存在不同的数据库中[6]

<hr>

## 迪米特法则

**作用**
降低系统的耦合度，使类与类之间保持松散的耦合关系。

**如何做？**
>思考软件实体之间的交互；确定只和“朋友”打交道

1. 不要和“陌生人”说话、只与你的直接朋友通信；对于一个对象，其朋友包括以下几类：  
    - 当前 **对象本身** (this)；
    - **参数对象**：以参数形式传入到当前对象方法中的对象；
    - 当前对象的 **成员对象**；如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
    - 当前对象所 **创建的对象**


1. 应该尽量减少对象之间的交互
    - 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用
    - 如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用

1. 在类之间的设计上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及
1. 在单个类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限，一个类型应当尽量设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低

**具体实例**

- 一个多操作的窗口[7]

## 接口隔离原则

**作用**

系统解开耦合，从而容易重构，更改和重新部署

**如何做？**
>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来

- **接口职责要单一**
将大接口中的方法根据 **职责不同** 分别放在不同的小接口中，以确保每个接口都承担某一单一角色。

- **为不同的客户端提供宽窄不同的接口**
接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可。

注意：在使用接口隔离原则时，我们需要注意控制接口的粒度。接口太小会导致系统中接口泛滥，不利于维护；接口太大将违背接口隔离原则，灵活性较差，使用起来很不方便。

>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法

**具体实例**

- 将文件内容转为不同的数据格式存储[5]

# 总结

>不要过度使用设计模式，一切从简。

| 设计原则   | 说明            |
| ------ | ------------- |
| 开闭原则   | 对扩展开放，对修改关闭   |
| 里氏替换原则 | 不要破坏继承体系      |
| 依赖倒置原则 | 面向接口编程        |
| 单一职责原则 | 类要职责单一        |
| 接口隔离原则 | 接口要精简单一       |
| 迪米特法则  | 软件实体间要降低耦合    |
| 合成复用原则 | 复用时要合理使用继承和组合 |


设计原则之间的关系，个人总结如下：  

![oop](/images/2017/11/oop.jpg)

# 参考资料
1. [面向对象设计原则概述](http://blog.csdn.net/lovelion/article/details/7536532)
2. [面向对象设计原则之开闭原则](http://blog.csdn.net/lovelion/article/details/7537584)
3. [面向对象设计原则之里氏代换原则](http://blog.csdn.net/lovelion/article/details/7540445)
4. [面向对象设计原则之依赖倒转原则](http://blog.csdn.net/lovelion/article/details/7562783)
5. [面向对象设计原则之接口隔离原则](http://blog.csdn.net/lovelion/article/details/7562842)
6. [面向对象设计原则之合成复用原则](http://blog.csdn.net/lovelion/article/details/7563441)
7. [面向对象设计原则之迪米特法则](http://blog.csdn.net/lovelion/article/details/7563445)
8. [面向对象设计原则之单一职责原则](http://blog.csdn.net/lovelion/article/details/7536542)
