---
layout: post
title: 性能优化
date: '2017-11-17 22:20'
toc: true
tags:
  - mysql
top: 9996
---

# 优化步骤

* 第一步，完成数据库查询的优化，需要理解索引结构，才能学会判断影响结果集。而影响结果集对查询效率线性相关，掌握这一点，编写数据查询语句就很容易判断系统开销，了解业务压力趋势。
* 第二步，在SQL语句已经足够优化的基础上，学会对数据库整体状况的分析，能够对异常和负载的波动有正确的认识和解读；能够对系统资源的分配和瓶颈有正确的认识。学会通过监控和数据来进行系统的评估和优化方案设计，杜绝拍脑袋，学会抓大放小，把握要点的处理方法。
* 第三步，在彻底掌握数据库语句优化和运维优化的基础上，学会分布式架构设计，掌握复杂，大容量数据库系统的搭建方法。




# 优化SQL

## 建立慢查询优化系统
利用 [pt-query-digest](https://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html) 定期分析slow query log，并结合 [Box Anemometer](https://github.com/box/Anemometer) 构建slow query log分析及优化系统。

## SELECT
只选择自己需要的列，不要盲目的使用* ，因为不需要的列可能会导致内存 buffer pool 被这些“无效”数据把真正的热点数据给洗出去了（尤其有 text/blob 列时）

## JOIN
要把过滤性最大（不一定是数据量最小哦，而是只加了WHERE条件后过滤性最大的那个）的表选为驱动表。此外，如果JOIN之后有排序，排序字段一定要属于驱动表，才能利用驱动表上的索引完成排序。

## 排序
绝大多数情况下，排序的代价通常要来的更高，因此如果看到执行计划中有 Using filesort，优先创建排序索引吧。

## EXPLAIN

详情见：[mysql5.6 explain](http://dev.mysql.com/doc/refman/5.6/en/explain-output.html#explain-join-types)

结果解析：

| 字段名 | 值              | 说明                                                                                                                                                                                                                           |
| ------ | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| type   | ALL             | 表示预计会进行全表扫描（full table scan）。通常全表扫描的代价是比较大的，建议创建适当的索引，通过索引检索避免全表扫描。此外，全索引扫描（full index scan）的代价有时候是比全表扫描还要高的，除非是基于InnoDB表的主键索引扫描。 |
| Extra  | Using temporary | 表示需要创建临时表以满足需求，通常是因为GROUP BY的列没有索引，或者GROUP BY和ORDER BY的列不一样，也需要创建临时表，建议添加适当的索引。                                                                                         |
|        | Using filesort  | 表示无法利用索引完成排序，也有可能是因为多表连接时，排序字段不是驱动表中的字段，因此也没办法利用索引完成排序，建议添加适当的索引。                                                                                             |
|        | Using where     | 通常是因为全表扫描或全索引扫描时（type 列显示为 ALL 或 index），又加上了WHERE条件，建议添加适当的索引。                                                                                                                        |

## 查询/优化影响结果集

### 查询

- 通过 Explain 分析 SQL，查看 rows 列内容
- 通过慢查询日志的Rows_examined: 后面的数字

### 优化

核心：减少影响结果集数目

- 基于影响结果集的理解去优化，不论从数据结构，代码，还是涉及产品策略上，都需要贯彻下去。
- 涉及 limit $start,$num的搜索，如果$start巨大，则影响结果集巨大，搜索效率会非常难过低，尽量用其他方式改写为 limit 0,$num； 确系无法改写的情况下，先从索引结构中获得 limit $start,$num 或limit $start,1 ；再用in操作或基于索引序的 limit 0,$num 二次搜索。
- 避免所有锁表的情况（比如 delete 操作无索引时）

### 案例

#### 实时排行榜

**背景：** 用户提交游戏积分，显示实时排名。

**原方案：**
设置积分区间，每个区间增加数据统计字段；每次都只 count 本区间的名次，再加上前面所有区间的总和。
1. 提交积分是插入记录，略，
1. select count(*) from jifen where gameid=$gameid and fenshu>$fenshu

**问题与挑战：**
即便索引是 gameid+fenshu 复合索引，涉及count操作，当分数较低时，影响结果集巨大，查询效率缓慢，高峰期会导致连接过多。

**优化思路：**
SQL 优化
减少影响结果集，又要取得实时数据，单纯从SQL上考虑，不太有方法。

**方案1：**
逻辑优化
1. 将游戏积分预定义分成数个积分断点，然后分成积分区间，原始状态，每个区间设置一个统计数字项，初始为0。
2. 每次积分提交时，先确定该分数属于哪两个区间之间，这个操作非常简单，因为区间是预定义的，而且数量很少，只需遍历即可，找到最该分数符合的区间，该区间的统计数字项（独立字段，可用内存处理，异步回写数据库或文件）+1。 记录该区间上边界数字为$duandian。SQL:  select count(*) from jifen where gameid=$gameid and fenshu>$fenshu and fenshu<$duandian，如果处于第一区间，则无需$duandian，这样因为第一区间本身也是最好的成绩，影响结果集不会很多。 通过该SQL获得其在该区间的名次。获取前面区间的总数总和。（该数字是直接从上述提到的区间统计数字获取，不需要进行count操作）将区间内名次+前区间的统计数字和，获得总名次。

该方法关键在于，积分区间需要合理定义，保证积分提交成绩能平均散落在不同区间。（如涉及较多其他条件，如日排行，总排行，以及其他独立用户去重等，请按照影响结果集思路自行发挥。）

**方案2：**
Redis方案
Zset 有序数组结构，分两个子结构，第一是多层树形的存储结构，第二是每个树形节点的计数器，这样类似于前面的分段方式，可以理解为多层分段方式，所以查询效率更高，缺点是更新效率有所增加。

#### 大数据量翻页

**背景**：常见论坛帖子页 SQL: select * from post where tagid=$tagid order by lastpost limit $start, $end 翻页 。索引为 tagid+lastpost 复合索引

**挑战**：超级热帖，几万回帖，用户频频翻到末页，limit 25770,30 一个操作下来，影响结果集巨大(25770+30)，查询缓慢。

**方案1：**
点击页码改为上下翻页；跳转页sql改为子查询或者内连接

- 只涉及上下翻页情况
  每次查询的时候将该页查询结果中最大的 $lastpost和最小的分别记录为 $minlastpost 和 $maxlastpost ，上翻页查询为 select * from post where tagid=$tagid and lastpost<$minlastpost order by lastpost desc limit 30; 下翻页为 select * from post where tagid=$tagid and lastpost>$maxlastpost order by lastpost limit 30; 使用这种方式，影响结果集只有30条，效率极大提升。

- 涉及跳转到任意页
  互联网上常见的一个优化方案可以这样表述，select * from post where tagid=$tagid and lastpost>=(select lastpost from post where tagid=$tagid order by lastpost limit $start,1) order by lastpost limit 30; 或者 select * from post where pid in (select pid from post where tagid=$tagid order by lastpost limit $start,30); (第2条S语法在新的mysql版本已经不支持，新版本mysql in的子语句不再支持limit条件，但可以分解为两条SQL实现，原理不变，不做赘述)

以上思路在于，子查询的影响结果集仍然是$start +30，但是数据获取的过程（Sending data状态）发生在索引文件中，而不是数据表文件，这样所需要的系统开销就比前一种普通的查询低一个数量级，而主查询的影响结果集只有30条，几乎无开销。但是切记，这里仍然涉及了太多的影响结果集操作。


## 常见杀手级SQL
* SELECT * vs SELECT col1, col2
  减少磁盘 io 和网络 io

* ORDER BY RAND()
  http://imysql.com/2014/07/04/mysql-optimization-case-rand-optimize.shtml

* LIMIT huge_num, offset
  http://imysql.com/2015/04/02/mysql-optimization-case-discuz-hot-post-very-old-paging-optimizing.shtml

* SELECT COUNT(*) on InnoDB table

* WHERE func(key_col) = ? -- 无法使用索引

* WHERE key_part2 =? AND key_part3 =? -- 无法使用索引

* WHERE key_part1 > ? AND key_part2 =? -- 只能用到部分索引

* SELECT … WHERE key_col + ? = ? -- 无法使用索引

## 开启/分析慢查询

### 开启

**检查是否开启**

``` sql
show variables like '%slow%'; //0为未开启
```

**开启慢查询**
``` sh
//my.cnf 添加
[mysqld]
log_slow_queries = 日志保存位置
long_query_time=1 #超过一秒的查询保存到日志
log-queries-not-using-indexes #没有使用到索引的查询保存在日志
log-slow-admin-statements #一些管理指令，也会被记录。比如OPTIMEZE TABLE, ALTER TABLE等等。
```


### 分析
1. **mysqldumpslow**

  mysql自带,参数可–help查看
  ``` sql
  # -s：排序方式。c , t , l , r 表示记录次数、时间、查询时间的多少、返回的记录数排序；
  # ac , at , al , ar 表示相应的倒序；
  # -t：返回前面多少条的数据；
  # -g：包含什么，大小写不敏感的；
  ```

  使用案例：
  ``` sql
  mysqldumpslow -s r -t 10 /slowquery.log #slow记录最多的10个语句
  mysqldumpslow -s t -t 10 -g "left join" /slowquery.log #按照时间排序前10中含有"left join"的
  ```

1. **mysqlsla**

  github地址: [点此进入](https://github.com/daniel-nichter/hackmysql.com/tree/master/mysqlsla)

  使用案例：
  ``` sql
  // mysqlsla会自动判断日志类型，为了方便可以建立一个配置文件“~/.mysqlsla”
  // 在文件里写上：top=100，这样会打印出前100条结果。
  mysqlsla /data/mysqldata/slow.log
  ```

  结果说明
  ```
  * queries total: 总查询次数
  * unique:去重后的sql数量
  * sorted by : 输出报表的内容排序最重大的慢sql统计信息, 包括平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数.
  * Count, sql的执行次数及占总的slow log数量的百分比.
  * Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.
  * 95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.
  * Lock Time, 等待锁的时间.
  * 95% of Lock , 95%的慢sql等待锁时间.
  * Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.
  * Rows examined, 扫描的行数量.
  * Database, 属于哪个数据库
  * Users, 哪个用户,IP, 占到所有用户执行的sql百分比
  * Query abstract, 抽象后的sql语句
  * Query sample, sql语句
  ```





## 优化索引

1. 定期检查并删除重复的索引
  用 pt-duplicate-key-checker 工具
  比如 index idx1(a, b) 索引已经涵盖了 index idx2(a)，就可以删除 idx2 索引了。

1. 索引量
  基于索引的条件过滤，如果优化器意识到总共需要扫描的数据量超过 **30%** 时，就会直接改变执行计划为全表扫描，不再使用索引。

1. 联合索引
  WHERE中过滤条件的字段顺序和索引 **无需一致**
  排序、分组则就 **必须一致**

1. 合理利用覆盖索引，但字段尽量不超过5个

1. 合理利用最左索引（前缀索引/部分索引）

1. 及时删除冗余索引

1. 索引字段条件不使用函数

1. 内存表(HEAP 表)使用HASH索引时，不能使用范围检索或者ORDER BY等，只能使用=或者!=

1. 两个独立索引，其中一个用于检索，一个用于排序 -- 只能用到其中一个索引，5.6以上有ICP特性
  优化器判断使用哪个索引

1. 表关联字段类型要一样（也包括长度一样），否则会有类型隐式转换


# 数据库优化
## 内存优化

注意内存的使用优化：[系统与软件->内存使用考量]()

## 查看/分析资源消耗

**SHOW PROFILE 和 SHOW PROFILES**

### 说明

1. 作用域是会话级；
1. SHOW PROFILES显示最近发给服务器的多条语句，条数根据会话变量profiling_history_size定义，默认是15，最大值为100。设为0等价于关闭分析功能。
1. **默认是关闭**；其是否启用是根据会话级的变量profiling
1. mysql5.7以后不建议使用SHOW PROFILE指令，或直接从INFORMATION_SCHEMA.PROFILING中查看，建议利用PERFORMANCE_SCHEMA中的几个视图查看。（因为会被废弃）

### 开启

``` sql
mysql> SET profiling=1;或 SET profiling=on;
```

### 关闭

```sql
mysql> SET profiling=0;或 SET profiling=off;
```

### 用法

``` sql
SHOW PROFILE [type [, type] … ][FOR QUERY n][LIMIT row_count [OFFSET offset]]
```

type是可选的，取值范围可以如下：
- ALL 显示所有性能信息
- BLOCK IO 显示块IO操作的次数
- CONTEXT SWITCHES 显示上下文切换次数，不管是主动还是被动
- CPU 显示用户CPU时间、系统CPU时间
- IPC 显示发送和接收的消息数量
- MEMORY [暂未实现]
- PAGE FAULTS 显示页错误数量
- SOURCE 显示源码中的函数名称与位置
- SWAPS 显示SWAP的次数


SHOW PROFILE FOR QUERY n，这里的n就是对应SHOW PROFILES输出中的Query_ID。
如果没有指定FOR QUERY，那么输出最近一条语句的信息。


`SHOW PROFILE ALL FOR QUERY 2` 的信息还可以通过`SELECT * FROM information_schema.profiling WHERE query_id = 2 ORDER BY seq;`获取。

参考：
http://dev.mysql.com/doc/refman/5.5/en/show-profile.html

## 查看执行状态

### 查看命令

``` sql
SHOW [FULL] PROCESSLIST
```

SHOW PROCESSLIST显示哪些线程正在运行。您也可以使用mysqladmin processlist语句得到此信息。如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程（也就是，与您正在使用的MySQL账户相关的线程）。如果您不使用FULL关键词，则只显示每个查询的前100个字符。

### Command
官方文档：https://dev.mysql.com/doc/refman/5.6/en/thread-commands.html

* Sleep
  通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内

  实例:因前端数据输出时（特别是输出到用户终端）未及时关闭数据库连接，导致因网络连接速度产生大量sleep连接，在网速出现异常时，数据库 too many connections挂死。

  简单解读，数据查询和执行通常只需要不到0.01秒，而网络输出通常需要1秒左右甚至更长，原本数据连接在0.01秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在 结果未展现在用户桌面前，该数据库连接一直维持在sleep状态！

* Waiting for net / reading from net / writing to net
  偶尔出现无妨，如大量出现，迅速检查数据库到前端的网络连接状态和流量
  Reading from net 表示server端正通过网络读取客户端发送过来的请求建议：减小客户端发送数据包大小，提高网络带宽/质量
  Writing to net通过网络传输数据

  案例: 因外挂程序，内网数据库大量读取，内网使用的百兆交换迅速爆满，导致大量连接阻塞在waiting for net，数据库连接过多崩溃

* Locked
  有更新操作锁定，通常使用innodb可以很好的减少locked状态的产生，但是切记，更新操作要正确使用索引，即便是低频次更新操作也不能疏忽。如上影响结果集范例所示。
  在myisam的时代，locked是很多高并发应用的噩梦。所以mysql官方也开始倾向于推荐innodb。

* Copy to tmp table
  索引及现有结构无法涵盖查询条件，才会建立一个临时表来满足查询要求，产生巨大的恐怖的i/o压力。
  很可怕的搜索语句会导致这样的情况，如果是数据分析，或者半夜的周期数据清理任务，偶尔出现，可以允许。频繁出现务必优化之。
  执行ALTER TABLE修改表结构时建议：放在凌晨执行或者采用类似pt-osc工具
  通常与连表查询有关，建议逐渐习惯不使用连表查询。

  实战范例：某社区数据库阻塞，求救，经查，其服务器存在多个数据库应用和网站，其中一个不常用的小网站数据库产生了一个恐怖的copy to tmp table 操作，导致整个硬盘i/o和cpu压力超载。Kill掉该操作一切恢复。

* Copying to tmp table
  拷贝数据到内存中的临时表，常见于GROUP BY操作时,建议：创建适当的索引

* Copying to tmp table on disk
  临时结果集太大，内存中放不下，需要将内存中的临时表拷贝到磁盘上，形成 `*sql.MYD`、`*sql.MYI`（在5.6及更高的版本，临时表可以改成InnoDB引擎了，可以参考选项default_tmp_storage_engine）建议：创建适当的索引，并且适当加大sort_buffer_size/tmp_table_size/max_heap_table_size

* Creating sort index
  当前的SELECT中需要用到临时表在进行ORDER BY排序，建议：创建适当的索引

* Sending data
  并不是发送数据，别被这个名字所欺骗，这是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，
  偶尔出现该状态连接无碍。回到上面影响结果集的问题，一般而言，如果sending data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化。
  前文提到影响结果集对SQL查询效率线性相关，主要就是针对这个状态的系统开销。
  如果出现大量相似的SQL语句出现在show proesslist列表中，并且都处于sending data状态，优化查询索引，记住用影响结果集的思路去思考。
  从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见备注：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net

  建议：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量

* Creating tmp table
  创建基于内存或磁盘的临时表，当从内存转成磁盘的临时表时，状态会变成：Copying to tmp table on disk
  建议：创建适当的索引，或者少用UNION、视图(VIEW)、子查询(SUBQUERY)之类的，确实需要用到临时表的时候，可以在session级临时适当调大 tmp_table_size/max_heap_table_size 的值

* Storing result to query cache
  出现这种状态，如果频繁出现，使用set profiling分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query cache碎片较多
  使用flush query cache 可即时清理，也可以做成定时任务
  Query cache参数可适当酌情设置。

* Freeing items
  理论上这玩意不会出现很多。偶尔出现无碍
  如果大量出现，内存，硬盘可能已经出现问题。比如硬盘满或损坏。
  i/o压力过大时，也可能出现Free items执行时间较长的情况。

* Sorting for …
  和Sending data类似，结果集过大，排序条件没有索引化，需要在内存里排序，甚至需要创建临时结构排序。

* Sorting result
  正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序建议：创建适当的索引

* statistics
  进行数据统计以便解析执行计划，如果状态比较经常出现，有可能是磁盘IO性能很差建议：查看当前io性能状态，例如iowait

* Waiting for global read lock
  FLUSH TABLES WITH READ LOCK整等待全局读锁
  建议：不要对线上业务数据库加上全局读锁，通常是备份引起，可以放在业务低谷期间执行或者放在slave服务器上执行备份

* Waiting for tables,Waiting for table flush
  FLUSH TABLES, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, OPTIMIZE TABLE等需要刷新表结构并重新打开
  建议：不要对线上业务数据库执行这些操作，可以放在业务低谷期间执行

* Waiting for lock_type lock
  等待各种类型的锁：
  - Waiting for event metadata lock
  - Waiting for global read lock
  - Waiting for schema metadata lock
  - Waiting for stored function metadata lock
  - Waiting for stored procedure metadata lock
  - Waiting for table level lock
  - Waiting for table metadata lock
  - Waiting for trigger metadata lock

  建议：比较常见的是上面提到的global read lock以及table metadata lock，建议不要对线上业务数据库执行这些操作，可以放在业务低谷期间执行。如果是table level lock，通常是因为还在使用MyISAM引擎表，赶紧转投InnoDB引擎吧，别再老顽固了

### State
官方文档:http://dev.mysql.com/doc/refman/5.6/en/general-thread-states.html

* After create
  当线程创建表（包括临时表）

* Analyzing
  线程正在分析MYISAM的key分布

* checking permissions
  线程正在检查执行语句的权限

* Checking table
  线程正在执行表check操作

* Cleaning up
  线程已经处理完一个命令然后开始准备释放内存和reset状态变量

* Closing tables
  线程把改变的表数据flush到磁盘然后关闭使用的表。这个操作应该是很快的，如果这个状态长时间出现，要留意检查磁盘的状态。

* Converting HEAP to MyISAM
  把一个内存中的临时表转换到磁盘上的MYISAM表

* Copy to tmp table
  线程执行alter table语句。这个状态出现在新的表结构已经创建但数据还在拷贝到新表之前。

* Copying to group table
  如果一个语句的group by和order by 条件不同，数据通过group by来排序然后拷贝到临时表

* Copying to tmp table
  拷贝到内存中的临时表

* Copying to tmp table on disk
  如果临时表过大，服务器要把内存中的临时表拷贝到磁盘。

* Creating index
  对一个MYISAM 执行ALTER TABLE … ENABLE KEYS

* Creating sort index
  线程通过执行一个临时表来执行select语句

* Creating table
  线程正在创建表（包括临时表）

* Creating tmp table
  创建临时表（在内存或者磁盘）上，如果表一开始在内存中到后面太大，临时表就会转换到磁盘上，而且状态也会变成Copying to tmp table on disk

* deleting from main table
  服务器正在执行一个多表delete语句的第一部分，也就是从第一张表删除数据，并且保留行以及偏移量数据以用来删除其他表中的数据。

* deleting from reference tables
  服务器正在执行一个多表delete语句的二部分

* discard_or_import_tablespace
  线程正在执行ALTER TABLE … DISCARD TABLESPACE 或者ALTER TABLE … IMPORT TABLESPACE 语句.

* end
  这个状态出现在ALTER TABLE, CREATE VIEW, DELETE, INSERT, SELECT, UPDATE语句结束之后，但在清理以前。

* executing
  线程开始执行一个语句

* Execution of init_command
  线程在init_command系统变量中执行语句

* freeing items
  线程已经执行命令。一些释放

* Flushing tables
  这个线程执行了FLUSH TABLES，而且等待所有的线程关闭表

* FULLTEXT initialization
  服务器准备执行文本搜索

* Killed
  发送了kill 语句给这个查询。这个语句在下次检查kill标志的时候，这个语句就应该放弃掉

* Locked
  查询被其他的查询锁住了

* logging slow query
  线程正在把慢sql写到慢查询log文件中

* login
  直到线程授权成功以前都是这个状态

* manage keys
  服务器正在管理表的索引

* Opening tables, Opening table
  线程正在打开表。这个操作是很快的，除非有其他原因阻止了打开操作，例如ALTER TABLE   LOCK TABLE

* optimizing
  服务器正在进行一个查询的初始阶段优化

* preparing
  正在进行查询优化

* Purging old relay logs
  线程删除不需要的relay log文件

* query end
  这个状态出现在处理完以后但在冻结item之前

* Reading from net
  服务器从网络读取包

* Removing duplicates
  查询使用了select distinct。mysq在发送数据到客户端之前需要一个额外的过程来删除重复的行

* removing tmp table
  在执行了select语句以后，线程正在删除内部的临时表

* rename
  线程正在重命名表

* rename result table
  线程正在执行一个alter table语句，而且已经创建了新表，对新表重命名来替换原始表。

* Reopen tables
  线程获取了一个表的锁。由于它已经得知它依赖的表结构已经发生了变化。线程需要释放锁、关闭表、然后尝试重新打开他。

* Repair by sorting
  修复代码通过排序来创建索引。

* Repair done
  线程完成了对一个myisam表的多线程修复。

* Repair with keycache
  修复代码正在通过key的缓存创建key。

* Rolling back
  线程正在回滚事物。

* Saving state
  myisam的analysis和repair操作中，线程会把表的一些信息例如表的行数、AUTO_INCREMENT的计数器以及key的分布都保存到.MYI文件的头部

* Searching rows for update
  语句执行的第一个阶段，找到所有满足条件的行记录

* Sending data
  线程在读取和处理SELECT语句，发送数据到客户端。由于语句需要大量的磁盘访问，这个状态会在语句的整个生命周期中占据最长的一个状态。

* setup
  线程开始进行ALTER TABLE 语句

* Sorting for group
  线程正在为group by 执行排序

* Sorting for order
  线程正在为order by 执行排序

* Sorting index
  在myisam表的优化操作中，进行索引页的排序以便获得更好的访问性能。

* Sorting result
  对结果进行排序

* Statistics
  服务器正在计算统计数据从而来生成一个执行计划。如果一个线程保留这个状态很长的时间，意味着服务器在执行其他的磁盘相关的工作。

* System lock
  线程正在请求和获取一个内部和外部锁。如果有这个状态

* Table lock
  System Lock后的另一个线程状态。线程已经获取了一个外部锁，然后接下来要去获取一个内部表锁。

* update
  线程已经准备好去更新

* Updating
  现在正在找或者正在更新行

* updating main table
  服务器正在执行一个多表update语句，正在更新第一张表，保存行和偏移量以用来更新其他表。

* updating reference tables
  服务器正在执行一个多表update语句的第二部分，正在从其他表更新行

* User lock
  请求或者等待获取一个锁

* User sleep
  线程sleep

* Waiting for release of readlock
  等待一个全局的读锁

* Waiting for tables, Waiting for table
  线程获得提示依赖的表结构发生了改变，线程需要重新打开表来获取新的结构。但是，重新打开表是需要等待其他的线程关闭表。

* Waiting on cond
  线程正在等条件变成true

* Waiting to get readlock
  线程用FLUSH TABLES WITH READ LOCK语句，所以要获得一个全局的读锁，这个状态表示正在等这个锁。

* Writing to net
  服务器把包写到网络

## 查看mysql状态


### show status 与 show global status 区别
status：当前连接的状态（当前会话/连接）
global status：mysql 启动后到目前的状态（全局会话）

### show status 详解

官方文档：http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html

| 状态名   | 作用域  | 详细解释   |
|-----------|---------|-----|
| Aborted\_clients                       | Global  | 由于客户端没有正确关闭连接导致客户端终止而中断的连接数                                                                                                                                             |
| Aborted\_connects                      | Global  | 试图连接到MySQL服务器而失败的连接数                                                                                                                                                                |
| Binlog\_cache\_disk\_use               | Global  | 使用临时二进制日志缓存但超过binlog\_cache\_size值并使用临时文件来保存事务中的语句的事务数量                                                                                                        |
| Binlog\_cache\_use                     | Global  | 使用临时二进制日志缓存的事务数量                                                                                                                                                                   |
| Bytes\_received                        | Both    | 从所有客户端接收到的字节数。                                                                                                                                                                       |
| Bytes\_sent                            | Both    | 发送给所有客户端的字节数。                                                                                                                                                                         |
| com\*                                  |         | 各种数据库操作的数量                                                                                                                                                                               |
| Compression                            | Session | 客户端与服务器之间只否启用压缩协议                                                                                                                                                                 |
| Connections                            | Global  | 试图连接到(不管是否成功)MySQL服务器的连接数                                                                                                                                                        |
| Created\_tmp\_disk\_tables             | Both    | 服务器执行语句时在硬盘上自动创建的临时表的数量                                                                                                                                                     |
| Created\_tmp\_files                    | Global  | mysqld已经创建的临时文件的数量                                                                                                                                                                     |
| Created\_tmp\_tables                   | Both    | 服务器执行语句时自动创建的内存中的临时表的数量。如果Created\_tmp\_disk\_tables较大，你可能要增加tmp\_table\_size值使临时表基于内存而不基于硬盘                                                     |
| Delayed\_errors                        | Global  | 用INSERT DELAYED写的出现错误的行数(可能为duplicate key)。                                                                                                                                          |
| Delayed\_insert\_threads               | Global  | 使用的INSERT DELAYED处理器线程数。                                                                                                                                                                 |
| Delayed\_writes                        | Global  | 写入的INSERT DELAYED行数                                                                                                                                                                           |
| Flush\_commands                        | Global  | 执行的FLUSH语句数。                                                                                                                                                                                |
| Handler\_commit                        | Both    | 内部提交语句数                                                                                                                                                                                     |
| Handler\_delete                        | Both    | 行从表中删除的次数。                                                                                                                                                                               |
| Handler\_discover                      | Both    | MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler\_discover说明通过该方法发现的次数。                                                                                |
| Handler\_prepare                       | Both    | A counter for the prepare phase of two-phase commit operations.                                                                                                                                    |
| Handler\_read\_first                   | Both    | 索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引。                                                                                   |
| Handler\_read\_key                     | Both    | 根据键读一行的请求数。如果较高，说明查询和表的索引正确。                                                                                                                                           |
| Handler\_read\_next                    | Both    | 按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。                                                                                                             |
| Handler\_read\_prev                    | Both    | 按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。                                                                                                                                |
| Handler\_read\_rnd                     | Both    | 根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。                                                  |
| Handler\_read\_rnd\_next               | Both    | 在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。                                                                               |
| Handler\_rollback                      | Both    | 内部ROLLBACK语句的数量。                                                                                                                                                                           |
| Handler\_savepoint                     | Both    | 在一个存储引擎放置一个保存点的请求数量。                                                                                                                                                           |
| Handler\_savepoint\_rollback           | Both    | 在一个存储引擎的要求回滚到一个保存点数目。                                                                                                                                                         |
| Handler\_update                        | Both    | 在表内更新一行的请求数。                                                                                                                                                                           |
| Handler\_write                         | Both    | 在表内插入一行的请求数。                                                                                                                                                                           |
| Innodb\_buffer\_pool\_pages\_data      | Global  | 包含数据的页数(脏或干净)。                                                                                                                                                                         |
| Innodb\_buffer\_pool\_pages\_dirty     | Global  | 当前的脏页数。                                                                                                                                                                                     |
| Innodb\_buffer\_pool\_pages\_flushed   | Global  | 要求清空的缓冲池页数                                                                                                                                                                               |
| Innodb\_buffer\_pool\_pages\_free      | Global  | 空页数。                                                                                                                                                                                           |
| Innodb\_buffer\_pool\_pages\_latched   | Global  | 在InnoDB缓冲池中锁定的页数。这是当前正读或写或由于其它原因不能清空或删除的页数。                                                                                                                   |
| Innodb\_buffer\_pool\_pages\_misc      | Global  | 忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。该值还可以计算为Innodb\_buffer\_pool\_pages\_total - Innodb\_buffer\_pool\_pages\_free - Innodb\_buffer\_pool\_pages\_data。 |
| Innodb\_buffer\_pool\_pages\_total     | Global  | 缓冲池总大小（页数）。                                                                                                                                                                             |
| Innodb\_buffer\_pool\_read\_ahead\_rnd | Global  | InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。                                                                                                                        |
| Innodb\_buffer\_pool\_read\_ahead\_seq | Global  | InnoDB初始化的顺序read-aheads数。当InnoDB执行顺序全表扫描时发生。                                                                                                                                  |
| Innodb\_buffer\_pool\_read\_requests   | Global  | InnoDB已经完成的逻辑读请求数。                                                                                                                                                                     |
| Innodb\_buffer\_pool\_reads            | Global  | 不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。                                                                                                                                                 |
| Innodb\_buffer\_pool\_wait\_free       | Global  | 一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。                   |
| Innodb\_buffer\_pool\_write\_requests  | Global  | 向InnoDB缓冲池的写数量。                                                                                                                                                                           |
| Innodb\_data\_fsyncs                   | Global  | fsync()操作数。                                                                                                                                                                                    |
| Innodb\_data\_pending\_fsyncs          | Global  | 当前挂起的fsync()操作数。                                                                                                                                                                          |
| Innodb\_data\_pending\_reads           | Global  | 当前挂起的读数。                                                                                                                                                                                   |
| Innodb\_data\_pending\_writes          | Global  | 当前挂起的写数。                                                                                                                                                                                   |
| Innodb\_data\_read                     | Global  | 至此已经读取的数据数量（字节）。                                                                                                                                                                   |
| Innodb\_data\_reads                    | Global  | 数据读总数量。                                                                                                                                                                                     |
| Innodb\_data\_writes                   | Global  | 数据写总数量。                                                                                                                                                                                     |
| Innodb\_data\_written                  | Global  | 至此已经写入的数据量（字节）。                                                                                                                                                                     |
| Innodb\_dblwr\_pages\_written          | Global  | 已经执行的双写操作数量                                                                                                                                                                             |
| Innodb\_dblwr\_writes                  | Global  | 双写操作已经写好的页数                                                                                                                                                                             |
| Innodb\_log\_waits                     | Global  | 我们必须等待的时间，因为日志缓冲区太小，我们在继续前必须先等待对它清空                                                                                                                             |
|                                        |         |                                                                                                                                                                                                    |
| Innodb\_log\_write\_requests           | Global  | 日志写请求数。                                                                                                                                                                                     |
| Innodb\_log\_writes                    | Global  | 向日志文件的物理写数量。                                                                                                                                                                           |
| Innodb\_os\_log\_fsyncs                | Global  | 向日志文件完成的fsync()写数量。                                                                                                                                                                    |
| Innodb\_os\_log\_pending\_fsyncs       | Global  | 挂起的日志文件fsync()操作数量。                                                                                                                                                                    |
| Innodb\_os\_log\_pending\_writes       | Global  | 挂起的日志文件写操作                                                                                                                                                                               |
| Innodb\_os\_log\_written               | Global  | 写入日志文件的字节数。                                                                                                                                                                             |
| Innodb\_page\_size                     | Global  | 编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。                                                                                                                         |
| Innodb\_pages\_created                 | Global  | 创建的页数。                                                                                                                                                                                       |
| Innodb\_pages\_read                    | Global  | 读取的页数。                                                                                                                                                                                       |
| Innodb\_pages\_written                 | Global  | 写入的页数。                                                                                                                                                                                       |
| Innodb\_row\_lock\_current\_waits      | Global  | 当前等待的待锁定的行数。                                                                                                                                                                           |
| Innodb\_row\_lock\_time                | Global  | 行锁定花费的总时间，单位毫秒。                                                                                                                                                                     |
| Innodb\_row\_lock\_time\_avg           | Global  | 行锁定的平均时间，单位毫秒。                                                                                                                                                                       |
| Innodb\_row\_lock\_time\_max           | Global  | 行锁定的最长时间，单位毫秒。                                                                                                                                                                       |
| Innodb\_row\_lock\_waits               | Global  | 一行锁定必须等待的时间数。                                                                                                                                                                         |
| Innodb\_rows\_deleted                  | Global  | 从InnoDB表删除的行数。                                                                                                                                                                             |
| Innodb\_rows\_inserted                 | Global  | 插入到InnoDB表的行数。                                                                                                                                                                             |
| Innodb\_rows\_read                     | Global  | 从InnoDB表读取的行数。                                                                                                                                                                             |
| Innodb\_rows\_updated                  | Global  | InnoDB表内更新的行数。                                                                                                                                                                             |
| Key\_blocks\_not\_flushed              | Global  | 键缓存内已经更改但还没有清空到硬盘上的键的数据块数量。                                                                                                                                             |
| Key\_blocks\_unused                    | Global  | 键缓存内未使用的块数量。你可以使用该值来确定使用了多少键缓存                                                                                                                                       |
| Key\_blocks\_used                      | Global  | 键缓存内使用的块数量。该值为高水平线标记，说明已经同时最多使用了多少块。                                                                                                                           |
| Key\_read\_requests                    | Global  | 从缓存读键的数据块的请求数。                                                                                                                                                                       |
| Key\_reads                             | Global  | 从硬盘读取键的数据块的次数。如果Key\_reads较大，则Key\_buffer\_size值可能太小。可以用Key\_reads/Key\_read\_requests计算缓存损失率。                                                                |
| Key\_write\_requests                   | Global  | 将键的数据块写入缓存的请求数。                                                                                                                                                                     |
| Key\_writes                            | Global  | 向硬盘写入将键的数据块的物理写操作的次数。                                                                                                                                                         |
| Last\_query\_cost                      | Session | 用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。默认值是0。Last\_query\_cost具有会话范围。                                              |
| Max\_used\_connections                 | Global  | 服务器启动后已经同时使用的连接的最大数量。                                                                                                                                                         |
| ndb*                                   |         | ndb集群相关                                                                                                                                                                                        |
| Not\_flushed\_delayed\_rows            | Global  | 等待写入INSERT DELAY队列的行数。                                                                                                                                                                   |
| Open\_files                            | Global  | 打开的文件的数目。                                                                                                                                                                                 |
| Open\_streams                          | Global  | 打开的流的数量(主要用于记录)。                                                                                                                                                                     |
| Open\_table\_definitions               | Global  | 缓存的.frm文件数量                                                                                                                                                                                 |
| Open\_tables                           | Both    | 当前打开的表的数量。                                                                                                                                                                               |
| Opened\_files                          | Global  | 文件打开的数量。不包括诸如套接字或管道其他类型的文件。 也不包括存储引擎用来做自己的内部功能的文件。                                                                                                |
| Opened\_table\_definitions             | Both    | 已经缓存的.frm文件数量                                                                                                                                                                             |
| Opened\_tables                         | Both    | 已经打开的表的数量。如果Opened\_tables较大，table\_cache 值可能太小。                                                                                                                              |
| Prepared\_stmt\_count                  | Global  | 当前的预处理语句的数量。(最大数为系统变量: max\_prepared\_stmt\_count)                                                                                                                             |
| Qcache\_free\_blocks                   | Global  | 查询缓存内自由内存块的数量。                                                                                                                                                                       |
| Qcache\_free\_memory                   | Global  | 用于查询缓存的自由内存的数量。                                                                                                                                                                     |
| Qcache\_hits                           | Global  | 查询缓存被访问的次数。                                                                                                                                                                             |
| Qcache\_inserts                        | Global  | 加入到缓存的查询数量。                                                                                                                                                                             |
| Qcache\_lowmem\_prunes                 | Global  | 由于内存较少从缓存删除的查询数量。                                                                                                                                                                 |
| Qcache\_not\_cached                    | Global  | 非缓存查询数(不可缓存，或由于query\_cache\_type设定值未缓存)。                                                                                                                                     |
| Qcache\_queries\_in\_cache             | Global  | 登记到缓存内的查询的数量。                                                                                                                                                                         |
| Qcache\_total\_blocks                  | Global  | 查询缓存内的总块数。                                                                                                                                                                               |
| Queries                                | Both    | 服务器执行的请求个数，包含存储过程中的请求。                                                                                                                                                       |
| Questions                              | Both    | 已经发送给服务器的查询的个数。                                                                                                                                                                     |
| Rpl\_status                            | Global  | 失败安全复制状态(还未使用)。                                                                                                                                                                       |
| Select\_full\_join                     | Both    | 没有使用索引的联接的数量。如果该值不为0,你应仔细检查表的索引                                                                                                                                       |
| Select\_full\_range\_join              | Both    | 在引用的表中使用范围搜索的联接的数量。                                                                                                                                                             |
| Select\_range                          | Both    | 在第一个表中使用范围的联接的数量。一般情况不是关键问题，即使该值相当大。                                                                                                                           |
| Select\_range\_check                   | Both    | 在每一行数据后对键值进行检查的不带键值的联接的数量。如果不为0，你应仔细检查表的索引。                                                                                                              |
| Select\_scan                           | Both    | 对第一个表进行完全扫描的联接的数量。                                                                                                                                                               |
| Slave\_heartbeat\_period               | Global  | 复制的心跳间隔                                                                                                                                                                                     |
| Slave\_open\_temp\_tables              | Global  | 从服务器打开的临时表数量                                                                                                                                                                           |
| Slave\_received\_heartbeats            | Global  | 从服务器心跳数                                                                                                                                                                                     |
| Slave\_retried\_transactions           | Global  | 本次启动以来从服务器复制线程重试次数                                                                                                                                                               |
| Slave\_running                         | Global  | 如果该服务器是连接到主服务器的从服务器，则该值为ON。                                                                                                                                               |
| Slow\_launch\_threads                  | Both    | 创建时间超过slow\_launch\_time秒的线程数。                                                                                                                                                         |
| Slow\_queries                          | Both    | 查询时间超过long\_query\_time秒的查询的个数。                                                                                                                                                      |
| Sort\_merge\_passes                    | Both    | 排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort\_buffer\_size系统变量的值。                                                                                                       |
| Sort\_range                            | Both    | 在范围内执行的排序的数量。                                                                                                                                                                         |
| Sort\_rows                             | Both    | 已经排序的行数。                                                                                                                                                                                   |
| Sort\_scan                             | Both    | 通过扫描表完成的排序的数量。                                                                                                                                                                       |
| ssl＊                                  |         | ssl连接相关                                                                                                                                                                                        |
| Table\_locks\_immediate                | Global  | 立即获得的表的锁的次数。                                                                                                                                                                           |
| Table\_locks\_waited                   | Global  | 不能立即获得的表的锁的次数。如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。                                                                                                 |
| Threads\_cached                        | Global  | 线程缓存内的线程的数量。                                                                                                                                                                           |
| Threads\_connected                     | Global  | 当前打开的连接的数量。                                                                                                                                                                             |
| Threads\_created                       | Global  | 创建用来处理连接的线程数。如果Threads\_created较大，你可能要增加thread\_cache\_size值。缓存访问率的计算方法Threads\_created/Connections。                                                          |
| Threads\_running                       | Global  | 激活的（非睡眠状态）线程数。                                                                                                                                                                       |
| Uptime                                 | Global  | 服务器已经运行的时间（以秒为单位）。                                                                                                                                                               |
| Uptime\_since\_flush\_status           | Global  | 最近一次使用FLUSH STATUS的时间（以秒为单位）。                                                                                                                                                     |

<!--以下是脚注-->
