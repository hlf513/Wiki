---
layout: post
title: 分析问题
date: '2017-11-17 10:15'
toc: true
tags:
  - mysql
top: 9997
---

# 基本认识

- 要学会怎样分析问题，而不是单纯拍脑袋优化
- 慢查询只是最基础的东西，要学会优化0.01秒的查询请求。
- 当发生连接阻塞时，不同状态的阻塞有不同的原因，要找到原因，如果不对症下药，就会南辕北辙
  - 范例：如果本身系统内存已经超载，已经使用到了swap，而还在考虑加大缓存来优化查询，那就是自寻死路了。
- 影响结果集是非常重要的中间数据和优化指标，学会理解这一概念，理论上影响结果集与查询效率呈现非常紧密的线性相关。
- 监测与跟踪要经常做，而不是出问题才做
  - 读取频繁度抽样监测
    - 全监测不要搞，i/o吓死人。
    - 按照一个抽样比例抽样即可。
    - 针对抽样中发现的问题，可以按照特定SQL在特定时间内监测一段全查询记录，但仍要考虑i/o影响。
  - 写入频繁度监测
    - 基于binlog解开即可，可定时或不定时分析。
  - 微慢查询抽样监测
    - 高并发情况下，查询请求时间超过0.01秒甚至0.005秒的，建议酌情抽样记录。
  - 连接数预警监测
    - 连接数超过特定阈值的情况下，虽然数据库没有崩溃，建议记录相关连接状态。
- 学会通过数据和监控发现问题，分析问题，而后解决问题顺理成章。特别是要学会在日常监控中发现隐患，而不是问题爆发了才去处理和解决。


# 常见关注的重点

## 慢查询日志

- 是否锁定，及锁定时间
  如存在锁定，则该慢查询通常是因锁定因素导致，本身无需优化，需解决锁定问题。

- 影响结果集
  如影响结果集较大，显然是索引项命中存在问题，需要认真对待。

## Explain 操作

- 索引项使用
  不建议用using index做强制索引，如未如预期使用索引，建议重新斟酌表结构和索引设置。

- 影响结果集
  这里显示的数字不一定准确，结合之前提到对数据索引的理解来看，还记得嘛？就把索引当作有序序列来理解，反思SQL。

## Set profiling , show profiles for query操作

- 执行开销
  - 注意，有问题的SQL如果重复执行，可能在缓存里，这时要注意避免缓存影响。通过这里可以看到。
  - 执行时间超过0.005秒的频繁操作SQL建议都分析一下。
  - 深入理解数据库执行的过程和开销的分布

## Show processlist 执行状态监控

这是在数据库负载波动时经常进行的一项操作
具体参见：[查看执行状态](/技术之路/数据库/Mysql/优化/#执行状态)

# 排查步骤

## 确认问题

**详细了解问题状况**
- Too many connections 是常见表象，有很多种原因。
- 索引损坏的情况在innodb情况下很少出现。
- 如出现其他情况应追溯日志和错误信息。

## 确认瓶颈

**常见的瓶颈**

- cpu 非常高--索引问题 or 并发太高（通常是索引问题）
  并发问题：thread_pool 限制连接数（其他分支都支持线程池）

- 内存 swap高 -- 内存分配不足（过多会 oom）
  适量调整内存，不要太大也不要太小，50%-70%比较保守，80%太偏激，尽量覆盖全部热点数据
  mysql 专用服务器，关闭 swap

- iowait 太高 -- 内存不足 or io 设备性能太低 or 索引不当 or 频繁读取 select  or 频繁排序/分组

### 了解基本运营状况

- 当前每秒读请求
- 当前每秒写请求
- 当前在线用户
- 当前数据容量

### 了解基本负载情况

学会使用这些指令
  - Top --系统状态，哪个服务/进程消耗的 cpu 、内存
  - Vmstat -- 查看 cpu、io、内存负载
  - dstat -- 和 vmstat 类似，结果更友好
  - sar -- systat 工具包的一个命令；关注（sar  -u / -d / -r）cpu/io/内存
  - iotop -- 查看哪个进程 io 消耗最高
  - oprofile -- 神器，一般用不上，用法自己查
  - strace -- 跟踪进程执行时的系统调用和所接收的信号
  - uptime
  - iostat
  - df

Cpu负载构成
  - 特别关注i/o压力( wa%)
  - 多核负载分配

内存占用
  - Swap分区是否被侵占，若Swap分区被侵占，物理内存是否较多空闲

磁盘状态
  - 硬盘满和inode节点满的情况要迅速定位和迅速处理

### 查看 mysql 的状态

**当前连接数**
  - Netstat –an|grep 3306|wc –l
  - Show processlist

**当前连接分布 show processlist**
  - 前端应用请求数据库不要使用root帐号！
    - Root帐号比其他普通帐号多一个连接数许可。
    - 前端使用普通帐号，在too many connections的时候root帐号仍可以登录数据库查询 show processlist!
    - 记住，前端应用程序不要设置一个不叫root的root帐号来糊弄！非root账户是骨子里的，而不是名义上的。
  - 状态分布
    - 不同状态代表不同的问题，有不同的优化目标。
  - 雷同SQL的分布
    - 是否较多雷同SQL出现在同一状态

**当前是否有较多慢查询日志**
  - 是否锁定
  - 影响结果集

**常用命令**
- slow log
  优先频次高，其次耗时久

- show global status
  1. 查看连接数（活跃、不活跃），设置 interactive_timeout、wait_timeout 的 timecount值，减少不活跃连接
  1. TPS、QPS、DML_Active
    - tps=(handler_commit_d+handler_rollback_d)/uptime_d
    - qps=(questions_d2 - questions_d1)/uptime_d
    - dml_active=(com_select_d+com_insert_d+com_update_d+com_delete_d)/uptime_d
  1. 各种 buffer、cache 的利用率、命中率
    - innodb_buffer_pool_wait_free>0 说明 innodb_buffer 不够用,有 wait、wait_free 发生，都要关注下
    - innodb_row_lock_current_waits 当前行锁的个数
    - slow_queries 慢查询的次数
    - table_locks_immediate 表锁的次数
    - table_locks_waited 表锁等待的次数
- show processlist

- show engine innodb status
  主要看锁，事务，等待

- pt-ioprofile
  可以查看哪个表在频繁的读写

### 频繁度分析

- 写频繁度
  - 如果i/o压力高，优先分析写入频繁度
  - Mysqlbinlog 输出最新binlog文件，编写脚本拆分
  - 最多写入的数据表是哪个
  - 最多写入的数据SQL是什么
  - 是否存在基于同一主键的数据内容高频重复写入？
    - 涉及架构优化部分，参见架构优化-缓存异步更新
- 读取频繁度
  - 如果cpu资源较高，而i/o压力不高，优先分析读取频繁度
  - 程序中在封装的db类增加抽样日志即可，抽样比例酌情考虑，以不显著影响系统负载压力为底线。
  - 最多读取的数据表是哪个
  - 最多读取的数据SQL是什么
    - 该SQL进行explain 和set profiling判定
    - 注意判定时需要避免query cache影响
      - 比如，在这个SQL末尾增加一个条件子句 and 1=1 就可以避免从query cache中获取数据，而得到真实的执行状态分析。
  - 是否存在同一个查询短期内频繁出现的情况
    - 涉及前端缓存优化

## 制定方案

抓大放小，解决显著问题

- 不苛求解决所有优化问题，但是应以保证线上服务稳定可靠为目标。
- 解决与评估要同时进行，新的策略或解决方案务必经过评估后上线。

## 测试方案

确认优化方案的覆盖范围，不要为了解决1%的问题而忽略了99%的问题，并且不能带来新的问题（索引滥用，太多索引，导致 dml 效率降低）而且最好再测试环境验证通过后再上线

## 实施方案

## 回顾反馈

# 案例分析

## 服务器出现too many connections 阻塞

入手点：
- 查看服务器状态，cpu占用，内存占用，硬盘占用，硬盘i/o压力
- 查看网络流量状态，mysql与应用服务器的输入输出状况
- 通过Show processlist查看当前运行清单
- 注意事项，日常应用程序连接数据库不要使用root账户，保证故障时可以通过root 进入数据库查看 show processlist。

状态分析：
- 参见如上执行状态清单，根据连接状态的分布去确定原因。

紧急恢复
- 在确定故障原因后，应通过kill掉阻塞进程的方式 立即恢复数据库。

善后处理：以下针对常见问题简单解读
- Sleep 连接过多导致，应用端及时释放连接，排查关联因素。
- Locked连接过多，如源于myisam表级锁，更innodb引擎;如源于更新操作使用了不恰当的索引或未使用索引，改写更新操作SQL或建立恰当索引。
- Sending data连接过多，用影响结果集的思路优化SQL查询，优化表索引结构。
- Free items连接过多，i/o压力过大 或硬盘故障
- Waiting for net , writing to net 连接过多， mysql与应用服务器连接阻塞。
- 其他仍参见如上执行状态清单所示分析。
- 如涉及不十分严格安全要求的数据内容，可用定期脚本跟踪请求进程，并kill掉僵死进程。如数据安全要求较严格，则不能如此进行。

## 数据库负载过高，响应缓慢

**入手点：**
- 查看cpu状态，服务器负载构成

**可能问题1：i/o占用过高**
  - 步骤1： 检查内存是否占用swap分区，排除因内存不足导致的i/o开销。
  - 步骤2：通过iostat 指令分析i/o是否集中于数据库硬盘，是否是写入度较高。
  - 步骤3：如果压力来自于写，使用mysqlbinlog 解开最新的binlog文件。
  - 步骤4：编写日志分析脚本或grep指令，分析每秒写入频度和写入内容。
    - 写入频度不高，则说明i/o压力另有原因或数据库配置不合理。
  - 步骤5：编写日志分析脚本或grep 指令，分析写入的数据表构成，和写入的目标构成。
  - 步骤6：编写日志分析脚本，分析是否存在同一主键的重复写入。 比如出现大量 update post set views=views+1 where tagid=的操作，假设在一段时间内出现了2万次，而其中不同的tagid有1万次，那么就是有50%的请求是重复update请求，有可以通过异步更新合并的空间。

提示一下，以上所提及的日志分析脚本编写，正常情况下不应超过1个小时，而对系统负载分析所提供的数据支持价值是巨大的，对性能优化方案的选择是非常有意义的，如果您认为这项工作是繁冗而且复杂的工作，那么一定是在分析思路和目标把握上出现了偏差。


**可能问题2：i/o占用不高，CPU 占用过高**
- 步骤1：查看慢查询日志
- 步骤2：不断刷新查看Show processlist清单，并把握可能频繁出现的处于Sending data状态的SQL。
- 步骤3：记录前端执行SQL
  - 于前端应用程序执行查询的封装对象内，设置随机采样，记录前端执行的SQL，保证有一定的样本规模，并且不会带来前端i/o负载的激增。
  - 基于采样率和记录频率，获得每秒读请求次数数据指标。
  - 编写日志分析脚本，分析采样的SQL构成，所操作的数据表，所操作的主键。
  - 对频繁重复读取的SQL(完全一致的SQL)进行判定，是否数据存在频繁变动，是否需要实时展现最新数据，如有可能，缓存化，并预估缓存命中率。
  - 对频繁读取但不重复的(SQL结构一致，但条件中的数据不一致)SQL进行判定，是否索引足够优化，影响结果集与输出结果是否足够接近。
- 步骤4：将导致慢查询的SQL或频繁出现于show processlist状态的SQL，或采样记录的频繁度SQL进行分析，按照影响结果集的思路和索引理解来优化。
- 步骤5：对如上难以界定问题的SQL进行 set profiling 分析。
- 步骤6：优化后分析继续采样跟踪分析。并跟踪比对结果。

**善后处理**
- 日常跟踪脚本，不断记录一些状态信息。保证每个时间节点都能回溯。
- 确保随时能了解服务器的请求频次，读写请求的分布。
- 记录一些未造成致命影响的隐患点，可暂不解决，但需要记录。
- 如确系服务器请求频次过高，可基于负载分布决定硬件扩容方案，比如i/o压力过高可考虑固态硬盘；内存占用swap可考虑增加内容容量等。用尽可能少的投入实现最好的负载支撑能力，而不是简单的买更多服务器。


<!--以下是脚注-->
